diff -urN --no-dereference glibc-clean/elf/elf.h glibc-workdir/elf/elf.h
--- glibc-clean/elf/elf.h
+++ glibc-workdir/elf/elf.h
@@ -372,6 +372,8 @@
 
 #define EM_ALPHA	0x9026
 
+#define EM_XR17032	0xb5f0
+
 /* Legal values for e_version (version).  */
 
 #define EV_NONE		0		/* Invalid ELF version */
@@ -4480,4 +4482,43 @@
 #define R_OR1K_TLS_DTPOFF	33
 #define R_OR1K_TLS_DTPMOD	34
 
+/* XR/17032 specific relocs. */
+#define R_XR17032_NONE		0
+#define R_XR17032_32		1
+#define R_XR17032_RELATIVE	2
+#define R_XR17032_IRELATIVE	3
+#define R_XR17032_JUMP_SLOT	4
+#define R_XR17032_COPY		5
+#define R_XR17032_TLS_TPREL	6
+#define R_XR17032_TLS_DTPMOD	7
+#define R_XR17032_TLS_DTPREL	8
+#define R_XR17032_8		9
+#define R_XR17032_16		10
+#define R_XR17032_8_PCREL	11
+#define R_XR17032_16_PCREL	12
+#define R_XR17032_32_PCREL	13
+#define R_XR17032_JUMP		14
+#define R_XR17032_BRANCH	15
+#define R_XR17032_IMM16		16
+#define R_XR17032_IMM16_1	17
+#define R_XR17032_IMM16_2	18
+#define R_XR17032_IMM16_16	19
+#define R_XR17032_IMM16_SIGNED	20
+#define R_XR17032_LO16		21
+#define R_XR17032_LO16_1	22
+#define R_XR17032_LO16_2	23
+#define R_XR17032_HI16		24
+#define R_XR17032_LO16_PCREL	25
+#define R_XR17032_LO16_1_PCREL	26
+#define R_XR17032_LO16_2_PCREL	27
+#define R_XR17032_HI16_PCREL	28
+#define R_XR17032_HI16_GOT	29
+#define R_XR17032_HI16_PLT	30
+#define R_XR17032_HI16_TLS_GOT	31
+#define R_XR17032_HI16_TLS_GD	32
+#define R_XR17032_LO16_TPREL	33
+#define R_XR17032_LO16_1_TPREL	34
+#define R_XR17032_LO16_2_TPREL	35
+#define R_XR17032_HI16_TPREL	36
+
 #endif	/* elf.h */
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/Implies glibc-workdir/sysdeps/unix/sysv/linux/xr17032/Implies
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/Implies	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/Implies
@@ -0,0 +1 @@
+xr17032/nptl
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/arch-syscall.h glibc-workdir/sysdeps/unix/sysv/linux/xr17032/arch-syscall.h
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/arch-syscall.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/arch-syscall.h
@@ -0,0 +1,312 @@
+/* AUTOGENERATED by update-syscall-lists.py.  */
+#define __NR_accept 202
+#define __NR_accept4 242
+#define __NR_acct 89
+#define __NR_add_key 217
+#define __NR_bind 200
+#define __NR_bpf 280
+#define __NR_brk 214
+#define __NR_cachestat 451
+#define __NR_capget 90
+#define __NR_capset 91
+#define __NR_chdir 49
+#define __NR_chroot 51
+#define __NR_clock_adjtime64 405
+#define __NR_clock_getres_time64 406
+#define __NR_clock_gettime64 403
+#define __NR_clock_nanosleep_time64 407
+#define __NR_clock_settime64 404
+#define __NR_clone 220
+#define __NR_clone3 435
+#define __NR_close 57
+#define __NR_close_range 436
+#define __NR_connect 203
+#define __NR_copy_file_range 285
+#define __NR_delete_module 106
+#define __NR_dup 23
+#define __NR_dup3 24
+#define __NR_epoll_create1 20
+#define __NR_epoll_ctl 21
+#define __NR_epoll_pwait 22
+#define __NR_epoll_pwait2 441
+#define __NR_eventfd2 19
+#define __NR_execve 221
+#define __NR_execveat 281
+#define __NR_exit 93
+#define __NR_exit_group 94
+#define __NR_faccessat 48
+#define __NR_faccessat2 439
+#define __NR_fadvise64_64 223
+#define __NR_fallocate 47
+#define __NR_fanotify_init 262
+#define __NR_fanotify_mark 263
+#define __NR_fchdir 50
+#define __NR_fchmod 52
+#define __NR_fchmodat 53
+#define __NR_fchmodat2 452
+#define __NR_fchown 55
+#define __NR_fchownat 54
+#define __NR_fcntl64 25
+#define __NR_fdatasync 83
+#define __NR_fgetxattr 10
+#define __NR_finit_module 273
+#define __NR_flistxattr 13
+#define __NR_flock 32
+#define __NR_fremovexattr 16
+#define __NR_fsconfig 431
+#define __NR_fsetxattr 7
+#define __NR_fsmount 432
+#define __NR_fsopen 430
+#define __NR_fspick 433
+#define __NR_fstatfs64 44
+#define __NR_fsync 82
+#define __NR_ftruncate64 46
+#define __NR_futex_requeue 456
+#define __NR_futex_time64 422
+#define __NR_futex_wait 455
+#define __NR_futex_waitv 449
+#define __NR_futex_wake 454
+#define __NR_get_mempolicy 236
+#define __NR_get_robust_list 100
+#define __NR_getcpu 168
+#define __NR_getcwd 17
+#define __NR_getdents64 61
+#define __NR_getegid 177
+#define __NR_geteuid 175
+#define __NR_getgid 176
+#define __NR_getgroups 158
+#define __NR_getitimer 102
+#define __NR_getpeername 205
+#define __NR_getpgid 155
+#define __NR_getpid 172
+#define __NR_getppid 173
+#define __NR_getpriority 141
+#define __NR_getrandom 278
+#define __NR_getresgid 150
+#define __NR_getresuid 148
+#define __NR_getrusage 165
+#define __NR_getsid 156
+#define __NR_getsockname 204
+#define __NR_getsockopt 209
+#define __NR_gettid 178
+#define __NR_getuid 174
+#define __NR_getxattr 8
+#define __NR_getxattrat 464
+#define __NR_init_module 105
+#define __NR_inotify_add_watch 27
+#define __NR_inotify_init1 26
+#define __NR_inotify_rm_watch 28
+#define __NR_io_cancel 3
+#define __NR_io_destroy 1
+#define __NR_io_pgetevents_time64 416
+#define __NR_io_setup 0
+#define __NR_io_submit 2
+#define __NR_io_uring_enter 426
+#define __NR_io_uring_register 427
+#define __NR_io_uring_setup 425
+#define __NR_ioctl 29
+#define __NR_ioprio_get 31
+#define __NR_ioprio_set 30
+#define __NR_kcmp 272
+#define __NR_kexec_file_load 294
+#define __NR_kexec_load 104
+#define __NR_keyctl 219
+#define __NR_kill 129
+#define __NR_landlock_add_rule 445
+#define __NR_landlock_create_ruleset 444
+#define __NR_landlock_restrict_self 446
+#define __NR_lgetxattr 9
+#define __NR_linkat 37
+#define __NR_listen 201
+#define __NR_listmount 458
+#define __NR_listxattr 11
+#define __NR_listxattrat 465
+#define __NR_llistxattr 12
+#define __NR_llseek 62
+#define __NR_lookup_dcookie 18
+#define __NR_lremovexattr 15
+#define __NR_lsetxattr 6
+#define __NR_lsm_get_self_attr 459
+#define __NR_lsm_list_modules 461
+#define __NR_lsm_set_self_attr 460
+#define __NR_madvise 233
+#define __NR_map_shadow_stack 453
+#define __NR_mbind 235
+#define __NR_membarrier 283
+#define __NR_memfd_create 279
+#define __NR_migrate_pages 238
+#define __NR_mincore 232
+#define __NR_mkdirat 34
+#define __NR_mknodat 33
+#define __NR_mlock 228
+#define __NR_mlock2 284
+#define __NR_mlockall 230
+#define __NR_mmap2 222
+#define __NR_mount 40
+#define __NR_mount_setattr 442
+#define __NR_move_mount 429
+#define __NR_move_pages 239
+#define __NR_mprotect 226
+#define __NR_mq_getsetattr 185
+#define __NR_mq_notify 184
+#define __NR_mq_open 180
+#define __NR_mq_timedreceive_time64 419
+#define __NR_mq_timedsend_time64 418
+#define __NR_mq_unlink 181
+#define __NR_mremap 216
+#define __NR_mseal 462
+#define __NR_msgctl 187
+#define __NR_msgget 186
+#define __NR_msgrcv 188
+#define __NR_msgsnd 189
+#define __NR_msync 227
+#define __NR_munlock 229
+#define __NR_munlockall 231
+#define __NR_munmap 215
+#define __NR_name_to_handle_at 264
+#define __NR_nfsservctl 42
+#define __NR_open_by_handle_at 265
+#define __NR_open_tree 428
+#define __NR_open_tree_attr 467
+#define __NR_openat 56
+#define __NR_openat2 437
+#define __NR_perf_event_open 241
+#define __NR_personality 92
+#define __NR_pidfd_getfd 438
+#define __NR_pidfd_open 434
+#define __NR_pidfd_send_signal 424
+#define __NR_pipe2 59
+#define __NR_pivot_root 41
+#define __NR_pkey_alloc 289
+#define __NR_pkey_free 290
+#define __NR_pkey_mprotect 288
+#define __NR_ppoll_time64 414
+#define __NR_prctl 167
+#define __NR_pread64 67
+#define __NR_preadv 69
+#define __NR_preadv2 286
+#define __NR_prlimit64 261
+#define __NR_process_madvise 440
+#define __NR_process_mrelease 448
+#define __NR_process_vm_readv 270
+#define __NR_process_vm_writev 271
+#define __NR_pselect6_time64 413
+#define __NR_ptrace 117
+#define __NR_pwrite64 68
+#define __NR_pwritev 70
+#define __NR_pwritev2 287
+#define __NR_quotactl 60
+#define __NR_quotactl_fd 443
+#define __NR_read 63
+#define __NR_readahead 213
+#define __NR_readlinkat 78
+#define __NR_readv 65
+#define __NR_reboot 142
+#define __NR_recvfrom 207
+#define __NR_recvmmsg_time64 417
+#define __NR_recvmsg 212
+#define __NR_remap_file_pages 234
+#define __NR_removexattr 14
+#define __NR_removexattrat 466
+#define __NR_renameat2 276
+#define __NR_request_key 218
+#define __NR_restart_syscall 128
+#define __NR_rseq 293
+#define __NR_rt_sigaction 134
+#define __NR_rt_sigpending 136
+#define __NR_rt_sigprocmask 135
+#define __NR_rt_sigqueueinfo 138
+#define __NR_rt_sigreturn 139
+#define __NR_rt_sigsuspend 133
+#define __NR_rt_sigtimedwait_time64 421
+#define __NR_rt_tgsigqueueinfo 240
+#define __NR_sched_get_priority_max 125
+#define __NR_sched_get_priority_min 126
+#define __NR_sched_getaffinity 123
+#define __NR_sched_getattr 275
+#define __NR_sched_getparam 121
+#define __NR_sched_getscheduler 120
+#define __NR_sched_rr_get_interval_time64 423
+#define __NR_sched_setaffinity 122
+#define __NR_sched_setattr 274
+#define __NR_sched_setparam 118
+#define __NR_sched_setscheduler 119
+#define __NR_sched_yield 124
+#define __NR_seccomp 277
+#define __NR_semctl 191
+#define __NR_semget 190
+#define __NR_semop 193
+#define __NR_semtimedop_time64 420
+#define __NR_sendfile64 71
+#define __NR_sendmmsg 269
+#define __NR_sendmsg 211
+#define __NR_sendto 206
+#define __NR_set_mempolicy 237
+#define __NR_set_mempolicy_home_node 450
+#define __NR_set_robust_list 99
+#define __NR_set_tid_address 96
+#define __NR_setdomainname 162
+#define __NR_setfsgid 152
+#define __NR_setfsuid 151
+#define __NR_setgid 144
+#define __NR_setgroups 159
+#define __NR_sethostname 161
+#define __NR_setitimer 103
+#define __NR_setns 268
+#define __NR_setpgid 154
+#define __NR_setpriority 140
+#define __NR_setregid 143
+#define __NR_setresgid 149
+#define __NR_setresuid 147
+#define __NR_setreuid 145
+#define __NR_setsid 157
+#define __NR_setsockopt 208
+#define __NR_setuid 146
+#define __NR_setxattr 5
+#define __NR_setxattrat 463
+#define __NR_shmat 196
+#define __NR_shmctl 195
+#define __NR_shmdt 197
+#define __NR_shmget 194
+#define __NR_shutdown 210
+#define __NR_sigaltstack 132
+#define __NR_signalfd4 74
+#define __NR_socket 198
+#define __NR_socketpair 199
+#define __NR_splice 76
+#define __NR_statfs64 43
+#define __NR_statmount 457
+#define __NR_statx 291
+#define __NR_swapoff 225
+#define __NR_swapon 224
+#define __NR_symlinkat 36
+#define __NR_sync 81
+#define __NR_sync_file_range 84
+#define __NR_syncfs 267
+#define __NR_sysinfo 179
+#define __NR_syslog 116
+#define __NR_tee 77
+#define __NR_tgkill 131
+#define __NR_timer_create 107
+#define __NR_timer_delete 111
+#define __NR_timer_getoverrun 109
+#define __NR_timer_gettime64 408
+#define __NR_timer_settime64 409
+#define __NR_timerfd_create 85
+#define __NR_timerfd_gettime64 410
+#define __NR_timerfd_settime64 411
+#define __NR_times 153
+#define __NR_tkill 130
+#define __NR_truncate64 45
+#define __NR_umask 166
+#define __NR_umount2 39
+#define __NR_uname 160
+#define __NR_unlinkat 35
+#define __NR_unshare 97
+#define __NR_userfaultfd 282
+#define __NR_utimensat_time64 412
+#define __NR_vhangup 58
+#define __NR_vmsplice 75
+#define __NR_waitid 95
+#define __NR_write 64
+#define __NR_writev 66
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/bits/procfs.h glibc-workdir/sysdeps/unix/sysv/linux/xr17032/bits/procfs.h
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/bits/procfs.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/bits/procfs.h
@@ -0,0 +1,30 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_PROCFS_H
+# error "Never include <bits/procfs.h> directly; use <sys/procfs.h> instead."
+#endif
+
+#include <sys/ucontext.h>
+
+/* ELF register definitions */
+#define ELF_NGREG	NGREG
+#define ELF_NFPREG	NFPREG
+
+typedef unsigned long int elf_greg_t;
+typedef unsigned long int elf_gregset_t[32];
+typedef unsigned int elf_fpregset_t;
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/bits/sigcontext.h glibc-workdir/sysdeps/unix/sysv/linux/xr17032/bits/sigcontext.h
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/bits/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/bits/sigcontext.h
@@ -0,0 +1,30 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H 1
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+struct sigcontext {
+	/* gregs[0] holds the program counter.  */
+	unsigned long int gregs[32];
+};
+
+#endif
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/clone.S glibc-workdir/sysdeps/unix/sysv/linux/xr17032/clone.S
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/clone.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/clone.S
@@ -0,0 +1,92 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#include <tls.h>
+#include "tcb-offsets.h"
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     void *parent_tidptr, void *tls, void *child_tidptr) */
+
+	.text
+LEAF (__clone)
+
+	/* Sanity check arguments.  */
+	beq		a0,L (invalid)	/* No NULL function pointers.  */
+	beq		a1,L (invalid)	/* No NULL stack pointers.  */
+
+	subi		a1,a1,8		/* Reserve argument save space.  */
+	mov		long [a1],a0	/* Save function pointer.  */
+	mov		long [a1+4],a3	/* Save argument pointer.  */
+
+	/* The syscall expects the args to be in different slots.  */
+	add		a0,a2,zero
+	mov		a2,long [sp]
+	mov		a3,long [sp+4]
+	mov		t0,long [sp+8]
+
+	/* Do the system call.  */
+	addi		t5,zero,__NR_clone
+	sys
+
+	blt		a3,L (error)
+	beq		a3,L (thread_start)
+
+	/* Successful return from the parent.  */
+	jalr		zero,lr,0
+
+L (invalid):
+	subi		a3, zero, EINVAL
+	/* Something bad happened -- no child created.  */
+L (error):
+1:	adr		t1, %pcrel_hi(__syscall_error)
+	jalr		zero, t1, %pcrel_lo(1b)
+	END (__clone)
+
+/* Load up the arguments to the function.  Put this block of code in
+   its own function so that we can terminate the stack trace with our
+   debug info.  */
+
+ENTRY (__thread_start)
+L (thread_start):
+	/* Terminate call stack by noting lr is undefined.  Use a dummy
+	   .cfi_label to force starting the FDE.  */
+	.cfi_label .Ldummy
+	cfi_undefined (lr)
+
+	/* Restore the arg for user's function.  */
+	mov		a1,long [sp]	/* Function pointer.  */
+	mov		a0,long [sp+4]	/* Argument pointer.  */
+
+	/* Call the user's function.  */
+	jalr		lr, a1, 0
+
+	/* Call exit with the function's return value.  */
+	addi		t5, zero, __NR_exit
+	add		a0, a3, zero
+	sys
+
+	END (__thread_start)
+
+libc_hidden_def (__clone)
+weak_alias (__clone, clone)
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/clone3.S glibc-workdir/sysdeps/unix/sysv/linux/xr17032/clone3.S
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/clone3.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/clone3.S
@@ -0,0 +1,79 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <asm/errno.h>
+#include <sys/asm.h>
+#include <sysdep.h>
+
+/* The userland implementation is:
+   int clone3 (struct clone_args *cl_args, size_t size,
+               int (*func)(void *arg), void *arg);
+
+   the kernel entry is:
+   int clone3 (struct clone_args *cl_args, size_t size);
+
+   The parameters are passed in registers from userland:
+   a0: cl_args
+   a1: size
+   a2: func
+   a3: arg  */
+
+        .text
+ENTRY(__clone3)
+	/* Sanity check args.  */
+	beq	a0, L(invalid)	/* No NULL cl_args pointer.  */
+	beq	a2, L(invalid)  /* No NULL function pointer.  */
+
+	/* Do the system call, the kernel expects:
+	   t5: system call number
+	   a0: cl_args
+	   a1: size  */
+	addi	t5, zero, __NR_clone3
+	sys
+
+	blt	t5, L(error)
+	beq	t5, L(thread_start)
+
+	jalr	zero, lr, 0
+
+L(invalid):
+	subi	a3, zero, EINVAL
+L(error):
+	add	a0, a3, zero
+1:	adr	t1, %pcrel_hi(__syscall_error)
+	jalr	zero, t1, %pcrel_lo(1b)
+END (__clone3)
+
+ENTRY(__thread_start_clone3)
+L(thread_start):
+	/* Terminate call stack by noting lr is undefined.  Use a dummy
+	   .cfi_label to force starting the FDE.  */
+	.cfi_label .Ldummy
+	cfi_undefined (lr)
+
+	/* Restore the arg for user's function and call the user's
+	   function.  */
+	add		a0, a3, zero	/* Argument pointer.  */
+	jalr		lr, a2, 0
+
+	/* Call exit with the function's return value.  */
+	addi		t5, zero, __NR_exit
+	add		a0, a3, zero
+	sys
+END(__thread_start_clone3)
+
+libc_hidden_def (__clone3)
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/shlib-versions glibc-workdir/sysdeps/unix/sysv/linux/xr17032/shlib-versions
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/shlib-versions	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/shlib-versions
@@ -0,0 +1,2 @@
+DEFAULT		GLIBC_2.33
+ld=ld-linux.so.1
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/sys/ucontext.h glibc-workdir/sysdeps/unix/sysv/linux/xr17032/sys/ucontext.h
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/sys/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/sys/ucontext.h
@@ -0,0 +1,80 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Don't rely on this, the interface is currently messed up and may need to
+ be broken to be fixed.*  */
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+
+#include <bits/types/sigset_t.h>
+#include <bits/types/stack_t.h>
+
+typedef unsigned long int __xr17032_mc_gp_state[32];
+
+#ifdef __USE_MISC
+# define NGREG	32
+
+# define REG_PC 0
+# define REG_A0 7
+# define REG_NARGS 4
+# define REG_S0 11
+# define REG_S1 12
+# define REG_S2 13
+# define REG_TP 29
+# define REG_SP 30
+# define REG_LR 31
+
+typedef unsigned long int greg_t;
+
+/* Container for all general registers.  */
+typedef __xr17032_mc_gp_state gregset_t;
+
+/* Container for floating-point state.  */
+typedef unsigned int fpregset_t;
+#endif
+
+typedef struct mcontext_t
+  {
+    __xr17032_mc_gp_state __gregs;
+  } mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext_t
+  {
+    unsigned long int  __uc_flags;
+    struct ucontext_t *uc_link;
+    stack_t            uc_stack;
+    sigset_t           uc_sigmask;
+    /* There's some padding here to allow sigset_t to be expanded in the
+       future.  Though this is unlikely, other architectures put uc_sigmask
+       at the end of this structure and explicitly state it can be
+       expanded, so we didn't want to box ourselves in here.  */
+    char               __glibc_reserved[1024 / 8 - sizeof (sigset_t)];
+    /* We can't put uc_sigmask at the end of this structure because we need
+       to be able to expand sigcontext in the future.  For example, the
+       vector ISA extension will almost certainly add ISA state.  We want
+       to ensure all user-visible ISA state can be saved and restored via a
+       ucontext, so we're putting this at the end in order to allow for
+       infinite extensibility.  Since we know this will be extended and we
+       assume sigset_t won't be extended an extreme amount, we're
+       prioritizing this.  */
+    mcontext_t uc_mcontext;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/sys/user.h glibc-workdir/sysdeps/unix/sysv/linux/xr17032/sys/user.h
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/sys/user.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/sys/user.h
@@ -0,0 +1,23 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H	1
+
+
+
+#endif	/* _SYS_USER_H */
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/syscall_cancel.S glibc-workdir/sysdeps/unix/sysv/linux/xr17032/syscall_cancel.S
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/syscall_cancel.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/syscall_cancel.S
@@ -0,0 +1,60 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <descr-const.h>
+
+/* long int __syscall_cancel_arch (int *cancelhandling,
+				   __syscall_arg_t nr,
+				   __syscall_arg_t arg1,
+				   __syscall_arg_t arg2,
+				   __syscall_arg_t arg3,
+				   __syscall_arg_t arg4,
+				   __syscall_arg_t arg5,
+				   __syscall_arg_t arg6)  */
+
+ENTRY (__syscall_cancel_arch)
+
+	.globl __syscall_cancel_arch_start
+__syscall_cancel_arch_start:
+	mov	t1, long [a0]
+	/* if (*ch & CANCELED_BITMASK)  */
+	andi	t1, t1, TCB_CANCELED_BITMASK
+	bne	t1, 1f
+
+	add	t5, a1, zero
+	add	a0, a2, zero
+	add	a1, a3, zero
+	mov	a2, long [sp]
+	mov	a3, long [sp + 4]
+	mov	t0, long [sp + 8]
+	mov	t1, long [sp + 12]
+	sys
+
+	.globl __syscall_cancel_arch_end
+__syscall_cancel_arch_end:
+	ret
+
+1:
+	subi	sp, sp, 4
+	cfi_def_cfa_offset (4)
+	mov	long [sp], lr
+	cfi_offset (lr, -4)
+1:	adr	lr, %pcrel_hi(__syscall_do_cancel)
+	jalr	lr, lr, %pcrel_lo(1b)
+
+END (__syscall_cancel_arch)
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/sysdep.S glibc-workdir/sysdeps/unix/sysv/linux/xr17032/sysdep.S
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/sysdep.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/sysdep.S
@@ -0,0 +1,51 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+#if IS_IN (libc)
+# define errno __libc_errno
+#endif
+
+ENTRY (__syscall_error)
+	add t0, lr, zero
+	/* Fall through to __syscall_set_errno.  */
+END (__syscall_error)
+
+/* Non-standard calling convention: argument in a0, return address in t0,
+   and clobber only t1.  */
+ENTRY (__syscall_set_errno)
+	/* We got here because a0 < 0, but only codes in the range [-4095, -1]
+	  represent errors.  Otherwise, just return the result normally.  */
+	slti signed t1, a0, -4095
+	bne t1, 1f
+	sub a3, zero, a0
+#if RTLD_PRIVATE_ERRNO
+1:	adr t1, %pcrel_hi(rtld_errno)
+	mov long [t1 + %pcrel_lo(1b)], a3
+#elif defined(__PIC__)
+1:	adr t1, %tls_ie_pcrel_hi(errno)
+	mov t1, long [t1 + %pcrel_lo(1b)]
+	mov long [t1 + tp], a3
+#else
+	lui t1, %tprel_hi(errno)
+	add t1, t1, tp
+	mov long [t1 + %tprel_lo(errno)], a3
+#endif
+	subi a3, zero, 1
+1:	jalr zero, t0, 0
+END (__syscall_set_errno)
diff -urN --no-dereference glibc-clean/sysdeps/unix/sysv/linux/xr17032/sysdep.h glibc-workdir/sysdeps/unix/sysv/linux/xr17032/sysdep.h
--- glibc-clean/sysdeps/unix/sysv/linux/xr17032/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/unix/sysv/linux/xr17032/sysdep.h
@@ -0,0 +1,332 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _LINUX_XR17032_SYSDEP_H
+#define _LINUX_XR17032_SYSDEP_H 1
+
+#include <sysdeps/unix/sysv/linux/sysdep.h>
+#include <sysdeps/unix/sysdep.h>
+#include <tls.h>
+
+#undef SYS_ify
+#define SYS_ify(syscall_name)	__NR_##syscall_name
+
+/* Workarounds for generic code needing to handle 64-bit time_t.  */
+
+/* Fix sysdeps/unix/sysv/linux/clock_getcpuclockid.c.  */
+#define __NR_clock_getres	__NR_clock_getres_time64
+/* Fix sysdeps/nptl/lowlevellock-futex.h.  */
+#define __NR_futex		__NR_futex_time64
+/* Fix sysdeps/unix/sysv/linux/pause.c.  */
+#define __NR_ppoll		__NR_ppoll_time64
+/* Fix sysdeps/unix/sysv/linux/select.c.  */
+#define __NR_pselect6		__NR_pselect6_time64
+/* Fix sysdeps/unix/sysv/linux/recvmmsg.c.  */
+#define __NR_recvmmsg		__NR_recvmmsg_time64
+/* Fix sysdeps/unix/sysv/linux/sigtimedwait.c.  */
+#define __NR_rt_sigtimedwait	__NR_rt_sigtimedwait_time64
+/* Fix sysdeps/unix/sysv/linux/semtimedop.c.  */
+#define __NR_semtimedop		__NR_semtimedop_time64
+/* Hack sysdeps/unix/sysv/linux/generic/utimes.c.  */
+#define __NR_utimensat		__NR_utimensat_time64
+
+#ifdef __ASSEMBLER__
+
+# include <sys/asm.h>
+
+# define ENTRY(name) LEAF(name)
+
+# define L(label) .L ## label
+
+/* Performs a system call, handling errors by setting errno.  Linux indicates
+   errors by setting a3 to a value between -1 and -4095.  */
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)			\
+  .text;							\
+  .balign 4;							\
+  ENTRY (name);							\
+.if args >= 5;							\
+  mov t0, long [sp];						\
+.endif;								\
+.if args >= 6;							\
+  mov t1, long [sp + 4];					\
+.endif;								\
+  addi t5, zero, SYS_ify (syscall_name);			\
+  sys;								\
+  bge a3, 1f;							\
+  addi t5, a3, 4096;						\
+  bgt t5, .Lsyscall_error ## name;				\
+1:;
+
+# undef PSEUDO_END
+# define PSEUDO_END(sym) 					\
+  SYSCALL_ERROR_HANDLER (sym)					\
+  jalr zero, lr, 0;						\
+  END (sym)
+
+# if !IS_IN (libc)
+#  if RTLD_PRIVATE_ERRNO
+#   define SYSCALL_ERROR_HANDLER(name)				\
+.Lsyscall_error ## name:					\
+	sub a3, zero, a3;					\
+1:	adr t1, %pcrel_hi(rtld_errno);				\
+	mov long [t1 + %pcrel_lo(1b)], a3;			\
+	subi a3, zero, 1;
+#  elif defined (__PIC__)
+#   define SYSCALL_ERROR_HANDLER(name)				\
+.Lsyscall_error ## name:					\
+	sub a3, zero, a3;					\
+1:	adr t1, %tls_ie_pcrel_hi(errno);			\
+	mov t1, long [t1 + %pcrel_lo(1b)];			\
+	mov long [tp + t1], a3;					\
+	subi a3, zero, 1;
+#  else
+#   define SYSCALL_ERROR_HANDLER(name)				\
+.Lsyscall_error ## name:					\
+	sub a3, zero, a3;					\
+	lui t1, %tprel_hi(errno);				\
+	add t1, t1, tp;						\
+	mov long [t1 + %tprel_lo(errno)], a3;			\
+	subi a3, zero, 1;
+#  endif
+# else
+#  define SYSCALL_ERROR_HANDLER(name)				\
+.Lsyscall_error ## name:					\
+	add a0, a3, zero;					\
+1:	adr t1, %pcrel_hi(__syscall_error);			\
+        jalr zero, t1, %pcrel_lo(1b);
+# endif
+
+/* Performs a system call, not setting errno.  */
+# undef PSEUDO_NEORRNO
+# define PSEUDO_NOERRNO(name, syscall_name, args)	\
+  .align 2;						\
+  ENTRY (name);						\
+.if args >= 5;						\
+  mov t0, long [sp];					\
+.endif;							\
+.if args >= 6;						\
+  mov t1, long [sp + 4];				\
+.endif;							\
+  addi t5, zero, SYS_ify (syscall_name);		\
+  sys;
+
+# undef PSEUDO_END_NOERRNO
+# define PSEUDO_END_NOERRNO(name)			\
+  END (name)
+
+# undef ret_NOERRNO
+# define ret_NOERRNO jalr zero, lr, 0
+
+/* Performs a system call, returning the error code.  */
+# undef PSEUDO_ERRVAL
+# define PSEUDO_ERRVAL(name, syscall_name, args) 	\
+  PSEUDO_NOERRNO (name, syscall_name, args)		\
+  sub a3, zero, a3;
+
+# undef PSEUDO_END_ERRVAL
+# define PSEUDO_END_ERRVAL(name)			\
+  END (name)
+
+# undef ret_ERRVAL
+# define ret_ERRVAL jalr zero, lr, 0
+
+# undef ret
+# define ret jalr zero, lr, 0
+
+#else /* !__ASSEMBLER__ */
+
+# define VDSO_NAME	"LINUX_5.4"
+# define VDSO_HASH	61765876
+
+# define HAVE_CLONE3_WRAPPER		1
+
+# undef HAVE_INTERNAL_BRK_ADDR_SYMBOL
+# define HAVE_INTERNAL_BRK_ADDR_SYMBOL 1
+
+# define INTERNAL_SYSCALL(name, nr, args...) \
+	internal_syscall##nr (SYS_ify (name), args)
+
+# define INTERNAL_SYSCALL_NCS(number, nr, args...) \
+	internal_syscall##nr (number, args)
+
+# define internal_syscall0(number, dummy...)			\
+({ 									\
+	long int _sys_result;						\
+									\
+	{								\
+	register long int __t5 asm ("t5") = number;			\
+	register long int __a3 asm ("a3");				\
+	__asm__ volatile ( 						\
+	"sys\n\t" 							\
+	: "=r" (__a3)							\
+	: "r" (__t5)							\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a3;						\
+	}								\
+	_sys_result;							\
+})
+
+# define internal_syscall1(number, arg0)				\
+({ 									\
+	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+									\
+	{								\
+	register long int __t5 asm ("t5") = number;			\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a3 asm ("a3");				\
+	__asm__ volatile ( 						\
+	"sys\n\t" 							\
+	: "=r" (__a3)							\
+	: "r" (__t5), "r" (__a0)					\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a3;						\
+	}								\
+	_sys_result;							\
+})
+
+# define internal_syscall2(number, arg0, arg1)	    			\
+({ 									\
+	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
+									\
+	{								\
+	register long int __t5 asm ("t5") = number;			\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
+	register long int __a3 asm ("a3");				\
+	__asm__ volatile ( 						\
+	"sys\n\t" 							\
+	: "=r" (__a3)							\
+	: "r" (__t5), "r" (__a0), "r" (__a1)				\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a3;						\
+	}								\
+	_sys_result;							\
+})
+
+# define internal_syscall3(number, arg0, arg1, arg2)      		\
+({ 									\
+	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+									\
+	{								\
+	register long int __t5 asm ("t5") = number;			\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
+	register long int __a2 asm ("a2") = _arg2;			\
+	register long int __a3 asm ("a3");				\
+	__asm__ volatile ( 						\
+	"sys\n\t" 							\
+	: "=r" (__a3)							\
+	: "r" (__t5), "r" (__a0), "r" (__a1), "r" (__a2)		\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a3;						\
+	}								\
+	_sys_result;							\
+})
+
+# define internal_syscall4(number, arg0, arg1, arg2, arg3)	  \
+({ 									\
+	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
+									\
+	{								\
+	register long int __t5 asm ("t5") = number;			\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
+	register long int __a2 asm ("a2") = _arg2;			\
+	register long int __a3 asm ("a3") = _arg3;			\
+	__asm__ volatile ( 						\
+	"sys\n\t" 							\
+	: "+r" (__a3)							\
+	: "r" (__t5), "r" (__a0), "r" (__a1), "r" (__a2)		\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a3;						\
+	}								\
+	_sys_result;							\
+})
+
+# define internal_syscall5(number, arg0, arg1, arg2, arg3, arg4)   \
+({ 									\
+	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
+	long int _arg4 = (long int) (arg4);				\
+									\
+	{								\
+	register long int __t5 asm ("t5") = number;			\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
+	register long int __a2 asm ("a2") = _arg2;			\
+	register long int __a3 asm ("a3") = _arg3;			\
+	register long int __t0 asm ("t0") = _arg4;			\
+	__asm__ volatile ( 						\
+	"sys\n\t" 							\
+	: "+r" (__a3)							\
+	: "r" (__t5), "r"(__a0), "r"(__a1), "r"(__a2), "r" (__t0)	\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a3;						\
+	}								\
+	_sys_result;							\
+})
+
+# define internal_syscall6(number, arg0, arg1, arg2, arg3, arg4, arg5) \
+({ 									\
+	long int _sys_result;						\
+	long int _arg0 = (long int) (arg0);				\
+	long int _arg1 = (long int) (arg1);				\
+	long int _arg2 = (long int) (arg2);				\
+	long int _arg3 = (long int) (arg3);				\
+	long int _arg4 = (long int) (arg4);				\
+	long int _arg5 = (long int) (arg5);				\
+									\
+	{								\
+	register long int __t5 asm ("t5") = number;			\
+	register long int __a0 asm ("a0") = _arg0;			\
+	register long int __a1 asm ("a1") = _arg1;			\
+	register long int __a2 asm ("a2") = _arg2;			\
+	register long int __a3 asm ("a3") = _arg3;			\
+	register long int __t0 asm ("t0") = _arg4;			\
+	register long int __t1 asm ("t1") = _arg5;			\
+	__asm__ volatile ( 						\
+	"sys\n\t" 							\
+	: "+r" (__a3)							\
+	: "r" (__t5), "r" (__a0), "r" (__a1), "r" (__a2),		\
+	  "r" (__t0), "r" (__t1)					\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a3;						\
+	}								\
+	_sys_result;							\
+})
+
+# define __SYSCALL_CLOBBERS "memory"
+
+extern long int __syscall_error (long int neg_errno);
+
+#endif /* ! __ASSEMBLER__ */
+
+#endif /* _LINUX_XR17032_SYSDEP_H */
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/Implies glibc-workdir/sysdeps/xr17032/Implies
--- glibc-clean/sysdeps/xr17032/Implies	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/Implies
@@ -0,0 +1,2 @@
+ieee754/dbl-64
+ieee754/flt-32
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/Makefile glibc-workdir/sysdeps/xr17032/Makefile
--- glibc-clean/sysdeps/xr17032/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/Makefile
@@ -0,0 +1,7 @@
+ifeq ($(subdir),misc)
+sysdep_headers += sys/asm.h
+endif
+
+ifeq ($(subdir),elf)
+gen-as-const-headers += dl-link.sym
+endif
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/__longjmp.S glibc-workdir/sysdeps/xr17032/__longjmp.S
--- glibc-clean/sysdeps/xr17032/__longjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/__longjmp.S
@@ -0,0 +1,46 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (__longjmp)
+	mov lr,  long [a0 + 0x00]
+	mov s0,  long [a0 + 0x04]
+	mov s1,  long [a0 + 0x08]
+	mov s2,  long [a0 + 0x0c]
+	mov s3,  long [a0 + 0x10]
+	mov s4,  long [a0 + 0x14]
+	mov s5,  long [a0 + 0x18]
+	mov s6,  long [a0 + 0x1c]
+	mov s7,  long [a0 + 0x20]
+	mov s8,  long [a0 + 0x24]
+	mov s9,  long [a0 + 0x28]
+	mov s10, long [a0 + 0x2c]
+	mov s11, long [a0 + 0x30]
+	mov s12, long [a0 + 0x34]
+	mov s13, long [a0 + 0x38]
+	mov s14, long [a0 + 0x3c]
+	mov s15, long [a0 + 0x40]
+	mov s16, long [a0 + 0x44]
+	mov s17, long [a0 + 0x48]
+	mov sp,  long [a0 + 0x4c]
+
+	slti a0, a1, 1
+	add  a0, a0, a1   # a0 = (a1 == 0) ? 1 : a1
+	jalr zero, lr, 0
+END (__longjmp)
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/atomic-machine.h glibc-workdir/sysdeps/xr17032/atomic-machine.h
--- glibc-clean/sysdeps/xr17032/atomic-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/atomic-machine.h
@@ -0,0 +1,127 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _XR17032_BITS_ATOMIC_H
+#define _XR17032_BITS_ATOMIC_H 1
+
+#define atomic_full_barrier() __sync_synchronize ()
+
+#define __HAVE_64B_ATOMICS 0
+#define USE_ATOMIC_COMPILER_BUILTINS 1
+#define ATOMIC_EXCHANGE_USES_CAS 0
+
+/* Compare and exchange.
+   For all "bool" routines, we return FALSE if exchange successful.  */
+
+# define __arch_compare_and_exchange_bool_8_int(mem, newval, oldval, model) \
+  ({									\
+    typeof (*mem) __oldval = (oldval);					\
+    !__atomic_compare_exchange_n (mem, (void *) &__oldval, newval, 0,	\
+				  model, __ATOMIC_RELAXED);		\
+  })
+
+# define __arch_compare_and_exchange_bool_16_int(mem, newval, oldval, model) \
+  ({									\
+    typeof (*mem) __oldval = (oldval);					\
+    !__atomic_compare_exchange_n (mem, (void *) &__oldval, newval, 0,	\
+				  model, __ATOMIC_RELAXED);		\
+  })
+
+# define __arch_compare_and_exchange_bool_32_int(mem, newval, oldval, model) \
+  ({									\
+    typeof (*mem) __oldval = (oldval);					\
+    !__atomic_compare_exchange_n (mem, (void *) &__oldval, newval, 0,	\
+				  model, __ATOMIC_RELAXED);		\
+  })
+
+#  define __arch_compare_and_exchange_bool_64_int(mem, newval, oldval, model) \
+  ({									\
+    typeof (*mem) __oldval = (oldval);					\
+    !__atomic_compare_exchange_n (mem, (void *) &__oldval, newval, 0,	\
+				  model, __ATOMIC_RELAXED);		\
+  })
+
+# define __arch_compare_and_exchange_val_8_int(mem, newval, oldval, model) \
+  ({									\
+    typeof (*mem) __oldval = (oldval);					\
+    __atomic_compare_exchange_n (mem, (void *) &__oldval, newval, 0,	\
+				 model, __ATOMIC_RELAXED);		\
+    __oldval;								\
+  })
+
+# define __arch_compare_and_exchange_val_16_int(mem, newval, oldval, model) \
+  ({									\
+    typeof (*mem) __oldval = (oldval);					\
+    __atomic_compare_exchange_n (mem, (void *) &__oldval, newval, 0,	\
+				 model, __ATOMIC_RELAXED);		\
+    __oldval;								\
+  })
+
+# define __arch_compare_and_exchange_val_32_int(mem, newval, oldval, model) \
+  ({									\
+    typeof (*mem) __oldval = (oldval);					\
+    __atomic_compare_exchange_n (mem, (void *) &__oldval, newval, 0,	\
+				 model, __ATOMIC_RELAXED);		\
+    __oldval;								\
+  })
+
+# define __arch_compare_and_exchange_val_64_int(mem, newval, oldval, model) \
+  ({									\
+    typeof (*mem) __oldval = (oldval);					\
+    __atomic_compare_exchange_n (mem, (void *) &__oldval, newval, 0,	\
+				 model, __ATOMIC_RELAXED);		\
+    __oldval;								\
+  })
+
+/* Atomic compare and exchange.  */
+
+# define atomic_compare_and_exchange_bool_acq(mem, new, old)	\
+  __atomic_bool_bysize (__arch_compare_and_exchange_bool, int,	\
+			mem, new, old, __ATOMIC_ACQUIRE)
+
+# define atomic_compare_and_exchange_val_acq(mem, new, old)	\
+  __atomic_val_bysize (__arch_compare_and_exchange_val, int,	\
+		       mem, new, old, __ATOMIC_ACQUIRE)
+
+# define atomic_compare_and_exchange_val_rel(mem, new, old)	 \
+  __atomic_val_bysize (__arch_compare_and_exchange_val, int,    \
+                       mem, new, old, __ATOMIC_RELEASE)
+
+/* Atomic exchange (without compare).  */
+
+# define __arch_exchange_8_int(mem, newval, model)	\
+  __atomic_exchange_n (mem, newval, model)
+
+# define __arch_exchange_16_int(mem, newval, model)	\
+  __atomic_exchange_n (mem, newval, model)
+
+# define __arch_exchange_32_int(mem, newval, model)	\
+  __atomic_exchange_n (mem, newval, model)
+
+#  define __arch_exchange_64_int(mem, newval, model)	\
+  __atomic_exchange_n (mem, newval, model)
+
+# define atomic_exchange_acq(mem, value)				\
+  __atomic_val_bysize (__arch_exchange, int, mem, value, __ATOMIC_ACQUIRE)
+
+# define atomic_exchange_rel(mem, value)				\
+  __atomic_val_bysize (__arch_exchange, int, mem, value, __ATOMIC_RELEASE)
+
+/* Execute a PAUSE hint when spinning.  */
+#define atomic_spin_nop() __asm("pause")
+
+#endif /* _XR17032_BITS_ATOMIC_H */
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/bits/endianness.h glibc-workdir/sysdeps/xr17032/bits/endianness.h
--- glibc-clean/sysdeps/xr17032/bits/endianness.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/bits/endianness.h
@@ -0,0 +1,28 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_ENDIANNESS_H
+#define _BITS_ENDIANNESS_H 1
+
+#ifndef _BITS_ENDIAN_H
+# error "Never use <bits/endianness.h> directly; include <endian.h> instead."
+#endif
+
+/* XR/17032 is little-endian.  */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+#endif /* bits/endianness.h */
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/bits/fenv.h glibc-workdir/sysdeps/xr17032/bits/fenv.h
--- glibc-clean/sysdeps/xr17032/bits/fenv.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/bits/fenv.h
@@ -0,0 +1,73 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+enum
+  {
+    FE_INEXACT   =
+#define FE_INEXACT	(0x01)
+      FE_INEXACT,
+    FE_UNDERFLOW =
+#define FE_UNDERFLOW	(0x02)
+      FE_UNDERFLOW,
+    FE_OVERFLOW  =
+#define FE_OVERFLOW	(0x04)
+      FE_OVERFLOW,
+    FE_DIVBYZERO =
+#define FE_DIVBYZERO	(0x08)
+      FE_DIVBYZERO,
+    FE_INVALID   =
+#define FE_INVALID	(0x10)
+      FE_INVALID
+  };
+
+#define FE_ALL_EXCEPT \
+	(FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {
+    FE_TONEAREST  =
+#define FE_TONEAREST	(0x0)
+      FE_TONEAREST,
+    FE_TOWARDZERO =
+#define FE_TOWARDZERO	(0x1)
+      FE_TOWARDZERO,
+    FE_DOWNWARD   =
+#define FE_DOWNWARD	(0x2)
+      FE_DOWNWARD,
+    FE_UPWARD     =
+#define FE_UPWARD	(0x3)
+      FE_UPWARD
+  };
+
+
+typedef unsigned int fexcept_t;
+typedef unsigned int fenv_t;
+
+/* If the default argument is used we use this value.  */
+#define FE_DFL_ENV	((__const fenv_t *) -1)
+
+#if __GLIBC_USE (IEC_60559_BFP_EXT_C23)
+/* Type representing floating-point control modes.  */
+typedef unsigned int femode_t;
+
+/* Default floating-point control modes.  */
+# define FE_DFL_MODE	((const femode_t *) -1L)
+#endif
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/bits/link.h glibc-workdir/sysdeps/xr17032/bits/link.h
--- glibc-clean/sysdeps/xr17032/bits/link.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/bits/link.h
@@ -0,0 +1,54 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+typedef struct La_xr17032_regs
+{
+   unsigned long int lr_reg[4]; /* a0 - a3 */
+   unsigned long int lr_lr;
+   unsigned long int lr_sp;
+} La_xr17032_regs;
+
+/* Return values for calls from PLT on XR/17032.  */
+typedef struct La_xr17032_retval
+{
+   unsigned long int lrv_a0;
+   unsigned long int lrv_a1;
+   unsigned long int lrv_a2;
+   unsigned long int lrv_a3;
+} La_xr17032_retval;
+
+__BEGIN_DECLS
+
+extern ElfW(Addr) la_xr17032_gnu_pltenter (ElfW(Sym) *__sym, unsigned int __ndx,
+					   uintptr_t *__refcook,
+					   uintptr_t *__defcook,
+					   La_xr17032_regs *__regs,
+					   unsigned int *__flags,
+					   const char *__symname,
+					   long int *__framesizep);
+extern unsigned int la_xr17032_gnu_pltexit (ElfW(Sym) *__sym, unsigned int __ndx,
+					    uintptr_t *__refcook,
+					    uintptr_t *__defcook,
+					    const La_xr17032_regs *__inregs,
+					    La_xr17032_retval *__outregs,
+					    const char *__symname);
+
+__END_DECLS
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/bits/setjmp.h glibc-workdir/sysdeps/xr17032/bits/setjmp.h
--- glibc-clean/sysdeps/xr17032/bits/setjmp.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/bits/setjmp.h
@@ -0,0 +1,31 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _XR17032_BITS_SETJMP_H
+#define _XR17032_BITS_SETJMP_H
+
+typedef struct __jmp_buf_internal_tag
+  {
+    /* Program counter.  */
+    long int __pc;
+    /* Callee-saved registers.  */
+    long int __regs[18];
+    /* Stack pointer.  */
+    long int __sp;
+  } __jmp_buf[1];
+
+#endif /* _XR17032_BITS_SETJMP_H */
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/bits/wordsize.h glibc-workdir/sysdeps/xr17032/bits/wordsize.h
--- glibc-clean/sysdeps/xr17032/bits/wordsize.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/bits/wordsize.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __WORDSIZE			32
+#define __WORDSIZE_TIME64_COMPAT32	1
+#define __WORDSIZE32_SIZE_ULONG		0
+#define __WORDSIZE32_PTRDIFF_LONG	0
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/bsd-_setjmp.c glibc-workdir/sysdeps/xr17032/bsd-_setjmp.c
--- glibc-clean/sysdeps/xr17032/bsd-_setjmp.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/bsd-_setjmp.c
@@ -0,0 +1 @@
+/* _setjmp is implemented in setjmp.S */
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/bsd-setjmp.c glibc-workdir/sysdeps/xr17032/bsd-setjmp.c
--- glibc-clean/sysdeps/xr17032/bsd-setjmp.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/bsd-setjmp.c
@@ -0,0 +1 @@
+/* setjmp is implemented in setjmp.S */
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/dl-link.sym glibc-workdir/sysdeps/xr17032/dl-link.sym
--- glibc-clean/sysdeps/xr17032/dl-link.sym	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/dl-link.sym
@@ -0,0 +1,12 @@
+#include <stddef.h>
+#include <sysdep.h>
+#include <link.h>
+
+DL_SIZEOF_RG            sizeof(struct La_xr17032_regs)
+DL_SIZEOF_RV            sizeof(struct La_xr17032_retval)
+
+DL_OFFSET_RG_A0         offsetof(struct La_xr17032_regs, lr_reg)
+DL_OFFSET_RG_LR         offsetof(struct La_xr17032_regs, lr_lr)
+DL_OFFSET_RG_SP         offsetof(struct La_xr17032_regs, lr_sp)
+
+DL_OFFSET_RV_A0         offsetof(struct La_xr17032_retval, lrv_a0)
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/dl-machine.h glibc-workdir/sysdeps/xr17032/dl-machine.h
--- glibc-clean/sysdeps/xr17032/dl-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/dl-machine.h
@@ -0,0 +1,342 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef dl_machine_h
+#define dl_machine_h
+
+#define ELF_MACHINE_NAME "XR/17032"
+
+#include <entry.h>
+#include <elf/elf.h>
+#include <sys/asm.h>
+#include <dl-tls.h>
+#include <dl-irel.h>
+#include <dl-static-tls.h>
+#include <dl-machine-rel.h>
+
+#ifndef _RTLD_PROLOGUE
+# define _RTLD_PROLOGUE(entry)						\
+	".globl\t" __STRING (entry) "\n\t"				\
+	".type\t" __STRING (entry) ", @function\n"			\
+	__STRING (entry) ":\n\t"
+#endif
+
+#ifndef _RTLD_EPILOGUE
+# define _RTLD_EPILOGUE(entry)						\
+	".size\t" __STRING (entry) ", . - " __STRING (entry) "\n\t"
+#endif
+
+#define ELF_MACHINE_JMP_SLOT R_XR17032_JUMP_SLOT
+
+#define elf_machine_type_class(type)				\
+  ((ELF_RTYPE_CLASS_PLT * ((type) == ELF_MACHINE_JMP_SLOT	\
+     || (type) == R_XR17032_TLS_DTPREL				\
+     || (type) == R_XR17032_TLS_DTPMOD				\
+     || (type) == R_XR17032_TLS_TPREL))				\
+   | (ELF_RTYPE_CLASS_COPY * ((type) == R_XR17032_COPY)))
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute_used__
+elf_machine_matches_host (const ElfW(Ehdr) *ehdr)
+{
+  /* We can only run XR/17032 binaries.  */
+  if (ehdr->e_machine != EM_XR17032)
+    return 0;
+
+  return 1;
+}
+
+/* Return the run-time load address of the shared object.  */
+static inline ElfW(Addr)
+elf_machine_load_address (void)
+{
+  extern const ElfW(Ehdr) __ehdr_start attribute_hidden;
+  return (ElfW(Addr)) &__ehdr_start;
+}
+
+/* Return the link-time address of _DYNAMIC.  */
+static inline ElfW(Addr)
+elf_machine_dynamic (void)
+{
+  extern ElfW(Dyn) _DYNAMIC[] attribute_hidden;
+  return (ElfW(Addr)) _DYNAMIC - elf_machine_load_address ();
+}
+
+#define STRINGXP(X) __STRING (X)
+#define STRINGXV(X) STRINGV_ (X)
+#define STRINGV_(...) # __VA_ARGS__
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+
+#define RTLD_START asm (\
+	".text\n\
+	" _RTLD_PROLOGUE (ENTRY_POINT) "\
+	add a0, sp, zero\n\
+1:	adr lr, %pcrel_hi(_dl_start)\n\
+	jalr lr, lr, %pcrel_lo(1b)\n\
+	add a0, a3, zero\n\
+	" _RTLD_PROLOGUE (_dl_start_user) "\
+	# Stash user entry point in s0.\n\
+	add s0, a0, zero\n\
+	# Load the adjusted argument count.\n\
+	mov a1, long [sp]\n\
+	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env) \n\
+1:	adr a0, %pcrel_hi(_rtld_local)\n\
+	mov a0, long [a0 + %pcrel_lo(1b)]\n\
+	addi a2, sp, 4\n\
+	add a3, a2, a1 LSH 2\n\
+	addi a3, a3, 4\n\
+	# Stash the stack pointer in s1.\n\
+	add s1, sp, zero\n\
+	# Call the function to run the initializers.\n\
+1:	adr lr, %pcrel_hi(_dl_init)\n\
+	jalr lr, lr, %pcrel_lo(1b)\n\
+	# Restore the stack pointer for _start.\n\
+	add sp, s1, zero\n\
+	# Pass our finalizer function to _start.\n\
+1:	adr a0, %pcrel_hi(_dl_fini)\n\
+	addi a0, a0, %pcrel_lo(1b)\n\
+	# Jump to the user entry point.\n\
+	jalr zero, s0, 0\n\
+	" _RTLD_EPILOGUE (ENTRY_POINT) \
+	  _RTLD_EPILOGUE (_dl_start_user) "\
+	.previous" \
+);
+
+/* Names of the architecture-specific auditing callback functions.  */
+#define ARCH_LA_PLTENTER xr17032_gnu_pltenter
+#define ARCH_LA_PLTEXIT xr17032_gnu_pltexit
+
+/* Bias .got.plt entry by the offset requested by the PLT header.  */
+#define elf_machine_plt_value(map, reloc, value) (value)
+
+static inline ElfW(Addr)
+elf_machine_fixup_plt (struct link_map *map, lookup_t t,
+		       const ElfW(Sym) *refsym, const ElfW(Sym) *sym,
+		       const ElfW(Rela) *reloc,
+		       ElfW(Addr) *reloc_addr, ElfW(Addr) value)
+{
+  return *reloc_addr = value;
+}
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE_MAP
+
+static inline void
+__attribute__ ((always_inline))
+elf_machine_rela_relative (ElfW(Addr) l_addr, const ElfW(Rela) *reloc,
+			  void *const reloc_addr)
+{
+  /* R_XR17032_RELATIVE might located in debug info section which might not
+     aligned to XLEN bytes.  Also support relocations on unaligned offsets.  */
+  ElfW(Addr) value = l_addr + reloc->r_addend;
+  memcpy (reloc_addr, &value, sizeof value);
+}
+
+/* Perform a relocation described by R_INFO at the location pointed to
+   by RELOC_ADDR.  SYM is the relocation symbol specified by R_INFO and
+   MAP is the object containing the reloc.  */
+
+static inline void
+__attribute__ ((always_inline))
+elf_machine_rela (struct link_map *map, struct r_scope_elem *scope[],
+		  const ElfW(Rela) *reloc, const ElfW(Sym) *sym,
+		  const struct r_found_version *version,
+		  void *const reloc_addr, int skip_ifunc)
+{
+  ElfW(Addr) r_info = reloc->r_info;
+  const unsigned long int r_type = ELFW (R_TYPE) (r_info);
+  ElfW(Addr) *addr_field = (ElfW(Addr) *) reloc_addr;
+  const ElfW(Sym) *const __attribute__ ((unused)) refsym = sym;
+  struct link_map *sym_map = RESOLVE_MAP (map, scope, &sym, version, r_type);
+  ElfW(Addr) value = 0;
+  if (sym_map != NULL)
+    value = SYMBOL_ADDRESS (sym_map, sym, true) + reloc->r_addend;
+
+  if (sym != NULL
+      && __glibc_unlikely (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC)
+      && __glibc_likely (sym->st_shndx != SHN_UNDEF)
+      && __glibc_likely (!skip_ifunc))
+    value = elf_ifunc_invoke (value);
+
+
+  switch (r_type)
+    {
+    case R_XR17032_RELATIVE:
+      elf_machine_rela_relative (map->l_addr, reloc, addr_field);
+      break;
+    case R_XR17032_JUMP_SLOT:
+    case R_XR17032_32:
+      *addr_field = value;
+      break;
+
+# ifndef RTLD_BOOTSTRAP
+    case R_XR17032_TLS_DTPMOD:
+      if (sym_map)
+	*addr_field = sym_map->l_tls_modid;
+      break;
+
+    case R_XR17032_TLS_DTPREL:
+      if (sym != NULL)
+	*addr_field = TLS_DTPREL_VALUE (sym) + reloc->r_addend;
+      break;
+
+    case R_XR17032_TLS_TPREL:
+      if (sym != NULL)
+	{
+	  CHECK_STATIC_TLS (map, sym_map);
+	  *addr_field = TLS_TPREL_VALUE (sym_map, sym) + reloc->r_addend;
+	}
+      break;
+
+    case R_XR17032_COPY:
+      {
+	if (__glibc_unlikely (sym == NULL))
+	  /* This can happen in trace mode if an object could not be
+	     found.  */
+	  break;
+
+	/* Handle TLS copy relocations.  */
+	if (__glibc_unlikely (ELFW (ST_TYPE) (sym->st_info) == STT_TLS))
+	  {
+	    /* There's nothing to do if the symbol is in .tbss.  */
+	    if (__glibc_likely (sym->st_value >= sym_map->l_tls_initimage_size))
+	      break;
+	    value += (ElfW(Addr)) sym_map->l_tls_initimage - sym_map->l_addr;
+	  }
+
+	size_t size = sym->st_size;
+	if (__glibc_unlikely (sym->st_size != refsym->st_size))
+	  {
+	    const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+	    if (sym->st_size > refsym->st_size)
+	      size = refsym->st_size;
+	    if (sym->st_size > refsym->st_size || GLRO(dl_verbose))
+	      _dl_error_printf ("\
+  %s: Symbol `%s' has different size in shared object, consider re-linking\n",
+				rtld_progname ?: "<program name unknown>",
+				strtab + refsym->st_name);
+	  }
+
+	memcpy (reloc_addr, (void *)value, size);
+	break;
+      }
+
+    case R_XR17032_IRELATIVE:
+      value = map->l_addr + reloc->r_addend;
+      if (__glibc_likely (!skip_ifunc))
+        value = elf_ifunc_invoke (value);
+      *addr_field = value;
+      break;
+
+    case R_XR17032_NONE:
+      break;
+# endif /* !RTLD_BOOTSTRAP */
+
+    default:
+      _dl_reloc_bad_type (map, r_type, 0);
+      break;
+    }
+}
+
+static inline void
+__attribute__ ((always_inline))
+elf_machine_lazy_rel (struct link_map *map, struct r_scope_elem *scope[],
+		      ElfW(Addr) l_addr, const ElfW(Rela) *reloc,
+		      int skip_ifunc)
+{
+  ElfW(Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned int r_type = ELFW (R_TYPE) (reloc->r_info);
+
+  /* Check for unexpected PLT reloc type.  */
+  if (__glibc_likely (r_type == R_XR17032_JUMP_SLOT))
+    {
+      if (__glibc_unlikely (map->l_mach.plt == 0))
+	{
+	  if (l_addr)
+	    *reloc_addr += l_addr;
+	}
+      else
+	*reloc_addr = map->l_mach.plt;
+    }
+  else if (__glibc_unlikely (r_type == R_XR17032_IRELATIVE))
+    {
+      ElfW(Addr) value = map->l_addr + reloc->r_addend;
+      if (__glibc_likely (!skip_ifunc))
+        value = elf_ifunc_invoke (value);
+      *reloc_addr = value;
+    }
+  else
+    _dl_reloc_bad_type (map, r_type, 1);
+}
+
+/* Set up the loaded object described by L so its stub function
+   will jump to the on-demand fixup code __dl_runtime_resolve.  */
+
+static inline int
+__attribute__ ((always_inline))
+elf_machine_runtime_setup (struct link_map *l, struct r_scope_elem *scope[],
+			   int lazy, int profile)
+{
+#ifndef RTLD_BOOTSTRAP
+  /* If using PLTs, fill in the first two entries of .got.plt.  */
+  if (l->l_info[DT_JMPREL])
+    {
+      extern void _dl_runtime_resolve (void) __attribute__ ((visibility ("hidden")));
+      extern void _dl_runtime_profile (void) __attribute__ ((visibility ("hidden")));
+      ElfW(Addr) *gotplt = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);
+      /* If a library is prelinked but we have to relocate anyway,
+	 we have to be able to undo the prelinking of .got.plt.
+	 The prelinker saved the address of .plt for us here.  */
+      if (gotplt[1])
+	l->l_mach.plt = gotplt[1] + l->l_addr;
+      /* The gotplt[0] entry contains the address of a function which gets
+	 called to get the address of a so far unresolved function and
+	 jump to it.  The profiling extension of the dynamic linker allows
+	 to intercept the calls to collect information.  In this case we
+	 don't store the address in the GOT so that all future calls also
+	 end in this function.  */
+#ifdef SHARED
+      if (profile != 0)
+	{
+	  gotplt[0] = (ElfW(Addr)) &_dl_runtime_profile;
+
+	  if (GLRO(dl_profile) != NULL
+	      && _dl_name_match_p (GLRO(dl_profile), l))
+	    /* Say that we really want profiling and the timers are
+	       started.  */
+	    GL(dl_profile_map) = l;
+	}
+      else
+#endif
+	{
+	  /* This function will get called to fix up the GOT entry
+	     indicated by the offset on the stack, and then jump to
+	     the resolved address.  */
+	  gotplt[0] = (ElfW(Addr)) &_dl_runtime_resolve;
+	}
+      gotplt[1] = (ElfW(Addr)) l;
+    }
+
+#endif
+  return lazy;
+}
+
+#endif /* RESOLVE_MAP */
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/dl-tls.h glibc-workdir/sysdeps/xr17032/dl-tls.h
--- glibc-clean/sysdeps/xr17032/dl-tls.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/dl-tls.h
@@ -0,0 +1,50 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _DL_TLS_H
+#define _DL_TLS_H
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+/* The thread pointer points to the first static TLS block.  */
+#define TLS_TP_OFFSET		0
+
+/* Dynamic thread vector pointers point 0x800 past the start of each
+   TLS block.  */
+#define TLS_DTV_OFFSET		0x800
+
+/* Compute the value for a GOTTPREL reloc.  */
+#define TLS_TPREL_VALUE(sym_map, sym) \
+  ((sym_map)->l_tls_offset + (sym)->st_value - TLS_TP_OFFSET)
+
+/* Compute the value for a DTPREL reloc.  */
+#define TLS_DTPREL_VALUE(sym) \
+  ((sym)->st_value - TLS_DTV_OFFSET)
+
+extern void *__tls_get_addr (tls_index *ti);
+
+#define __TLS_GET_ADDR(__ti)	(__tls_get_addr (__ti) - TLS_DTV_OFFSET)
+
+/* Value used for dtv entries for which the allocation is delayed.  */
+#define TLS_DTV_UNALLOCATED	((void *) -1l)
+
+#endif /* _DL_TLS_H */
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/dl-trampoline.S glibc-workdir/sysdeps/xr17032/dl-trampoline.S
--- glibc-clean/sysdeps/xr17032/dl-trampoline.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/dl-trampoline.S
@@ -0,0 +1,176 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "dl-link.h"
+
+/* Assembler veneer called from the PLT header code for lazy loading.
+   The PLT header passes its own args in t0-t2.  */
+
+#define FRAME_SIZE (5 * 4)
+
+ENTRY (_dl_runtime_resolve)
+  # Save arguments to stack.
+  subi sp, sp, FRAME_SIZE
+  mov long [sp + 0x00], lr
+  mov long [sp + 0x04], a0
+  mov long [sp + 0x08], a1
+  mov long [sp + 0x0c], a2
+  mov long [sp + 0x10], a3
+
+  # Update .got.plt and obtain runtime address of callee.
+  add a0, t0, zero     # link map
+  add a1, t1, t1 LSH 1 # reloc offset (== thrice the .got.plt offset)
+1:adr a2, %pcrel_hi(_dl_fixup)
+  jalr lr, a2, %pcrel_lo(1b)
+  add t1, a3, zero
+
+  # Restore arguments from stack.
+  mov lr, long [sp + 0x00]
+  mov a0, long [sp + 0x04]
+  mov a1, long [sp + 0x08]
+  mov a2, long [sp + 0x0c]
+  mov a3, long [sp + 0x10]
+  addi sp, sp, FRAME_SIZE
+
+  # Invoke the callee.
+  jalr zero, t1, 0
+END (_dl_runtime_resolve)
+
+#if !defined PROF && defined SHARED
+ENTRY (_dl_runtime_profile)
+  /* XR/17032 we get called with:
+  t0          linkr_map pointer
+  t1          the scaled offset stored in t0, which can be used
+              to calculate the offset of the current symbol in .rela.plt
+  t2          %hi(%pcrel(.got.plt)) stored in t2, no use in this function
+  t3          dl resolver entry point, no use in this function
+
+  Stack frame layout:
+  [sp, #44]  La_xr17032_regs
+  [sp, #28]  La_xr17032_retval
+  [sp, #24]  frame size return from pltenter
+  [sp, #20]  dl_profile_call saved a1
+  [sp, #16]  dl_profile_call saved a0
+  [sp, #12]  T1
+  [sp,  #4]  lr, s0   <- s0
+  [sp,  #0]  argument area
+   */
+
+# define OFFSET_T1              8
+# define OFFSET_SAVED_CALL_A0   OFFSET_T1 + 4
+# define OFFSET_SAVED_CALL_A1   OFFSET_SAVED_CALL_A0 + 4
+# define OFFSET_FS              OFFSET_SAVED_CALL_A1 + 4
+# define OFFSET_RV              OFFSET_FS + 4
+# define OFFSET_RG              OFFSET_RV + DL_SIZEOF_RV
+
+# define SF_SIZE                (OFFSET_RG + DL_SIZEOF_RG)
+
+  # Save arguments to stack.
+  subi sp, sp, SF_SIZE
+  mov long [sp + 4], lr
+  mov long [sp + 8], s0
+
+  addi s0, sp, 4
+
+  mov long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 0], a0
+  mov long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 4], a1
+  mov long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 8], a2
+  mov long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 12], a3
+
+  # Update .got.plt and obtain runtime address of callee.
+  add a0, t0, zero
+  add a1, t1, t1 LSH 1    # link map
+  add a2, lr, zero        # return addr
+  addi a3, s0, OFFSET_RG  # La_riscv_regs pointer
+  addi t0, s0, OFFSET_FS  # frame size return from pltenter
+  mov long [sp], t0
+
+  mov long [s0 + OFFSET_SAVED_CALL_A0], a0
+  mov long [s0 + OFFSET_SAVED_CALL_A1], a1
+
+1:adr t2, %pcrel_hi(_dl_profile_fixup)
+  jalr lr, t2, %pcrel_lo(1b)
+
+  mov t3, long [s0 + OFFSET_FS]
+  bge t3, 1f
+
+  # Save the return.
+  add t4, a3, zero
+
+  # Restore arguments from stack.
+  mov a0, long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 0]
+  mov a1, long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 4]
+  mov a2, long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 8]
+  mov a3, long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 12]
+
+  mov lr, long [s0]
+  mov s0, long [s0 + 4]
+
+  addi sp, s0, SF_SIZE
+  jalr zero, t4, 0
+
+1:
+  # The new frame size is in t3.
+  sub sp, s0, t3
+
+  mov long [s0 + OFFSET_T1], a3
+
+  add a0, sp, zero
+  addi a1, s0, SF_SIZE
+  add a2, t3, zero
+1:adr t4, %pcrel_hi(memcpy)
+  jalr lr, t4, %pcrel_lo(1b)
+
+  mov t4, long [s0 + OFFSET_T1]
+
+  # Call the function.
+  mov a0, long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 0]
+  mov a1, long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 4]
+  mov a2, long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 8]
+  mov a3, long [s0 + OFFSET_RG + DL_OFFSET_RG_A0 + 12]
+  jalr lr, t4, 0
+
+  mov long [s0 + OFFSET_SAVED_CALL_A0 + DL_OFFSET_RV_A0], a0
+  mov long [s0 + OFFSET_SAVED_CALL_A0 + DL_OFFSET_RV_A0 + 4], a1
+  mov long [s0 + OFFSET_SAVED_CALL_A0 + DL_OFFSET_RV_A0 + 8], a2
+  mov long [s0 + OFFSET_SAVED_CALL_A0 + DL_OFFSET_RV_A0 + 12], a3
+
+  # Setup call to pltexit.
+  mov a0, long [s0 + OFFSET_SAVED_CALL_A0]
+  mov a1, long [s0 + OFFSET_SAVED_CALL_A0 + 4]
+  addi a2, s0, OFFSET_RG
+  addi a3, s0, OFFSET_RV
+1:adr t4, %pcrel_hi(_dl_audit_pltexit)
+  jalr lr, t4, %pcrel_lo(1b)
+
+  mov a0, long [s0 + OFFSET_RV + DL_OFFSET_RV_A0]
+  mov a1, long [s0 + OFFSET_RV + DL_OFFSET_RV_A0 + 4]
+  mov a2, long [s0 + OFFSET_RV + DL_OFFSET_RV_A0 + 8]
+  mov a3, long [s0 + OFFSET_RV + DL_OFFSET_RV_A0 + 12]
+
+  # LR from within La_xr17032_reg.
+  mov lr, long [s0 + OFFSET_RG + DL_OFFSET_RG_LR]
+  addi sp, s0, SF_SIZE
+  mov s0, long [s0 + 4]
+
+  jalr zero, lr, 0
+
+END (_dl_runtime_profile)
+#endif /* SHARED */
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/jmpbuf-offsets.h glibc-workdir/sysdeps/xr17032/jmpbuf-offsets.h
--- glibc-clean/sysdeps/xr17032/jmpbuf-offsets.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/jmpbuf-offsets.h
@@ -0,0 +1,22 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <jmpbuf-unwind.h>
+
+/* Helper for generic ____longjmp_chk().  */
+#define JB_FRAME_ADDRESS(buf) \
+  ((void *) _jmpbuf_sp (buf))
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/jmpbuf-unwind.h glibc-workdir/sysdeps/xr17032/jmpbuf-unwind.h
--- glibc-clean/sysdeps/xr17032/jmpbuf-unwind.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/jmpbuf-unwind.h
@@ -0,0 +1,44 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <setjmp.h>
+#include <stdint.h>
+#include <unwind.h>
+#include <sysdep.h>
+#include <pointer_guard.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle)		\
+  ((void *) (address) < (void *) demangle ((jmpbuf)[0].__sp))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+static inline uintptr_t __attribute__ ((unused))
+_jmpbuf_sp (__jmp_buf regs)
+{
+  uintptr_t sp = regs[0].__sp;
+  PTR_DEMANGLE (sp);
+  return sp;
+}
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < _jmpbuf_sp (_jmpbuf) - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/ldsodefs.h glibc-workdir/sysdeps/xr17032/ldsodefs.h
--- glibc-clean/sysdeps/xr17032/ldsodefs.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/ldsodefs.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _XR17032_LDSODEFS_H
+#define _XR17032_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_xr17032_regs;
+struct La_xr17032_retval;
+
+#define ARCH_PLTENTER_MEMBERS							\
+    ElfW(Addr) (*xr17032_gnu_pltenter) (ElfW(Sym) *, unsigned int,		\
+					uintptr_t *, uintptr_t *,		\
+					const struct La_xr17032_regs *,		\
+					unsigned int *, const char *name,	\
+					long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS							\
+    unsigned int (*xr17032_gnu_pltexit) (ElfW(Sym) *, unsigned int,		\
+					 uintptr_t *, uintptr_t *,		\
+					 const struct La_xr17032_regs *,	\
+					 struct La_xr17032_retval *,		\
+					 const char *);
+
+#include_next <ldsodefs.h>
+
+#endif
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/linkmap.h glibc-workdir/sysdeps/xr17032/linkmap.h
--- glibc-clean/sysdeps/xr17032/linkmap.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/linkmap.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+struct link_map_machine
+  {
+    ElfW(Addr) plt; /* Address of .plt.  */
+  };
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/machine-gmon.h glibc-workdir/sysdeps/xr17032/machine-gmon.h
--- glibc-clean/sysdeps/xr17032/machine-gmon.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/machine-gmon.h
@@ -0,0 +1,36 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Accept 'frompc' address as argument from the function that calls
+   _mcount for profiling.  Use  __builtin_return_address (0)
+   for the 'selfpc' address.  */
+
+#include <sysdep.h>
+
+static void mcount_internal (unsigned long int frompc,
+			     unsigned long int selfpc);
+
+#define _MCOUNT_DECL(frompc, selfpc) \
+static inline void mcount_internal (unsigned long int frompc, \
+unsigned long int selfpc)
+
+#define MCOUNT								\
+void _mcount (void *frompc)						\
+{									\
+  mcount_internal ((unsigned long int) frompc,				\
+		   (unsigned long int) RETURN_ADDRESS (0));		\
+}
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/nptl/pthreaddef.h glibc-workdir/sysdeps/xr17032/nptl/pthreaddef.h
--- glibc-clean/sysdeps/xr17032/nptl/pthreaddef.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/nptl/pthreaddef.h
@@ -0,0 +1,31 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(2 * 1024 * 1024)
+
+/* Minimum guard size.  */
+#define ARCH_MIN_GUARD_SIZE 0
+
+/* Required stack pointer alignment at beginning.  */
+#define STACK_ALIGN		4
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	2048
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/nptl/tls.h glibc-workdir/sysdeps/xr17032/nptl/tls.h
--- glibc-clean/sysdeps/xr17032/nptl/tls.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/nptl/tls.h
@@ -0,0 +1,131 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _XR17032_TLS_H
+#define _XR17032_TLS_H	1
+
+#include <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+# include <dl-dtv.h>
+
+register void *__thread_self asm ("tp");
+# define READ_THREAD_POINTER() ({ __thread_self; })
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+# define TLS_TCB_AT_TP	0
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_INIT_TCB_SIZE	0
+
+/* This is the size of the TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_TCB_SIZE		0
+
+/* This is the size we need before TCB - actually, it includes the TCB.  */
+# define TLS_PRE_TCB_SIZE \
+  (sizeof (struct pthread)						      \
+   + ((sizeof (tcbhead_t) + __alignof (struct pthread) - 1)		      \
+      & ~(__alignof (struct pthread) - 1)))
+
+/* The thread pointer tp points to the end of the TCB.
+   The pthread_descr structure is immediately in front of the TCB.  */
+# define TLS_TCB_OFFSET	0
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv)
+
+/* Code to initially initialize the thread pointer.  */
+# define TLS_INIT_TP(tcbp) \
+  ({ __thread_self = (char*)tcbp + TLS_TCB_OFFSET; true; })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) (READ_THREAD_POINTER () - TLS_TCB_OFFSET))[-1].dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+ ((struct pthread *) (READ_THREAD_POINTER ()			     \
+		      - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE))
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+# define TLS_DEFINE_INIT_TP(tp, pd) \
+  void *tp = (void *) (pd) + TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE
+
+/* Informs libthread_db that the thread pointer is register 29, which is used
+ * to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  REGISTER (32, 32, 29 * 4, - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE)
+
+/* Access to data in the thread descriptor is easy.  */
+# include <tcb-access.h>
+
+/* l_tls_offset == 0 is perfectly valid, so we have to use some different
+   value to mean unset l_tls_offset.  */
+# define NO_TLS_OFFSET		-1
+
+/* Get and set the global scope generation counter in struct pthread.  */
+# define THREAD_GSCOPE_FLAG_UNUSED 0
+# define THREAD_GSCOPE_FLAG_USED   1
+# define THREAD_GSCOPE_FLAG_WAIT   2
+# define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_release (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+# define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* _XR17032_TLS_H */
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/setjmp.S glibc-workdir/sysdeps/xr17032/setjmp.S
--- glibc-clean/sysdeps/xr17032/setjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/setjmp.S
@@ -0,0 +1,66 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (_setjmp)
+	addi	a1, zero, 0
+1:	adr	t1, %pcrel_hi(HIDDEN_JUMPTARGET(__sigsetjmp))
+	jalr	zero, t1, %pcrel_lo(1b)
+END (_setjmp)
+ENTRY (setjmp)
+	addi	a1, zero, 1
+	/* Fallthrough */
+END (setjmp)
+ENTRY (__sigsetjmp)
+	mov long [a0 + 0x00], lr
+	mov long [a0 + 0x04], s0
+	mov long [a0 + 0x08], s1
+	mov long [a0 + 0x0c], s2
+	mov long [a0 + 0x10], s3
+	mov long [a0 + 0x14], s4
+	mov long [a0 + 0x18], s5
+	mov long [a0 + 0x1c], s6
+	mov long [a0 + 0x20], s7
+	mov long [a0 + 0x24], s8
+	mov long [a0 + 0x28], s9
+	mov long [a0 + 0x2c], s10
+	mov long [a0 + 0x30], s11
+	mov long [a0 + 0x34], s12
+	mov long [a0 + 0x38], s13
+	mov long [a0 + 0x3c], s14
+	mov long [a0 + 0x40], s15
+	mov long [a0 + 0x44], s16
+	mov long [a0 + 0x48], s17
+	mov long [a0 + 0x4c], sp
+
+#if !IS_IN (libc) && IS_IN (rtld)
+	/* In ld.so we never save the signal mask.  */
+	addi a3, zero, 0
+	jalr zero, lr, 0
+#else
+	/* Make a tail call to __sigjmp_save; it takes the same args.  */
+1:	adr t1, %pcrel_hi(__sigjmp_save)
+	jalr zero, t1, %pcrel_lo(1b)
+#endif
+
+
+END (__sigsetjmp)
+
+hidden_def (__sigsetjmp)
+weak_alias (_setjmp, __GI__setjmp)
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/sotruss-lib.c glibc-workdir/sysdeps/xr17032/sotruss-lib.c
--- glibc-clean/sysdeps/xr17032/sotruss-lib.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/sotruss-lib.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define HAVE_ARCH_PLTENTER
+#define HAVE_ARCH_PLTEXIT
+
+#include <elf/sotruss-lib.c>
+
+ElfW(Addr)
+la_xr17032_gnu_pltenter (ElfW(Sym) *sym __attribute__ ((unused)),
+			 unsigned int ndx __attribute__ ((unused)),
+			 uintptr_t *refcook, uintptr_t *defcook,
+			 La_xr17032_regs *regs, unsigned int *flags,
+			 const char *symname, long int *framesizep)
+{
+  print_enter (refcook, defcook, symname,
+	       regs->lr_reg[0], regs->lr_reg[1], regs->lr_reg[2],
+	       *flags);
+
+  /* No need to copy anything, we will not need the parameters in any case.  */
+  *framesizep = 0;
+
+  return sym->st_value;
+}
+
+unsigned int
+la_xr17032_gnu_pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
+			uintptr_t *defcook,
+			const struct La_xr17032_regs *inregs,
+			struct La_xr17032_retval *outregs,
+			const char *symname)
+{
+  print_exit (refcook, defcook, symname, outregs->lrv_a0);
+
+  return 0;
+}
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/start.S glibc-workdir/sysdeps/xr17032/start.S
--- glibc-clean/sysdeps/xr17032/start.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/start.S
@@ -0,0 +1,87 @@
+/* Startup code compliant to the ELF XR/17032 ABI.
+   Copyright (C) 1995-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __ASSEMBLY__ 1
+#include <entry.h>
+#include <sysdep.h>
+#include <sys/asm.h>
+
+/* The entry point's job is to call __libc_start_main.  Per the ABI,
+   a0 contains the address of a function to be passed to atexit.
+   __libc_start_main wants this in a5.  */
+
+ENTRY (ENTRY_POINT)
+	/* Terminate call stack by noting lr is undefined.  Use a dummy
+	   .cfi_label to force starting the FDE.  */
+	.cfi_label .Ldummy
+	cfi_undefined (lr)
+	mov   long [sp + 4], a0 /* rtld_fini. */
+	/* main may be in a shared library.  */
+#if defined PIC && !defined SHARED
+	/* Avoid relocation in static PIE since _start is called before it
+	   is relocated.  */
+1:	adr   a0, %pcrel_hi(__wrap_main)
+	addi  a0, a0, %pcrel_lo(1b)
+#else
+1:	adr   a0, %got_pcrel_hi(main)
+	mov   a0, long [a0 + %pcrel_lo(1b)]
+#endif
+	mov   a1, long [sp]     /* argc.  */
+	addi  a2, sp, 4         /* argv.  */
+	addi  a3, zero, 0       /* Used to be init.  */
+	mov   long [sp], zero   /* Used to be fini.  */
+	mov   long [sp + 8], sp /* stack_end. */
+
+#if defined PIC && !defined SHARED
+1:	adr   t1, %pcrel_hi(__libc_start_main)
+#else
+1:	adr   t1, %plt_pcrel_hi(__libc_start_main)
+#endif
+	jalr  lr, t1, %pcrel_lo(1b)
+	brk
+END (ENTRY_POINT)
+
+#if defined PIC && !defined SHARED
+__wrap_main:
+1:	adr   t1, %plt_pcrel_hi(main)
+	jalr  zero, t1, %pcrel_lo(1b)
+#endif
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.weak data_start
+	data_start = __data_start
diff -urN --no-dereference glibc-clean/sysdeps/xr17032/sys/asm.h glibc-workdir/sysdeps/xr17032/sys/asm.h
--- glibc-clean/sysdeps/xr17032/sys/asm.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-workdir/sysdeps/xr17032/sys/asm.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_ASM_H
+#define _SYS_ASM_H
+
+/* Declare leaf routine.  */
+#define	LEAF(symbol)				\
+		.globl	symbol;			\
+		.balign	4;			\
+		.type	symbol,@function;	\
+symbol:						\
+		cfi_startproc;
+
+/* Mark end of function.  */
+#undef END
+#define END(function)				\
+		cfi_endproc;			\
+		.size	function,.-function
+
+#endif /* _SYS_ASM_H */
