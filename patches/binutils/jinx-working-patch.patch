diff -urN --no-dereference binutils-clean/bfd/Makefile.am binutils-workdir/bfd/Makefile.am
--- binutils-clean/bfd/Makefile.am
+++ binutils-workdir/bfd/Makefile.am
@@ -172,6 +172,7 @@
 	cpu-visium.lo \
 	cpu-wasm32.lo \
 	cpu-xgate.lo \
+	cpu-xr17032.lo \
 	cpu-xstormy16.lo \
 	cpu-xtensa.lo \
 	cpu-z80.lo \
@@ -255,6 +256,7 @@
 	cpu-visium.c \
 	cpu-wasm32.c \
 	cpu-xgate.c \
+	cpu-xr17032.c \
 	cpu-xstormy16.c \
 	cpu-xtensa.c \
 	cpu-z80.c \
@@ -350,6 +352,7 @@
 	elf32-visium.lo \
 	elf32-wasm32.lo \
 	elf32-xgate.lo \
+	elf32-xr17032.lo \
 	elf32-xstormy16.lo \
 	elf32-xtensa.lo \
 	elf32-z80.lo \
@@ -484,6 +487,7 @@
 	elf32-visium.c \
 	elf32-wasm32.c \
 	elf32-xgate.c \
+	elf32-xr17032.c \
 	elf32-xstormy16.c \
 	elf32-xtensa.c \
 	elf32-z80.c \
diff -urN --no-dereference binutils-clean/bfd/archures.c binutils-workdir/bfd/archures.c
--- binutils-clean/bfd/archures.c
+++ binutils-workdir/bfd/archures.c
@@ -574,6 +574,8 @@
 .#define bfd_mach_amdgcn_gfx1100 0x041
 .#define bfd_mach_amdgcn_gfx1101 0x046
 .#define bfd_mach_amdgcn_gfx1102 0x047
+.  bfd_arch_xr17032,   {* XR/17032 *}
+.#define bfd_mach_xr17032       1
 .  bfd_arch_last
 .  };
 */
@@ -704,6 +706,7 @@
 extern const bfd_arch_info_type bfd_vax_arch;
 extern const bfd_arch_info_type bfd_visium_arch;
 extern const bfd_arch_info_type bfd_wasm32_arch;
+extern const bfd_arch_info_type bfd_xr17032_arch;
 extern const bfd_arch_info_type bfd_xstormy16_arch;
 extern const bfd_arch_info_type bfd_xtensa_arch;
 extern const bfd_arch_info_type bfd_xgate_arch;
@@ -790,6 +793,7 @@
     &bfd_vax_arch,
     &bfd_visium_arch,
     &bfd_wasm32_arch,
+    &bfd_xr17032_arch,
     &bfd_xstormy16_arch,
     &bfd_xtensa_arch,
     &bfd_xgate_arch,
diff -urN --no-dereference binutils-clean/bfd/bfd-in2.h binutils-workdir/bfd/bfd-in2.h
--- binutils-clean/bfd/bfd-in2.h
+++ binutils-workdir/bfd/bfd-in2.h
@@ -1842,6 +1842,8 @@
 #define bfd_mach_amdgcn_gfx1100 0x041
 #define bfd_mach_amdgcn_gfx1101 0x046
 #define bfd_mach_amdgcn_gfx1102 0x047
+  bfd_arch_xr17032,   /* XR/17032 */
+#define bfd_mach_xr17032       1
   bfd_arch_last
   };
 
@@ -6208,6 +6210,18 @@
   BFD_RELOC_IQ2000_OFFSET_21,
   BFD_RELOC_IQ2000_UHI16,
 
+  /* XR/17032 Relocations.  */
+  BFD_RELOC_XR17032_IMM29,
+  BFD_RELOC_XR17032_IMM16,
+  BFD_RELOC_XR17032_IMM16_1,
+  BFD_RELOC_XR17032_IMM16_2,
+  BFD_RELOC_XR17032_IMM16_16,
+  BFD_RELOC_XR17032_SIMM16,
+  BFD_RELOC_XR17032_DISP16_16,
+  BFD_RELOC_XR17032_SIMM5,
+  BFD_RELOC_XR17032_DISP21,
+  BFD_RELOC_XR17032_SHAMT,
+
   /* Special Xtensa relocation used only by PLT entries in ELF shared
      objects to indicate that the runtime linker should set the value
      to one of its own internal functions or data structures.  */
diff -urN --no-dereference binutils-clean/bfd/config.bfd binutils-workdir/bfd/config.bfd
--- binutils-clean/bfd/config.bfd
+++ binutils-workdir/bfd/config.bfd
@@ -222,6 +222,7 @@
 v850*)		 targ_archs="bfd_v850_arch bfd_v850_rh850_arch" ;;
 visium*)	 targ_archs=bfd_visium_arch ;;
 x86_64*)	 targ_archs=bfd_i386_arch ;;
+xr17032*)	 targ_archs=bfd_xr17032_arch ;;
 xtensa*)	 targ_archs=bfd_xtensa_arch ;;
 z80*|r800|z180|gbz80|ez80*)	 targ_archs=bfd_z80_arch ;;
 z8k*)		 targ_archs=bfd_z8k_arch ;;
@@ -1449,6 +1450,10 @@
     targ_selvecs="xgate_elf32_vec"
     ;;
 
+  xr17032-*-linux-*)
+    targ_defvec=xr17032_elf32_vec
+    ;;
+
   xstormy16-*-elf)
     targ_defvec=xstormy16_elf32_vec
     ;;
diff -urN --no-dereference binutils-clean/bfd/configure.ac binutils-workdir/bfd/configure.ac
--- binutils-clean/bfd/configure.ac
+++ binutils-workdir/bfd/configure.ac
@@ -668,6 +668,7 @@
     x86_64_pe_big_vec)		 tb="$tb pe-x86_64.lo pex64igen.lo $coff"; target_size=64 ;;
     x86_64_pei_vec)		 tb="$tb pei-x86_64.lo pex64igen.lo $coff"; target_size=64 ;;
     xgate_elf32_vec)		 tb="$tb elf32-xgate.lo elf32.lo $elf" ;;
+    xr17032_elf32_vec)		 tb="$tb elf32-xr17032.lo elf32.lo $elf" ;;
     xstormy16_elf32_vec)	 tb="$tb elf32-xstormy16.lo elf32.lo $elf" ;;
     xtensa_elf32_be_vec)	 tb="$tb xtensa-dynconfig.lo xtensa-isa.lo xtensa-modules.lo elf32-xtensa.lo elf32.lo $elf" ;;
     xtensa_elf32_le_vec)	 tb="$tb xtensa-dynconfig.lo xtensa-isa.lo xtensa-modules.lo elf32-xtensa.lo elf32.lo $elf" ;;
diff -urN --no-dereference binutils-clean/bfd/cpu-xr17032.c binutils-workdir/bfd/cpu-xr17032.c
--- binutils-clean/bfd/cpu-xr17032.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/bfd/cpu-xr17032.c
@@ -0,0 +1,71 @@
+/* BFD support for the XR/17032 processor.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Written by monkuous
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+/* Fill the buffer with zero or nop instruction if CODE is true.  */
+
+static void *
+bfd_arch_xr17032_fill (bfd_size_type count,
+		       bool is_bigendian ATTRIBUTE_UNUSED,
+		       bool code)
+{
+  static const char nop [] = { 0x3c, 0x00, 0x00, 0x00 };
+
+  void *fill = bfd_malloc (count);
+  if (fill == NULL)
+    return fill;
+
+  void *p = fill;
+
+  if (code)
+    {
+      while (count >= sizeof(nop))
+	{
+	  memcpy(p, nop, sizeof(nop));
+	  p += sizeof(nop);
+	  count -= sizeof(nop);
+	}
+    }
+
+  memset(p, 0, count);
+
+  return p;
+}
+
+const bfd_arch_info_type bfd_xr17032_arch =
+{
+  32,			/* Bits in a word.  */
+  32,			/* Bits in an address.  */
+  8,			/* Bits in a byte.  */
+  bfd_arch_xr17032,	/* Architecture number.  */
+  bfd_mach_xr17032,
+  "xr17032",		/* Arch name.  */
+  "xr17032",		/* Printable name.  */
+  1,			/* Section alignment power.  */
+  true,			/* The one and only.  */
+  bfd_default_compatible,
+  bfd_default_scan,
+  bfd_arch_xr17032_fill,
+  NULL,
+  0 /* Maximum offset of a reloc from the start of an insn.  */
+};
diff -urN --no-dereference binutils-clean/bfd/elf32-xr17032.c binutils-workdir/bfd/elf32-xr17032.c
--- binutils-clean/bfd/elf32-xr17032.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/bfd/elf32-xr17032.c
@@ -0,0 +1,348 @@
+/* BFD back-end for XR/17032 ELF
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Written by monkuous.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "libiberty.h"
+#include "elf-bfd.h"
+#include "elf/xr17032.h"
+
+#define USE_REL 0
+
+/* xr17032_reloc_map array maps BFD relocation enum into a XR/17032 relocation type.  */
+
+struct xr17032_reloc_map
+{
+  bfd_reloc_code_real_type bfd_reloc_enum; /* BFD relocation enum.  */
+  unsigned short xr17032_reloc_type;	   /* XR/17032 relocation type.  */
+};
+
+static const struct xr17032_reloc_map xr17032_reloc_map[R_XR17032_MAX] =
+{
+  {BFD_RELOC_NONE,	        R_XR17032_NONE},
+  {BFD_RELOC_XR17032_IMM29,     R_XR17032_IMM29},
+  {BFD_RELOC_XR17032_IMM16,     R_XR17032_IMM16},
+  {BFD_RELOC_XR17032_IMM16_1,   R_XR17032_IMM16_1},
+  {BFD_RELOC_XR17032_IMM16_2,   R_XR17032_IMM16_2},
+  {BFD_RELOC_XR17032_IMM16_16,  R_XR17032_IMM16_16},
+  {BFD_RELOC_XR17032_SIMM16,    R_XR17032_SIMM16},
+  {BFD_RELOC_XR17032_DISP16_16, R_XR17032_DISP16_16},
+  {BFD_RELOC_XR17032_SIMM5,     R_XR17032_SIMM5},
+  {BFD_RELOC_XR17032_DISP21,    R_XR17032_DISP21},
+  {BFD_RELOC_XR17032_SHAMT,     R_XR17032_SHAMT},
+  {BFD_RELOC_8,		        R_XR17032_ABS8},
+  {BFD_RELOC_16,	        R_XR17032_ABS16},
+  {BFD_RELOC_32,	        R_XR17032_ABS32},
+  {BFD_RELOC_8_PCREL,	        R_XR17032_PCREL8},
+  {BFD_RELOC_16_PCREL,	        R_XR17032_PCREL16},
+  {BFD_RELOC_32_PCREL,	        R_XR17032_PCREL32},
+};
+
+static reloc_howto_type xr17032_elf_howto_table[] =
+{
+  HOWTO (R_XR17032_NONE,	     /* type */
+	 0,			     /* rightshift */
+	 0,			     /* size */
+	 0,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 0,			     /* bitpos */
+	 complain_overflow_dont,     /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_NONE",	     /* name */
+	 false,			     /* partial_inplace */
+	 0,			     /* src_mask */
+	 0,			     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_IMM29,	     /* type */
+	 2,			     /* rightshift */
+	 4,			     /* size */
+	 29,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 3,			     /* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_IMM29",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0xfffffff8,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_IMM16,	     /* type */
+	 0,			     /* rightshift */
+	 4,			     /* size */
+	 16,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 16,			     /* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_IMM16",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0xffff0000,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_IMM16_1,	     /* type */
+	 1,			     /* rightshift */
+	 4,			     /* size */
+	 16,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 16,			     /* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_IMM16_1",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0xffff0000,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_IMM16_2,	     /* type */
+	 2,			     /* rightshift */
+	 4,			     /* size */
+	 16,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 16,			     /* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_IMM16_2",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0xffff0000,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_IMM16_16,	     /* type */
+	 16,			     /* rightshift */
+	 4,			     /* size */
+	 16,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 16,			     /* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_IMM16_16",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0xffff0000,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_SIMM16,	     /* type */
+	 0,			     /* rightshift */
+	 4,			     /* size */
+	 16,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 16,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_SIMM16",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0xffff0000,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_DISP16_16,	     /* type */
+	 16,			     /* rightshift */
+	 4,			     /* size */
+	 16,			     /* bitsize */
+	 true,			     /* pc_relative */
+	 16,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_DISP16_16",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0xffff0000,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_SIMM5,	     /* type */
+	 0,			     /* rightshift */
+	 4,			     /* size */
+	 5,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 11,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_SIMM5",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0x0000f800,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_DISP21,	     /* type */
+	 2,			     /* rightshift */
+	 4,			     /* size */
+	 21,			     /* bitsize */
+	 true,			     /* pc_relative */
+	 11,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_DISP21",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0xfffff800,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_SHAMT,	     /* type */
+	 0,			     /* rightshift */
+	 4,			     /* size */
+	 5,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 21,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_SHAMT",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0x03e00000,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_ABS8,	     /* type */
+	 0,			     /* rightshift */
+	 1,			     /* size */
+	 8,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 0,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_ABS8",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00,			     /* src_mask */
+	 0xff,			     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_ABS16,	     /* type */
+	 0,			     /* rightshift */
+	 2,			     /* size */
+	 16,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 0,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_ABS16",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x0000,		     /* src_mask */
+	 0xffff,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_ABS32,	     /* type */
+	 0,			     /* rightshift */
+	 4,			     /* size */
+	 32,			     /* bitsize */
+	 false,			     /* pc_relative */
+	 0,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_ABS32",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0xffffffff,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_PCREL8,	     /* type */
+	 0,			     /* rightshift */
+	 1,			     /* size */
+	 8,			     /* bitsize */
+	 true,			     /* pc_relative */
+	 0,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_PCREL8",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00,			     /* src_mask */
+	 0xff,			     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_PCREL16,	     /* type */
+	 0,			     /* rightshift */
+	 2,			     /* size */
+	 16,			     /* bitsize */
+	 true,			     /* pc_relative */
+	 0,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_PCREL16",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x0000,		     /* src_mask */
+	 0xffff,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+  HOWTO (R_XR17032_PCREL32,	     /* type */
+	 0,			     /* rightshift */
+	 4,			     /* size */
+	 32,			     /* bitsize */
+	 true,			     /* pc_relative */
+	 0,			     /* bitpos */
+	 complain_overflow_signed,   /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	     /* special_function */
+	 "R_XR17032_PCREL32",	     /* name */
+	 false,			     /* partial_inplace */
+	 0x00000000,		     /* src_mask */
+	 0xffffffff,		     /* dst_mask */
+	 false),		     /* pcrel_offset */
+};
+
+/* Retrieve a howto ptr using a BFD reloc_code.  */
+
+static reloc_howto_type *
+elf_xr17032_reloc_type_lookup (bfd *abfd,
+			       bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  for (i = 0; i < R_XR17032_MAX; i++)
+    if (code == xr17032_reloc_map[i].bfd_reloc_enum)
+      return &xr17032_elf_howto_table[xr17032_reloc_map[i].xr17032_reloc_type];
+
+  _bfd_error_handler (_("%pB: unsupported relocation type %#x"),
+		      abfd, code);
+  return NULL;
+}
+
+static reloc_howto_type *
+elf_xr17032_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			       const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (xr17032_elf_howto_table); i++)
+    if (xr17032_elf_howto_table[i].name != NULL
+	&& strcasecmp (xr17032_elf_howto_table[i].name, r_name) == 0)
+      return xr17032_elf_howto_table + i;
+
+  return NULL;
+}
+
+static bool
+elf_xr17032_info_to_howto (bfd *abfd, arelent *cache_ptr,
+			   Elf_Internal_Rela *dst)
+{
+  unsigned int r_type = ELF32_R_TYPE (dst->r_info);
+
+  if (r_type >= R_XR17032_MAX)
+  {
+    /* xgettext:c-format */
+    _bfd_error_handler (_("%pB: unsupported relocation type %#x"),
+			abfd, r_type);
+    bfd_set_error (bfd_error_bad_value);
+    return false;
+  }
+
+  cache_ptr->howto = xr17032_elf_howto_table + r_type;
+  return true;
+}
+
+/* Definitions for setting XR/17032 target vector.  */
+#define TARGET_LITTLE_SYM		  xr17032_elf32_vec
+#define TARGET_LITTLE_NAME		  "elf32-xr17032"
+#define ELF_ARCH			  bfd_arch_xr17032
+#define ELF_MACHINE_CODE		  EM_XR17032
+#define ELF_MAXPAGESIZE			  0x1000
+
+#define bfd_elf32_bfd_reloc_type_lookup	  elf_xr17032_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup	  elf_xr17032_reloc_name_lookup
+
+#define elf_info_to_howto		  elf_xr17032_info_to_howto
+#define elf_info_to_howto_rel		  NULL
+
+#include "elf32-target.h"
diff -urN --no-dereference binutils-clean/bfd/libbfd.h binutils-workdir/bfd/libbfd.h
--- binutils-clean/bfd/libbfd.h
+++ binutils-workdir/bfd/libbfd.h
@@ -2910,6 +2910,16 @@
   "BFD_RELOC_IQ2000_OFFSET_16",
   "BFD_RELOC_IQ2000_OFFSET_21",
   "BFD_RELOC_IQ2000_UHI16",
+  "BFD_RELOC_XR17032_IMM29",
+  "BFD_RELOC_XR17032_IMM16",
+  "BFD_RELOC_XR17032_IMM16_1",
+  "BFD_RELOC_XR17032_IMM16_2",
+  "BFD_RELOC_XR17032_IMM16_16",
+  "BFD_RELOC_XR17032_SIMM16",
+  "BFD_RELOC_XR17032_DISP16_16",
+  "BFD_RELOC_XR17032_SIMM5",
+  "BFD_RELOC_XR17032_DISP21",
+  "BFD_RELOC_XR17032_SHAMT",
   "BFD_RELOC_XTENSA_RTLD",
   "BFD_RELOC_XTENSA_GLOB_DAT",
   "BFD_RELOC_XTENSA_JMP_SLOT",
diff -urN --no-dereference binutils-clean/bfd/reloc.c binutils-workdir/bfd/reloc.c
--- binutils-clean/bfd/reloc.c
+++ binutils-workdir/bfd/reloc.c
@@ -6244,6 +6244,29 @@
   IQ2000 Relocations.
 
 ENUM
+  BFD_RELOC_XR17032_IMM29
+ENUMX
+  BFD_RELOC_XR17032_IMM16
+ENUMX
+  BFD_RELOC_XR17032_IMM16_1
+ENUMX
+  BFD_RELOC_XR17032_IMM16_2
+ENUMX
+  BFD_RELOC_XR17032_IMM16_16
+ENUMX
+  BFD_RELOC_XR17032_SIMM16
+ENUMX
+  BFD_RELOC_XR17032_DISP16_16
+ENUMX
+  BFD_RELOC_XR17032_SIMM5
+ENUMX
+  BFD_RELOC_XR17032_DISP21
+ENUMX
+  BFD_RELOC_XR17032_SHAMT
+ENUMDOC
+  XR/17032 Relocations.
+
+ENUM
   BFD_RELOC_XTENSA_RTLD
 ENUMDOC
   Special Xtensa relocation used only by PLT entries in ELF shared
diff -urN --no-dereference binutils-clean/bfd/targets.c binutils-workdir/bfd/targets.c
--- binutils-clean/bfd/targets.c
+++ binutils-workdir/bfd/targets.c
@@ -946,6 +946,7 @@
 extern const bfd_target x86_64_pe_big_vec;
 extern const bfd_target x86_64_pei_vec;
 extern const bfd_target xgate_elf32_vec;
+extern const bfd_target xr17032_elf32_vec;
 extern const bfd_target xstormy16_elf32_vec;
 extern const bfd_target xtensa_elf32_be_vec;
 extern const bfd_target xtensa_elf32_le_vec;
@@ -1361,6 +1362,8 @@
 
 	&xgate_elf32_vec,
 
+	&xr17032_elf32_vec,
+
 	&xstormy16_elf32_vec,
 
 	&xtensa_elf32_be_vec,
diff -urN --no-dereference binutils-clean/binutils/readelf.c binutils-workdir/binutils/readelf.c
--- binutils-clean/binutils/readelf.c
+++ binutils-workdir/binutils/readelf.c
@@ -165,6 +165,7 @@
 #include "elf/wasm32.h"
 #include "elf/x86-64.h"
 #include "elf/xgate.h"
+#include "elf/xr17032.h"
 #include "elf/xstormy16.h"
 #include "elf/xtensa.h"
 #include "elf/z80.h"
@@ -1208,6 +1209,7 @@
     case EM_XGATE:
     case EM_NFP:
     case EM_BPF:
+    case EM_XR17032:
       return false;
 
       /* Targets that use RELA relocations.  */
@@ -2395,6 +2397,10 @@
 	case EM_AMDGPU:
 	  rtype = elf_amdgpu_reloc_type (type);
 	  break;
+
+	case EM_XR17032:
+	  rtype = elf_xr17032_reloc_type (type);
+	  break;
 	}
 
       if (rtype == NULL)
@@ -3452,6 +3458,7 @@
     case EM_ADAPTEVA_EPIPHANY:	return "Adapteva EPIPHANY";
     case EM_CYGNUS_FRV:		return "Fujitsu FR-V";
     case EM_S12Z:               return "Freescale S12Z";
+    case EM_XR17032:		return "XR/17032";
 
     default:
       snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
@@ -11656,6 +11663,7 @@
     { EM_TI_C6000, arm_process_unwind },
     { EM_386, no_processor_specific_unwind },
     { EM_X86_64, no_processor_specific_unwind },
+    { EM_XR17032, no_processor_specific_unwind },
     { 0, NULL }
   };
   int i;
@@ -15569,6 +15577,8 @@
       return reloc_type == 10; /* R_X86_64_32.  */
     case EM_XGATE:
       return reloc_type == 4; /* R_XGATE_32.  */
+    case EM_XR17032:
+      return reloc_type == 13; /* R_XR17032_ABS32. */
     case EM_XSTORMY16:
       return reloc_type == 1; /* R_XSTROMY16_32.  */
     case EM_XTENSA_OLD:
@@ -15657,6 +15667,8 @@
       return reloc_type == 2;  /* R_X86_64_PC32.  */
     case EM_VAX:
       return reloc_type == 4;  /* R_VAX_PCREL32.  */
+    case EM_XR17032:
+      return reloc_type == 16; /* R_XR17032_PCREL32. */
     case EM_XTENSA_OLD:
     case EM_XTENSA:
       return reloc_type == 14; /* R_XTENSA_32_PCREL.  */
@@ -16108,6 +16120,7 @@
     case EM_TILEPRO: /* R_TILEPRO_NONE.  */
     case EM_TI_C6000:/* R_C6000_NONE.  */
     case EM_X86_64:  /* R_X86_64_NONE.  */
+    case EM_XR17032: /* R_XR17032_NONE. */
     case EM_Z80:     /* R_Z80_NONE. */
     case EM_WEBASSEMBLY: /* R_WASM32_NONE.  */
       return reloc_type == 0;
diff -urN --no-dereference binutils-clean/gas/Makefile.am binutils-workdir/gas/Makefile.am
--- binutils-clean/gas/Makefile.am
+++ binutils-workdir/gas/Makefile.am
@@ -210,6 +210,7 @@
 	config/tc-vax.c \
 	config/tc-visium.c \
 	config/tc-wasm32.c \
+	config/tc-xr17032.c \
 	config/tc-xstormy16.c \
 	config/tc-xgate.c \
 	config/tc-xtensa.c \
@@ -283,6 +284,7 @@
 	config/tc-vax.h \
 	config/tc-visium.h \
 	config/tc-wasm32.h \
+	config/tc-xr17032.h \
 	config/tc-xstormy16.h \
 	config/tc-xgate.h \
 	config/tc-xtensa.h \
diff -urN --no-dereference binutils-clean/gas/config/tc-xr17032.c binutils-workdir/gas/config/tc-xr17032.c
--- binutils-clean/gas/config/tc-xr17032.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/gas/config/tc-xr17032.c
@@ -0,0 +1,948 @@
+/* tc-xr17032.c -- Assembler code for the XR/17032 CPU core.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+
+   Contributed by monkuous
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "dwarf2dbg.h"
+#include "opcode/xr17032.h"
+#include "elf/xr17032.h"
+
+#include <limits.h>
+#ifndef CHAR_BIT
+#define CHAR_BIT 8
+#endif
+
+#define streq(a, b)	(strcmp (a, b) == 0)
+
+/* Characters which always start a comment.  */
+const char comment_chars[] = "#";
+
+/* Characters which start a comment at the beginning of a line.  */
+const char line_comment_chars[] = "#";
+
+/* This array holds machine specific line separator characters.  */
+const char line_separator_chars[] = ";";
+
+/* Chars that can be used to separate mant from exp in floating point nums.  */
+const char EXP_CHARS[] = "eE";
+
+/* Chars that mean this number is a floating point constant as in 0f12.456  */
+const char FLT_CHARS[] = "fF";
+
+static symbolS *GOT_symbol;
+
+/* Target-specific multicharacter options, not const-declared at usage.  */
+const char md_shortopts[] = "";
+const struct option md_longopts[] =
+{
+  {NULL, no_argument, NULL, 0}
+};
+const size_t md_longopts_size = sizeof (md_longopts);
+
+const pseudo_typeS md_pseudo_table[] =
+{
+  {"align", s_align_bytes, 0},
+  {0, 0, 0}
+};
+
+static htab_t xr17032_inst_hash;
+static htab_t xr17032_reg_hash;
+static htab_t xr17032_creg_hash;
+
+symbolS *
+md_undefined_symbol (char *name)
+{
+  if (name[0] == GLOBAL_OFFSET_TABLE_NAME[0]
+    && name[1] == GLOBAL_OFFSET_TABLE_NAME[1]
+    && name[2] == GLOBAL_OFFSET_TABLE_NAME[2]
+    && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
+  {
+    if (!GOT_symbol)
+    {
+      if (symbol_find (name))
+	as_bad (_("GOT already in symbol table"));
+      GOT_symbol = symbol_new (name, undefined_section,
+			       &zero_address_frag, 0);
+    };
+    return GOT_symbol;
+  }
+  return 0;
+}
+
+/* Process machine-dependent command line options.  Called once for
+ *  each option on the command line that the machine-independent part of
+ *  GAS does not understand.  */
+
+int
+md_parse_option (int c ATTRIBUTE_UNUSED, const char *arg ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* Machine-dependent usage-output.  */
+
+void
+md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
+{
+  return;
+}
+
+/* This function is called once, at assembler startup time.  This should
+ *  set up all the tables, etc that the MD part of the assembler needs.  */
+
+void
+md_begin (void)
+{
+  xr17032_inst_hash = str_htab_create ();
+  xr17032_reg_hash = str_htab_create ();
+  xr17032_creg_hash = str_htab_create ();
+
+  for (unsigned int i = 0; i < xr17032_num_opcodes; i++)
+    {
+      const inst *insn = &xr17032_instruction[i];
+
+      if (str_hash_insert (xr17032_inst_hash, insn->mnemonic, insn, 0))
+	as_fatal (_("duplicate mnemonic: `%s`"), insn->mnemonic);
+
+      /* skip over instructions with the same mnemonic */
+      while (i + 1 < xr17032_num_opcodes
+	     && streq (insn->mnemonic, xr17032_instruction[i + 1].mnemonic))
+	i++;
+    }
+
+  for (unsigned int i = 0; i < xr17032_num_registers; i++)
+    {
+      const reg_entry *reg_val = &xr17032_register[i];
+
+      if (str_hash_insert (xr17032_reg_hash, reg_val->name, reg_val, 0))
+	as_fatal (_("duplicate register: `%s`"), reg_val->name);
+    }
+
+  for (unsigned int i = 0; i < xr17032_num_cregisters; i++)
+    {
+      const reg_entry *reg_val = &xr17032_cregister[i];
+
+      if (str_hash_insert (xr17032_creg_hash, reg_val->name, reg_val, 0))
+	as_fatal (_("duplicate control register: `%s`"), reg_val->name);
+    }
+}
+
+/* Parse an operand that is machine-specific.  */
+
+void
+md_operand (expressionS * exp ATTRIBUTE_UNUSED)
+{
+}
+
+const char *
+md_atof (int type, char *litP, int *sizeP)
+{
+  return ieee_md_atof (type, litP, sizeP, target_big_endian);
+}
+
+/* This is the guts of the machine-dependent assembler.  OP points to a
+ *  machine dependent instruction.  This function is supposed to emit
+ *  the frags/bytes it assembles to.  */
+
+static const inst *
+xr17032_parse_opcode (char **str)
+{
+  char *start = *str;
+  char *cur = start;
+
+  while (*cur != '\0' && !ISSPACE(*cur))
+    cur++;
+
+  char orig = *cur;
+  *cur = '\0';
+
+  const inst *insn = (const inst *) str_hash_find (xr17032_inst_hash, start);
+
+  if (!insn)
+    {
+      as_bad (_("unknown opcode `%s`"), start);
+      return NULL;
+    }
+
+  *cur = orig;
+
+  while (*cur != '\0' && ISSPACE(*cur))
+    cur++;
+
+  if ((insn->flags & XR17032_SIGNED_VARIANT) == 0)
+    goto done;
+
+  char *cur2 = cur;
+
+  while (*cur2 != '\0' && !ISSPACE(*cur2))
+    cur2++;
+
+  orig = *cur2;
+  *cur2 = '\0';
+
+  if (strcasecmp (cur, "signed") == 0)
+    {
+      insn++;
+      cur = cur2;
+    }
+
+  *cur2 = orig;
+
+  while (*cur != '\0' && ISSPACE(*cur))
+    cur++;
+
+done:
+  *str = cur;
+  return insn;
+}
+
+typedef struct
+{
+  expressionS expr;
+} imm_val;
+
+typedef union
+{
+  imm_val constant_val;
+  struct {
+    reg base_reg;
+    reg_op op_type;
+    imm_val op_val;
+  } reg_val;
+  creg creg_val;
+  struct {
+    reg base_reg;
+    reg offset_reg;
+    reg_op op_type;
+    imm_val op_val;
+  } mem_val;
+}
+argument;
+
+typedef struct
+{
+  const inst *insn;
+  argument arguments[XR17032_MAX_OPERANDS];
+}
+ins;
+
+static bool
+xr17032_parse_constant (argument *out, char *text)
+{
+  expressionS *pexpr = &out->constant_val.expr;
+
+  char *saved_input_line_pointer = input_line_pointer;
+  input_line_pointer = text;
+  expression (pexpr);
+
+  bool ok = true;
+
+  switch (pexpr->X_op)
+    {
+    case O_big:
+    case O_absent:
+      ok = false;
+      pexpr->X_op = O_constant;
+      pexpr->X_add_number = 0;
+      pexpr->X_add_symbol = NULL;
+      pexpr->X_op_symbol = NULL;
+      break;
+    default:
+      break;
+    }
+
+  input_line_pointer = saved_input_line_pointer;
+  return ok;
+}
+
+static bool
+xr17032_parse_regr (argument *out, char *text, bool shift, bool report)
+{
+  char *start = text;
+  char orig;
+  argument tmp_arg;
+
+  if (shift)
+    {
+      while (*text != '\0' && !ISSPACE(*text))
+	text++;
+
+      orig = *text;
+      *text = '\0';
+    }
+
+  const reg_entry *entry = (const reg_entry *)str_hash_find (xr17032_reg_hash,
+							     start);
+
+  if (!entry)
+    {
+      if (shift)
+	*text = orig;
+      if (report)
+	as_bad (_("invalid register `%s`"), start);
+      return false;
+    }
+
+  out->reg_val.base_reg = entry->reg_val;
+
+  if (shift)
+    {
+      *text = orig;
+
+      while (*text != '\0' && ISSPACE(*text))
+	text++;
+
+      start = text;
+
+      while (*text != '\0' && ISALPHA(*text))
+	text++;
+
+      if (start == text)
+	goto no_shift;
+
+      orig = *text;
+      *text = '\0';
+
+      if (strcasecmp (start, "lsh") == 0)
+	out->reg_val.op_type = reg_lsh;
+      else if (strcasecmp (start, "rsh") == 0)
+	out->reg_val.op_type = reg_rsh;
+      else if (strcasecmp (start, "ash") == 0)
+	out->reg_val.op_type = reg_ash;
+      else if (strcasecmp (start, "ror") == 0)
+	out->reg_val.op_type = reg_ror;
+      else
+	{
+	  *text = orig;
+	  if (report)
+	    as_bad (_("invalid register operation `%s`"), start);
+	  return false;
+	}
+
+      *text = orig;
+
+      if (!xr17032_parse_constant (&tmp_arg, text))
+	return false;
+
+      out->reg_val.op_val = tmp_arg.constant_val;
+      return true;
+    }
+
+no_shift:
+  char buffer[2];
+  buffer[0] = '0';
+  buffer[1] = '\0';
+
+  if (!xr17032_parse_constant (&tmp_arg, buffer))
+    return false;
+
+  out->reg_val.op_type = reg_lsh;
+  out->reg_val.op_val = tmp_arg.constant_val;
+  return true;
+}
+
+static bool
+xr17032_parse_cregr (argument *out, char *text)
+{
+  const reg_entry *entry = (const reg_entry *)str_hash_find (xr17032_creg_hash,
+							     text);
+
+  if (!entry)
+    return false;
+
+  out->creg_val = entry->creg_val;
+  return true;
+}
+
+static bool
+xr17032_parse_argument (argument *out, char *text, operand_type type)
+{
+  switch (type)
+    {
+    case simm16:
+    case simm5:
+    case imm29:
+    case imm16:
+    case imm16_16:
+    case imm16_2:
+    case disp21:
+    case disp16_16:
+      return xr17032_parse_constant (out, text);
+    case regA:
+    case regB:
+    case regC:
+      return xr17032_parse_regr (out, text, false, true);
+    case regC_shift:
+      return xr17032_parse_regr (out, text, true, true);
+    case cregC:
+      return xr17032_parse_cregr (out, text);
+    default:
+      as_fatal (_("unknown operand type %d"), type);
+      return false;
+    }
+}
+
+static char *
+xr17032_find_param_end (char *text)
+{
+  unsigned int num_brackets = 0;
+  bool in_sq_brackets = false;
+
+  while (*text != '\0')
+    {
+      char c = *text;
+
+      switch (c)
+	{
+	case '(':
+	  num_brackets += 1;
+	  break;
+	case ')':
+	  if (num_brackets > 0)
+	    num_brackets -= 1;
+	  else
+	    as_fatal (_("extraneous ')'"));
+	  break;
+	case '[':
+	  if (!in_sq_brackets && num_brackets == 0)
+	    in_sq_brackets = true;
+	  else
+	    as_fatal (_("illegal '['"));
+	  break;
+	case ']':
+	  if (num_brackets == 0)
+	    if (in_sq_brackets)
+	      in_sq_brackets = false;
+	    else
+	      as_fatal (_("extraneous ']"));
+	  else
+	    as_fatal (_("illegal ']'"));
+	  break;
+	case ',':
+	  if (!in_sq_brackets && num_brackets == 0)
+	    return text;
+	  break;
+	}
+
+      text++;
+    }
+
+  return text;
+}
+
+static bool
+xr17032_parse_arguments (ins *out, char *params)
+{
+  for (int i = 0; i < XR17032_MAX_OPERANDS; i++)
+    {
+      operand_type wanted = out->insn->operands[i];
+
+      if (wanted == dummy)
+	break;
+
+      if (i != 0 && *params++ != ',')
+	{
+	  as_bad (_("not enough operands"));
+	  return false;
+	}
+
+      char *end = xr17032_find_param_end (params);
+      char orig = *end;
+      *end = '\0';
+
+      if (!xr17032_parse_argument (&out->arguments[i], params, wanted))
+	return false;
+
+      *end = orig;
+      params = end;
+    }
+
+  if (*params)
+    {
+      as_bad (_("too many operands"));
+      return false;
+    }
+
+  return true;
+}
+
+static bool
+xr17032_argtypes_match (const inst *wanted, const operand_type *actual, int count)
+{
+  for (int i = 0; i < XR17032_MAX_OPERANDS; i++)
+    {
+      operand_type wanted_type = wanted->operands[i];
+      operand_type actual_type = i < count ? actual[i] : dummy;
+
+      if (wanted_type != actual_type)
+	return false;
+    }
+
+  return true;
+}
+
+static bool
+xr17032_parse_mem_arg (argument *out, char *text, operand_type *type)
+{
+  char *bracket = strchr (text, '[');
+  char *start = bracket + 1;
+  char *end = strchr (text, ']');
+
+  if (!end)
+    {
+      as_bad (_("unterminated memory operand"));
+      return false;
+    }
+
+  *end = '\0';
+
+  char *disp_start = start;
+
+  while (disp_start != end && *disp_start != '+')
+    disp_start++;
+
+  bool is_reg;
+  argument tmp_arg;
+
+  if (disp_start == end)
+    {
+      /* either [regr], [regr_shift], or [imm16]. only [regr_shift] requires
+       * is_reg=true. [regr] uses is_reg=true as well, because it's simpler. */
+      if (xr17032_parse_regr (&tmp_arg, start, true, false))
+	{
+	  is_reg = true;
+	  out->mem_val.base_reg = zero;
+	  out->mem_val.offset_reg = tmp_arg.reg_val.base_reg;
+	  out->mem_val.op_type = tmp_arg.reg_val.op_type;
+	  out->mem_val.op_val = tmp_arg.reg_val.op_val;
+	}
+      else if (xr17032_parse_constant (&tmp_arg, start))
+	{
+	  is_reg = false;
+	  out->mem_val.base_reg = zero;
+	  out->mem_val.offset_reg = zero;
+	  out->mem_val.op_type = reg_lsh;
+	  out->mem_val.op_val = tmp_arg.constant_val;
+	}
+      else
+	return false;
+    }
+  else
+    {
+      *disp_start++ = '\0';
+
+      /* either [regr+imm16] or [regr+regr_shift]. only [regr+regr_shift] requires is_reg=true. */
+      if (xr17032_parse_regr (&tmp_arg, disp_start, true, false))
+	{
+	  is_reg = true;
+	  out->mem_val.offset_reg = tmp_arg.reg_val.base_reg;
+	  out->mem_val.op_type = tmp_arg.reg_val.op_type;
+	  out->mem_val.op_val = tmp_arg.reg_val.op_val;
+	}
+      else if (xr17032_parse_constant (&tmp_arg, disp_start))
+	{
+	  is_reg = false;
+	  out->mem_val.offset_reg = zero;
+	  out->mem_val.op_type = reg_lsh;
+	  out->mem_val.op_val = tmp_arg.constant_val;
+	}
+      else
+	return false;
+
+      *disp_start = '\0';
+
+      if (!xr17032_parse_regr (&tmp_arg, start, false, true))
+	return false;
+
+      out->mem_val.base_reg = tmp_arg.reg_val.base_reg;
+    }
+
+  if (bracket != text)
+    {
+      *bracket = '\0';
+
+      if (strcasecmp (text, "byte") == 0)
+	*type = is_reg ? memreg8 : memimm8;
+      else if (strcasecmp (text, "int") == 0)
+	*type = is_reg ? memreg16 : memimm16;
+      else if (strcasecmp (text, "long") == 0)
+	*type = is_reg ? memreg32 : memimm32;
+      else
+	{
+	  as_bad (_("invalid memory operand size `%s`"), text);
+	  return false;
+	}
+    }
+  else
+    {
+      as_warn (_("no size given for memory operand, defaulting to 32 bits"));
+      *type = is_reg ? memreg32 : memimm32;
+    }
+
+  return true;
+}
+
+static bool
+xr17032_parse_mov_args (ins *out, char *params)
+{
+  char *argtext[2];
+  operand_type argtype[ARRAY_SIZE(argtext)];
+
+  for (unsigned int i = 0; i < ARRAY_SIZE(argtext); i++)
+    {
+      argtext[i] = params;
+
+      char *end = xr17032_find_param_end (params);
+
+      if (i + 1 < ARRAY_SIZE(argtext) && *end != ',')
+	{
+	  as_bad (_("not enough operands"));
+	  return false;
+	}
+
+      if (*end)
+	params = end + 1;
+      else
+	params = end;
+
+      *end = '\0';
+    }
+
+  if (*params)
+    {
+      as_bad (_("too many operands (`%s`, `%s`, `%s`)"), argtext[0], argtext[1], params);
+      return false;
+    }
+
+  argtype[0] = strchr (argtext[0], '[') != NULL ? memimm32 : regA;
+
+  if (argtype[0] == regA)
+    argtype[1] = memimm32;
+  else if (str_hash_find (xr17032_reg_hash, argtext[1]) != NULL)
+    argtype[1] = regB;
+  else
+    argtype[1] = simm5;
+
+  for (unsigned int i = 0; i < ARRAY_SIZE(argtext); i++)
+    {
+      operand_type type = argtype[i];
+
+      if (type == memimm32)
+	{
+	  if (!xr17032_parse_mem_arg (&out->arguments[i], argtext[i], &argtype[i]))
+	    return false;
+	}
+      else if (!xr17032_parse_argument (&out->arguments[i], argtext[i], type))
+	return false;
+    }
+
+  if (argtype[0] == memreg8 || argtype[0] == memreg16
+      || argtype[0] == memreg32)
+    argtype[1] = regA;
+
+  while (!xr17032_argtypes_match(out->insn, argtype, ARRAY_SIZE(argtype)))
+    {
+      if ((out->insn->flags & XR17032_MULTI_OPCODES) == 0)
+	{
+	  as_bad (_("no matching mov opcode for operands"));
+	  return false;
+	}
+
+      out->insn++;
+    }
+
+  return true;
+}
+
+static bool
+xr17032_parse_insn (ins *out, char *params)
+{
+  out->insn = xr17032_parse_opcode (&params);
+
+  if (!out->insn)
+    return false;
+
+  if (streq (out->insn->mnemonic, "mov"))
+    return xr17032_parse_mov_args (out, params);
+  else
+    return xr17032_parse_arguments (out, params);
+}
+
+static void
+xr17032_print_insn (const ins *insn)
+{
+  unsigned int data = insn->insn->opcode_bits;
+  char *frag = frag_more(4);
+
+  for (int i = 0; i < XR17032_MAX_OPERANDS; i++)
+    {
+      operand_type type = insn->insn->operands[i];
+      bfd_reloc_code_real_type rtype = BFD_RELOC_NONE;
+      const imm_val *imm = NULL;
+
+      switch (type)
+	{
+	case dummy:
+	  goto operand_done;
+	case imm29:
+	  rtype = BFD_RELOC_XR17032_IMM29;
+	  imm = &insn->arguments[i].constant_val;
+	  break;
+	case imm16:
+	  rtype = BFD_RELOC_XR17032_IMM16;
+	  imm = &insn->arguments[i].constant_val;
+	  break;
+	case imm16_16:
+	  rtype = BFD_RELOC_XR17032_IMM16_16;
+	  imm = &insn->arguments[i].constant_val;
+	  break;
+	case imm16_2:
+	  rtype = BFD_RELOC_XR17032_IMM16_2;
+	  imm = &insn->arguments[i].constant_val;
+	  break;
+	case simm16:
+	  rtype = BFD_RELOC_XR17032_SIMM16;
+	  imm = &insn->arguments[i].constant_val;
+	  break;
+	case simm5:
+	  rtype = BFD_RELOC_XR17032_SIMM5;
+	  imm = &insn->arguments[i].constant_val;
+	  break;
+	case disp21:
+	  rtype = BFD_RELOC_XR17032_DISP21;
+	  imm = &insn->arguments[i].constant_val;
+	  break;
+	case disp16_16:
+	  rtype = BFD_RELOC_XR17032_DISP16_16;
+	  imm = &insn->arguments[i].constant_val;
+	  break;
+	case regA:
+	  data |= insn->arguments[i].reg_val.base_reg << 6;
+	  break;
+	case regB:
+	  data |= insn->arguments[i].reg_val.base_reg << 11;
+	  break;
+	case regC:
+	  data |= insn->arguments[i].reg_val.base_reg << 16;
+	  break;
+	case regC_shift:
+	  data |= insn->arguments[i].reg_val.base_reg << 16;
+	  data |= insn->arguments[i].reg_val.op_type << 26;
+	  rtype = BFD_RELOC_XR17032_SHAMT;
+	  imm = &insn->arguments[i].reg_val.op_val;
+	  break;
+	case cregC:
+	  data |= insn->arguments[i].creg_val << 16;
+	  break;
+	case memimm8:
+	  data |= insn->arguments[i].mem_val.base_reg << (6 + 5 * i);
+	  rtype = BFD_RELOC_XR17032_IMM16;
+	  imm = &insn->arguments[i].mem_val.op_val;
+	  break;
+	case memimm16:
+	  data |= insn->arguments[i].mem_val.base_reg << (6 + 5 * i);
+	  rtype = BFD_RELOC_XR17032_IMM16_1;
+	  imm = &insn->arguments[i].mem_val.op_val;
+	  break;
+	case memimm32:
+	  data |= insn->arguments[i].mem_val.base_reg << (6 + 5 * i);
+	  rtype = BFD_RELOC_XR17032_IMM16_2;
+	  imm = &insn->arguments[i].mem_val.op_val;
+	  break;
+	case memreg8:
+	case memreg16:
+	case memreg32:
+	  data |= insn->arguments[i].mem_val.base_reg << 11;
+	  data |= insn->arguments[i].mem_val.offset_reg << 16;
+	  data |= insn->arguments[i].mem_val.op_type << 26;
+	  rtype = BFD_RELOC_XR17032_SHAMT;
+	  imm = &insn->arguments[i].mem_val.op_val;
+	  break;
+	default:
+	  as_bad (_("don't know how to emit %d"), type);
+	  break;
+	}
+
+      if (rtype != BFD_RELOC_NONE)
+	{
+	  reloc_howto_type *howto = bfd_reloc_type_lookup (stdoutput, rtype);
+
+	  if (!howto)
+	    abort ();
+
+	  fix_new_exp (frag_now, frag - frag_now->fr_literal,
+		       bfd_get_reloc_size (howto), &imm->expr,
+		       howto->pc_relative, rtype);
+	}
+    }
+
+operand_done:
+  md_number_to_chars (frag, (valueT) data, 4);
+}
+
+void
+md_assemble (char *op)
+{
+  ins insn;
+
+  if (!xr17032_parse_insn (&insn, op))
+    return;
+
+  xr17032_print_insn(&insn);
+}
+
+/* Relax a machine dependent frag.  This returns the amount by which
+ *  the current size of the frag should change.  */
+
+void
+md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT asec ATTRIBUTE_UNUSED,
+		 fragS *fragp ATTRIBUTE_UNUSED)
+{
+  as_fatal ("TODO XR/17032 md_convert_frag");
+  abort();
+}
+
+/* Round up a section size to the appropriate boundary.  */
+
+valueT
+md_section_align (segT seg, valueT val)
+{
+  /* Round .text section to a multiple of 4.  */
+  if (seg == text_section)
+    return (val + 3) & ~3;
+  return val;
+}
+
+/* Generate a relocation entry for a fixup.  */
+
+arelent *
+tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS * fixp)
+{
+  arelent *reloc;
+
+  reloc = notes_alloc (sizeof(arelent));
+  reloc->sym_ptr_ptr = notes_alloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->addend = fixp->fx_addnumber;
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("cannot represent %s relocation in object file"),
+		    bfd_get_reloc_code_name (fixp->fx_r_type));
+      return NULL;
+    }
+
+  return reloc;
+}
+
+/* The location from which a PC relative jump should be calculated,
+ *  given a PC relative reloc.  */
+
+long
+md_pcrel_from (fixS *fixp)
+{
+  return fixp->fx_frag->fr_address + fixp->fx_where;
+}
+
+/* Apply a fixS (fixup of an instruction or data that we didn't have
+ *  enough info to complete immediately) to the data in a frag.  */
+
+void
+md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
+{
+  bfd_byte *buf = (bfd_byte *) (fixP->fx_frag->fr_literal + fixP->fx_where);
+
+  unsigned int bits;
+
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_XR17032_IMM29:
+      bits = ((*valP >> 2) & 0x1fffffff) << 3;
+      break;
+    case BFD_RELOC_XR17032_IMM16:
+      bits = (*valP & 0xffff) << 16;
+      break;
+    case BFD_RELOC_XR17032_IMM16_1:
+      bits = ((*valP >> 1) & 0xffff) << 16;
+      break;
+    case BFD_RELOC_XR17032_IMM16_2:
+      bits = ((*valP >> 2) & 0xffff) << 16;
+      break;
+    case BFD_RELOC_XR17032_IMM16_16:
+      bits = ((*valP >> 16) & 0xffff) << 16;
+      break;
+    case BFD_RELOC_XR17032_SIMM16:
+      bits = (*valP & 0xffff) << 16;
+      break;
+    case BFD_RELOC_XR17032_SIMM5:
+      bits = (*valP & 0x1f) << 11;
+      break;
+    case BFD_RELOC_XR17032_DISP21:
+      bits = ((*valP >> 2) & 0x1fffff) << 11;
+      break;
+    case BFD_RELOC_XR17032_DISP16_16:
+      bits = ((*valP >> 16) & 0xffff) << 16;
+      break;
+    case BFD_RELOC_XR17032_SHAMT:
+      bits = (*valP & 0x1f) << 21;
+      break;
+    case BFD_RELOC_8:
+    case BFD_RELOC_8_PCREL:
+      *buf = *valP & 0xff;
+      goto done;
+    case BFD_RELOC_16:
+    case BFD_RELOC_16_PCREL:
+      bfd_putl16 (*valP & 0xffff, buf);
+      goto done;
+    case BFD_RELOC_32:
+    case BFD_RELOC_32_PCREL:
+      bfd_putl32 (*valP & 0xffffffff, buf);
+      goto done;
+    default:
+      as_fatal (_("internal: bad relocation %d"), fixP->fx_r_type);
+      return;
+    }
+
+  bfd_putl32 (bits | bfd_getl32 (buf), buf);
+
+done:
+  if (fixP->fx_addsy == NULL)
+    fixP->fx_done = true;
+
+  if (fixP->fx_subsy != NULL)
+    as_bad_subtract (fixP);
+
+  fixP->fx_addnumber = *valP;
+}
+
+/* Prepare machine-dependent frags for relaxation.  */
+
+int
+md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
+			       asection *seg ATTRIBUTE_UNUSED)
+{
+  as_fatal ("TODO XR/17032 md_estimate_size_before_relax");
+  abort();
+}
diff -urN --no-dereference binutils-clean/gas/config/tc-xr17032.h binutils-workdir/gas/config/tc-xr17032.h
--- binutils-clean/gas/config/tc-xr17032.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/gas/config/tc-xr17032.h
@@ -0,0 +1,39 @@
+/* tc-xr17032.h -- Header file for tc-xr17032.c, the XR/17032 GAS port.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+
+   Contributed by monkuous
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#ifndef TC_XR17032_H
+#define TC_XR17032_H
+
+#define TC_XR17032 1
+
+#define TARGET_BYTES_BIG_ENDIAN 0
+
+#define GLOBAL_OFFSET_TABLE_NAME "_GLOBAL_OFFSET_TABLE_"
+
+#define TARGET_FORMAT "elf32-xr17032"
+#define TARGET_ARCH   bfd_arch_xr17032
+
+#define WORKING_DOT_WORD
+
+#define md_number_to_chars      number_to_chars_littleendian
+
+#endif /* TC_XR17032_H */
diff -urN --no-dereference binutils-clean/gas/configure.tgt binutils-workdir/gas/configure.tgt
--- binutils-clean/gas/configure.tgt
+++ binutils-workdir/gas/configure.tgt
@@ -425,6 +425,8 @@
 
   wasm32-*-*)                           fmt=elf ;;
 
+  xr17032-*-linux*)			fmt=elf em=linux ;;
+
   xstormy16-*-*)			fmt=elf ;;
   
   xgate-*-*)    			fmt=elf ;;
diff -urN --no-dereference binutils-clean/gprofng/libcollector/configure.ac binutils-workdir/gprofng/libcollector/configure.ac
--- binutils-clean/gprofng/libcollector/configure.ac
+++ binutils-workdir/gprofng/libcollector/configure.ac
@@ -18,7 +18,7 @@
 
 m4_include([../../bfd/version.m4])
 AC_INIT([gprofng], [BFD_VERSION])
-AC_CONFIG_MACRO_DIRS([../../config ../..])
+#AC_CONFIG_MACRO_DIRS([../../config ../..])
 AC_CONFIG_AUX_DIR(../..)
 AC_CANONICAL_TARGET
 AM_INIT_AUTOMAKE
diff -urN --no-dereference binutils-clean/include/elf/common.h binutils-workdir/include/elf/common.h
--- binutils-clean/include/elf/common.h
+++ binutils-workdir/include/elf/common.h
@@ -459,6 +459,8 @@
    architecture was derived.  */
 #define EM_CSKY_OLD		EM_MCORE
 
+#define EM_XR17032  0xb5f0 /* XR/17032 */
+
 /* See the above comment before you add a new EM_* value here.  */
 
 /* Values for e_version.  */
diff -urN --no-dereference binutils-clean/include/elf/xr17032.h binutils-workdir/include/elf/xr17032.h
--- binutils-clean/include/elf/xr17032.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/include/elf/xr17032.h
@@ -0,0 +1,47 @@
+/* XR/17032 ELF support for BFD.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Contributed by monkuous.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_XR17032_H
+#define _ELF_XR17032_H
+
+#include "elf/reloc-macros.h"
+
+/* Creating indices for reloc_map_index array.  */
+START_RELOC_NUMBERS(elf_xr17032_reloc_type)
+  RELOC_NUMBER (R_XR17032_NONE,        0)
+  RELOC_NUMBER (R_XR17032_IMM29,       1)
+  RELOC_NUMBER (R_XR17032_IMM16,       2)
+  RELOC_NUMBER (R_XR17032_IMM16_1,     3)
+  RELOC_NUMBER (R_XR17032_IMM16_2,     4)
+  RELOC_NUMBER (R_XR17032_IMM16_16,    5)
+  RELOC_NUMBER (R_XR17032_SIMM16,      6)
+  RELOC_NUMBER (R_XR17032_DISP16_16,   7)
+  RELOC_NUMBER (R_XR17032_SIMM5,       8)
+  RELOC_NUMBER (R_XR17032_DISP21,      9)
+  RELOC_NUMBER (R_XR17032_SHAMT,       10)
+  RELOC_NUMBER (R_XR17032_ABS8,        11)
+  RELOC_NUMBER (R_XR17032_ABS16,       12)
+  RELOC_NUMBER (R_XR17032_ABS32,       13)
+  RELOC_NUMBER (R_XR17032_PCREL8,      14)
+  RELOC_NUMBER (R_XR17032_PCREL16,     15)
+  RELOC_NUMBER (R_XR17032_PCREL32,     16)
+END_RELOC_NUMBERS(R_XR17032_MAX)
+
+#endif /* _ELF_XR17032_H */
diff -urN --no-dereference binutils-clean/include/opcode/xr17032.h binutils-workdir/include/opcode/xr17032.h
--- binutils-clean/include/opcode/xr17032.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/include/opcode/xr17032.h
@@ -0,0 +1,119 @@
+/* xr17032.h -- Header file for XR/17032 opcode and register tables.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Contributed by monkuous
+
+   This file is part of GAS, GDB and the GNU binutils.
+
+   GAS, GDB, and GNU binutils is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GAS, GDB, and GNU binutils are distributed in the hope that they will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _XR17032_H_
+#define _XR17032_H_
+
+typedef enum
+{
+  zero = 0,
+  t0 = 1, t1, t2, t3, t4, t5,
+  a0 = 7, a1, a2, a3,
+  s0 = 11, s1, s2, s3, s4, s5, s6, s7, s8,
+  s9 = 20, s10, s11, s12, s13, s14, s15, s16, s17,
+  tp = 29, sp, lr,
+}
+reg;
+
+typedef enum
+{
+  rs = 0,
+  whami = 1,
+  eb = 5,
+  epc = 6,
+  ebadaddr = 7,
+  tbmissaddr = 9,
+  tbpc = 10,
+  scratch0 = 11, scratch1, scratch2, scratch3, scratch4,
+  itbpte = 16,
+  itbtag = 17,
+  itbindex = 18,
+  itbctrl = 19,
+  icachectrl = 20,
+  itbaddr = 21,
+  dtbpte = 24,
+  dtbtag = 25,
+  dtbindex = 26,
+  dtbctrl = 27,
+  dcachectrl = 28,
+  dtbaddr = 29,
+}
+creg;
+
+typedef enum
+{
+  dummy = 0,
+  imm29, imm16, imm16_16, imm16_2,
+  simm16, simm5,
+  disp21, disp16_16,
+  regA, regB, regC, regC_shift, cregC,
+  memimm8, memimm16, memimm32,
+  memreg8, memreg16, memreg32,
+}
+operand_type;
+
+typedef enum
+{
+  reg_lsh,
+  reg_rsh,
+  reg_ash,
+  reg_ror,
+}
+reg_op;
+
+#define XR17032_SIGNED_VARIANT	(1u << 0)
+#define XR17032_MULTI_OPCODES	(1u << 1)
+
+#define XR17032_MAX_OPERANDS	3
+
+typedef struct
+{
+  const char *mnemonic;
+  unsigned int flags;
+  unsigned int match_mask;
+  unsigned int opcode_bits;
+  operand_type operands[XR17032_MAX_OPERANDS];
+}
+inst;
+
+typedef struct
+{
+  const char *name;
+  union
+  {
+    reg reg_val;
+    creg creg_val;
+  };
+}
+reg_entry;
+
+/* XR/17032 opcode table */
+extern const inst xr17032_instruction[];
+extern const unsigned int xr17032_num_opcodes;
+
+/* XR/17032 register table */
+extern const reg_entry xr17032_register[];
+extern const unsigned int xr17032_num_registers;
+
+/* XR/17032 control register table */
+extern const reg_entry xr17032_cregister[];
+extern const unsigned int xr17032_num_cregisters;
+
+#endif /* _XR17032_H_ */
diff -urN --no-dereference binutils-clean/ld/Makefile.am binutils-workdir/ld/Makefile.am
--- binutils-clean/ld/Makefile.am
+++ binutils-workdir/ld/Makefile.am
@@ -285,6 +285,7 @@
 	eelf_i386_vxworks.c \
 	eelf_iamcu.c \
 	eelf_s390.c \
+	eelf_xr17032.c \
 	eh8300elf.c \
 	eh8300elf_linux.c \
 	eh8300helf.c \
diff -urN --no-dereference binutils-clean/ld/configure.tgt binutils-workdir/ld/configure.tgt
--- binutils-clean/ld/configure.tgt
+++ binutils-workdir/ld/configure.tgt
@@ -1073,6 +1073,10 @@
 xgate-*-*)		targ_emul=xgateelf
 			targ_extra_ofiles=ldelfgen.o
 			;;
+xr17032-*-elf*)		targ_emul=elf_xr17032
+			;;
+xr17032-*-linux-*)	targ_emul=elf_xr17032
+			;;
 xstormy16-*-*)		targ_emul=elf32xstormy16
 			;;
 xtensa*-*-*)		targ_emul=elf32xtensa
diff -urN --no-dereference binutils-clean/ld/emulparams/elf_xr17032.sh binutils-workdir/ld/emulparams/elf_xr17032.sh
--- binutils-clean/ld/emulparams/elf_xr17032.sh	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/ld/emulparams/elf_xr17032.sh
@@ -0,0 +1,20 @@
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-xr17032"
+NO_RELA_RELOCS=yes
+TEXT_START_ADDR=0x08000000
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+COMMONPAGESIZE="CONSTANT (COMMONPAGESIZE)"
+ARCH=xr17032
+MACHINE=
+TEMPLATE_NAME=elf
+EXTRA_EM_FILE="elf-generic"
+GENERATE_SHLIB_SCRIPT=yes
+GENERATE_PIE_SCRIPT=yes
+NO_SMALL_DATA=yes
+SEPARATE_GOTPLT="SIZEOF (.got.plt) >= 12 ? 12 : 0"
+IREL_IN_PLT=
+# These sections are placed right after .plt section.
+OTHER_PLT_SECTIONS="
+.plt.got      ${RELOCATING-0} : { *(.plt.got) }
+.plt.sec      ${RELOCATING-0} : { *(.plt.sec) }
+"
diff -urN --no-dereference binutils-clean/opcodes/Makefile.am binutils-workdir/opcodes/Makefile.am
--- binutils-clean/opcodes/Makefile.am
+++ binutils-workdir/opcodes/Makefile.am
@@ -254,6 +254,8 @@
 	visium-dis.c \
 	visium-opc.c \
 	wasm32-dis.c \
+	xr17032-dis.c \
+	xr17032-opc.c \
 	xstormy16-asm.c \
 	xstormy16-desc.c \
 	xstormy16-dis.c \
diff -urN --no-dereference binutils-clean/opcodes/configure.ac binutils-workdir/opcodes/configure.ac
--- binutils-clean/opcodes/configure.ac
+++ binutils-workdir/opcodes/configure.ac
@@ -343,6 +343,7 @@
 	bfd_visium_arch)	ta="$ta visium-dis.lo visium-opc.lo" ;;
         bfd_wasm32_arch)        ta="$ta wasm32-dis.lo" ;;
 	bfd_xgate_arch)		ta="$ta xgate-dis.lo xgate-opc.lo" ;;
+	bfd_xr17032_arch)	ta="$ta xr17032-dis.lo xr17032-opc.lo" ;;
 	bfd_xstormy16_arch)	ta="$ta xstormy16-asm.lo xstormy16-desc.lo xstormy16-dis.lo xstormy16-ibld.lo xstormy16-opc.lo" using_cgen=yes ;;
 	bfd_xtensa_arch)	ta="$ta xtensa-dis.lo" ;;
 	bfd_z80_arch)		ta="$ta z80-dis.lo" ;;
diff -urN --no-dereference binutils-clean/opcodes/disassemble.c binutils-workdir/opcodes/disassemble.c
--- binutils-clean/opcodes/disassemble.c
+++ binutils-workdir/opcodes/disassemble.c
@@ -97,6 +97,7 @@
 #define ARCH_vax
 #define ARCH_visium
 #define ARCH_wasm32
+#define ARCH_xr17032
 #define ARCH_xstormy16
 #define ARCH_xgate
 #define ARCH_xtensa
@@ -532,6 +533,11 @@
       disassemble = print_insn_loongarch;
       break;
 #endif
+#ifdef ARCH_xr17032
+    case bfd_arch_xr17032:
+      disassemble = print_insn_xr17032;
+      break;
+#endif
     default:
       return 0;
     }
diff -urN --no-dereference binutils-clean/opcodes/disassemble.h binutils-workdir/opcodes/disassemble.h
--- binutils-clean/opcodes/disassemble.h
+++ binutils-workdir/opcodes/disassemble.h
@@ -93,6 +93,7 @@
 extern int print_insn_visium		(bfd_vma, disassemble_info *);
 extern int print_insn_wasm32		(bfd_vma, disassemble_info *);
 extern int print_insn_xgate             (bfd_vma, disassemble_info *);
+extern int print_insn_xr17032		(bfd_vma, disassemble_info *);
 extern int print_insn_xstormy16		(bfd_vma, disassemble_info *);
 extern int print_insn_xtensa		(bfd_vma, disassemble_info *);
 extern int print_insn_z80		(bfd_vma, disassemble_info *);
diff -urN --no-dereference binutils-clean/opcodes/xr17032-dis.c binutils-workdir/opcodes/xr17032-dis.c
--- binutils-clean/opcodes/xr17032-dis.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/opcodes/xr17032-dis.c
@@ -0,0 +1,362 @@
+/* Disassembler code for XR/17032.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Contributed by monkuous
+
+   This file is part of GAS, GDB and the GNU binutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "disassemble.h"
+#include "opcode/xr17032.h"
+#include "libiberty.h"
+
+/* Prints the instruction by calling print_arguments after proper matching.  */
+
+static bool
+xr17032_get_insn_data (unsigned int *out, bfd_vma memaddr, struct disassemble_info *info)
+{
+  bfd_byte buffer[4];
+
+  int status = info->read_memory_func (memaddr, buffer, 4, info);
+  if (status)
+    return false;
+
+  *out = bfd_getl32 (buffer);
+  return true;
+}
+
+static const inst *
+xr17032_find_opcode (unsigned int bits)
+{
+  for (unsigned int i = 0; i < xr17032_num_opcodes; i++)
+    {
+      const inst *candidate = &xr17032_instruction[i];
+
+      if ((bits & candidate->match_mask) == candidate->opcode_bits)
+	return candidate;
+    }
+
+  return NULL;
+}
+
+static void
+xr17032_print_signed (struct disassemble_info *info, unsigned int data,
+		      int bits, char prefix)
+{
+  unsigned int sign_bit = 1u << (bits - 1);
+
+  if (data & sign_bit)
+    info->fprintf_func (info->stream, "%c-0x%x", prefix,
+			sign_bit - (data & ~sign_bit));
+  else
+    info->fprintf_func (info->stream, "%c0x%x", prefix, data);
+}
+
+static const char *
+xr17032_register_name (reg regr)
+{
+  static const char *const names[32] =
+  {
+    [zero] = "zero",
+    [t0] = "t0",
+    [t1] = "t1",
+    [t2] = "t2",
+    [t3] = "t3",
+    [t4] = "t4",
+    [t5] = "t5",
+    [a0] = "a0",
+    [a1] = "a1",
+    [a2] = "a2",
+    [a3] = "a3",
+    [s0] = "s0",
+    [s1] = "s1",
+    [s2] = "s2",
+    [s3] = "s3",
+    [s4] = "s4",
+    [s5] = "s5",
+    [s6] = "s6",
+    [s7] = "s7",
+    [s8] = "s8",
+    [s9] = "s9",
+    [s10] = "s10",
+    [s11] = "s11",
+    [s12] = "s12",
+    [s13] = "s13",
+    [s14] = "s14",
+    [s15] = "s15",
+    [s16] = "s16",
+    [s17] = "s17",
+    [tp] = "tp",
+    [sp] = "sp",
+    [lr] = "lr",
+  };
+
+  return names[regr];
+}
+
+static const char *
+xr17032_reg_op_name (reg_op op)
+{
+  static const char *const names[4] =
+  {
+    [reg_lsh] = "LSH",
+    [reg_rsh] = "RSH",
+    [reg_ash] = "ASH",
+    [reg_ror] = "ROR",
+  };
+
+  return names[op];
+}
+
+static const char *
+xr17032_control_reg_name (creg cregr)
+{
+  static const char *const names[32] =
+  {
+    [rs] = "rs",
+    [whami] = "whami",
+    [eb] = "eb",
+    [epc] = "epc",
+    [ebadaddr] = "ebadaddr",
+    [tbmissaddr] = "tbmissaddr",
+    [tbpc] = "tbpc",
+    [scratch0] = "scratch0",
+    [scratch1] = "scratch1",
+    [scratch2] = "scratch2",
+    [scratch3] = "scratch3",
+    [scratch4] = "scratch4",
+    [itbpte] = "itbpte",
+    [itbtag] = "itbtag",
+    [itbindex] = "itbindex",
+    [itbctrl] = "itbctrl",
+    [icachectrl] = "icachectrl",
+    [itbaddr] = "itbaddr",
+    [dtbpte] = "dtbpte",
+    [dtbtag] = "dtbtag",
+    [dtbindex] = "dtbindex",
+    [dtbctrl] = "dtbctrl",
+    [dcachectrl] = "dcachectrl",
+    [dtbaddr] = "dtbaddr",
+  };
+
+  const char *name = names[cregr];
+
+  if (!name)
+    name = "(unknown control register)";
+
+  return name;
+}
+
+static const char *const xr17032_mem_size_names[] =
+{
+  "byte",
+  "int",
+  "long",
+};
+
+static void
+xr17032_print_memimm (struct disassemble_info *info, unsigned int bits,
+		      int shift, char prefix, int index)
+{
+  reg regr = (bits >> (6 + index * 5)) & 0x1f;
+  unsigned int offset = ((bits >> 16) & 0xffff) << shift;
+
+  const char *size_name = xr17032_mem_size_names[shift];
+  const char *reg_name = xr17032_register_name (regr);
+
+  info->fprintf_func (info->stream, "%c%s [%s + 0x%x]", prefix, size_name,
+		      reg_name, offset);
+}
+
+static void
+xr17032_print_memreg (struct disassemble_info *info, unsigned int bits,
+		      int shift, char prefix)
+{
+  reg base_reg = (bits >> 11) & 0x1f;
+  reg offs_reg = (bits >> 16) & 0x1f;
+  reg_op op = (bits >> 26) & 3;
+  unsigned int op_val = (bits >> 21) & 0x1f;
+
+  const char *size_name = xr17032_mem_size_names[shift];
+  const char *base_name = xr17032_register_name (base_reg);
+  const char *offs_name = xr17032_register_name (offs_reg);
+  const char *op_name = xr17032_reg_op_name (op);
+
+  info->fprintf_func (info->stream, "%c%s [%s + %s %s %u]", prefix, size_name,
+		      base_name, offs_name, op_name, op_val);
+}
+
+static void
+xr17032_print_operand (struct disassemble_info *info, operand_type type,
+		       unsigned int bits, bfd_vma addr, char prefix, int index)
+{
+  switch (type)
+    {
+    case dummy:
+      break;
+    case imm29:
+    {
+      bfd_vma value = (addr & 0x80000000) | ((bits >> 1) & 0x7ffffffc);
+      info->fprintf_func (info->stream, "%c", prefix);
+      info->print_address_func (value, info);
+      break;
+    }
+    case imm16:
+    {
+      unsigned int value = (bits >> 16) & 0xffff;
+      info->fprintf_func (info->stream, "%c0x%x", prefix, value);
+      break;
+    }
+    case imm16_16:
+    {
+      unsigned int value = bits & 0xffff0000;
+      info->fprintf_func (info->stream, "%c0x%x", prefix, value);
+      break;
+    }
+    case imm16_2:
+    {
+      unsigned int value = bits & 0x0003fffc;
+      info->fprintf_func (info->stream, "%c0x%x", prefix, value);
+      break;
+    }
+    case simm16:
+      xr17032_print_signed (info, (bits >> 16) & 0xffff, 16, prefix);
+      break;
+    case simm5:
+      xr17032_print_signed (info, (bits >> 11) & 0x1f, 5, prefix);
+      break;
+    case disp21:
+    {
+      bfd_vma value = (bits >> 9) & 0x7ffffc;
+
+      if (value & 0x400000)
+	value = addr - (0x400000 - (value & 0x3fffff));
+      else
+	value += addr;
+
+      info->fprintf_func (info->stream, "%c", prefix);
+      info->print_address_func (value, info);
+      break;
+    }
+    case disp16_16:
+    {
+      bfd_vma value = bits & 0xffff0000;
+
+      if (value & 0x80000000)
+	value = addr - (0x80000000 - (value & 0x7fffffff));
+      else
+	value += addr;
+
+      info->fprintf_func (info->stream, "%c", prefix);
+      info->print_address_func (value, info);
+      break;
+    }
+    case regA:
+    {
+      reg regr = (bits >> 6) & 0x1f;
+      const char *name = xr17032_register_name (regr);
+      info->fprintf_func (info->stream, "%c%s", prefix, name);
+      break;
+    }
+    case regB:
+    {
+      reg regr = (bits >> 11) & 0x1f;
+      const char *name = xr17032_register_name (regr);
+      info->fprintf_func (info->stream, "%c%s", prefix, name);
+      break;
+    }
+    case regC:
+    {
+      reg regr = (bits >> 16) & 0x1f;
+      const char *name = xr17032_register_name (regr);
+      info->fprintf_func (info->stream, "%c%s", prefix, name);
+      break;
+    }
+    case regC_shift:
+    {
+      reg regr = (bits >> 16) & 0x1f;
+      reg_op op = (bits >> 26) & 3;
+      unsigned int val = (bits >> 21) & 0x1f;
+      const char *reg_name = xr17032_register_name (regr);
+      const char *op_name = xr17032_reg_op_name (op);
+      info->fprintf_func (info->stream, "%c%s %s %u", prefix, reg_name,
+			  op_name, val);
+      break;
+    }
+    case cregC:
+    {
+      creg cregr = (bits >> 16) & 0x1f;
+      const char *name = xr17032_control_reg_name (cregr);
+      info->fprintf_func (info->stream, "%c%s", prefix, name);
+      break;
+    }
+    case memimm8:
+      xr17032_print_memimm (info, bits, 0, prefix, index);
+      break;
+    case memimm16:
+      xr17032_print_memimm (info, bits, 1, prefix, index);
+      break;
+    case memimm32:
+      xr17032_print_memimm (info, bits, 2, prefix, index);
+      break;
+    case memreg8:
+      xr17032_print_memreg (info, bits, 0, prefix);
+      break;
+    case memreg16:
+      xr17032_print_memreg (info, bits, 1, prefix);
+      break;
+    case memreg32:
+      xr17032_print_memreg (info, bits, 2, prefix);
+      break;
+    }
+}
+
+static void
+xr17032_print_operands(struct disassemble_info *info, const inst *opcode,
+		       unsigned int bits, bfd_vma addr)
+{
+  for (int i = 0; i < XR17032_MAX_OPERANDS; i++)
+    {
+      operand_type type = opcode->operands[i];
+
+      if (type == dummy)
+	break;
+
+      xr17032_print_operand (info, type, bits, addr, i == 0 ? '\t' : ',', i);
+    }
+}
+
+int
+print_insn_xr17032 (bfd_vma memaddr, struct disassemble_info *info)
+{
+  unsigned int bits;
+  if (!xr17032_get_insn_data (&bits, memaddr, info))
+    return -1;
+
+  const inst *opcode = xr17032_find_opcode (bits);
+
+  if (!opcode)
+    {
+      info->fprintf_func (info->stream, "(bad)");
+      goto done;
+    }
+
+  info->fprintf_func (info->stream, "%s", opcode->mnemonic);
+  xr17032_print_operands (info, opcode, bits, memaddr);
+
+done:
+  return 4;
+}
diff -urN --no-dereference binutils-clean/opcodes/xr17032-opc.c binutils-workdir/opcodes/xr17032-opc.c
--- binutils-clean/opcodes/xr17032-opc.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/opcodes/xr17032-opc.c
@@ -0,0 +1,234 @@
+/* xr17032-opc.c -- Table of opcodes for the XR/17032 processor.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Contributed by monkuous
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include <stdio.h>
+#include "libiberty.h"
+#include "symcat.h"
+#include "opcode/xr17032.h"
+
+#define OPC03 0x00000007
+#define OPC06 0x0000003f
+#define OPC10 0xf000003f
+
+#define OPC_LUI		0x00000004
+#define OPC_BPO		0x00000005
+#define OPC_J		0x00000006
+#define OPC_JAL		0x00000007
+#define OPC_MOVSLII	0x0000000a
+#define OPC_ORI		0x0000000c
+#define OPC_BPE		0x0000000d
+#define OPC_MOVSIII	0x00000012
+#define OPC_XORI	0x00000014
+#define OPC_BGE		0x00000015
+#define OPC_MOVSBII	0x0000001a
+#define OPC_ANDI	0x0000001c
+#define OPC_BLE		0x0000001d
+#define OPC_SLTIS	0x00000024
+#define OPC_BGT		0x00000025
+#define OPC_MOVSLIR	0x0000002a
+#define OPC_MOVLLI	0x0000002b
+#define OPC_SLTI	0x0000002c
+#define OPC_BLT		0x0000002d
+#define OPC_ADR		0x00000030
+#define OPC_SYS		0x00000031
+#define OPC_MOVSIIR	0x00000032
+#define OPC_MOVLII	0x00000033
+#define OPC_SUBI	0x00000034
+#define OPC_BNE		0x00000035
+#define OPC_JALR	0x00000038
+#define OPC_NOR		0x00000039
+#define OPC_MOVSBIR	0x0000003a
+#define OPC_MOVLBI	0x0000003b
+#define OPC_ADDI	0x0000003c
+#define OPC_BEQ		0x0000003d
+#define OPC_BRK		0x10000031
+#define OPC_OR		0x10000039
+#define OPC_WMB		0x20000031
+#define OPC_XOR		0x20000039
+#define OPC_MB		0x30000031
+#define OPC_AND		0x30000039
+#define OPC_SLTS	0x40000039
+#define OPC_SLT		0x50000039
+#define OPC_PAUSE	0x60000031
+#define OPC_SUB		0x60000039
+#define OPC_ADD		0x70000039
+#define OPC_SC		0x80000031
+#define OPC_LSH		0x80000039
+#define OPC_RSH		0x84000039
+#define OPC_ASH		0x88000039
+#define OPC_ROR		0x8c000039
+#define OPC_LL		0x90000031
+#define OPC_MOVSLR	0x90000039
+#define OPC_MOVSIR	0xa0000039
+#define OPC_RFE		0xb0000029
+#define OPC_MOD		0xb0000031
+#define OPC_MOVSBR	0xb0000039
+#define OPC_HLT		0xc0000029
+#define OPC_DIVS	0xc0000031
+#define OPC_DIV		0xd0000031
+#define OPC_MOVLLR	0xd0000039
+#define OPC_MTCR	0xe0000029
+#define OPC_MOVLIR	0xe0000039
+#define OPC_MFCR	0xf0000029
+#define OPC_MUL		0xf0000031
+#define OPC_MOVLBR	0xf0000039
+
+const inst xr17032_instruction[] =
+{
+  {"j",		0,			OPC03, OPC_J,	  {imm29}},
+  {"jal",	0,			OPC03, OPC_JAL,	  {imm29}},
+  {"beq",	0,			OPC06, OPC_BEQ,	  {regA, disp21}},
+  {"bne",	0,			OPC06, OPC_BNE,	  {regA, disp21}},
+  {"blt",	0,			OPC06, OPC_BLT,	  {regA, disp21}},
+  {"bgt",	0,			OPC06, OPC_BGT,	  {regA, disp21}},
+  {"bge",	0,			OPC06, OPC_BGE,	  {regA, disp21}},
+  {"ble",	0,			OPC06, OPC_BLE,	  {regA, disp21}},
+  {"bpe",	0,			OPC06, OPC_BPE,	  {regA, disp21}},
+  {"bpo",	0,			OPC06, OPC_BPO,	  {regA, disp21}},
+  {"addi",	0,			OPC06, OPC_ADDI,  {regA, regB, imm16}},
+  {"subi",	0,			OPC06, OPC_SUBI,  {regA, regB, imm16}},
+  {"slti", 	XR17032_SIGNED_VARIANT,	OPC06, OPC_SLTI,  {regA, regB, imm16}},
+  {"slti signed", 0,			OPC06, OPC_SLTIS, {regA, regB, simm16}},
+  {"andi", 	0,			OPC06, OPC_ANDI,  {regA, regB, imm16}},
+  {"xori", 	0,			OPC06, OPC_XORI,  {regA, regB, imm16}},
+  {"ori", 	0,			OPC06, OPC_ORI,	  {regA, regB, imm16}},
+  {"adr",	0,			OPC06, OPC_ADR,	  {regA, disp16_16}},
+  {"lui", 	0,			OPC06, OPC_LUI,	  {regA, regB,
+							   imm16_16}},
+  {"jalr", 	0,			OPC06, OPC_JALR,  {regA, regB,
+							   imm16_2}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC06, OPC_MOVLBI,  {regA, memimm8}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC06, OPC_MOVLII,  {regA, memimm16}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC06, OPC_MOVLLI,  {regA, memimm32}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC06, OPC_MOVSBIR, {memimm8, regB}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC06, OPC_MOVSIIR, {memimm16, regB}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC06, OPC_MOVSLIR, {memimm32, regB}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC06, OPC_MOVSBII, {memimm8, simm5}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC06, OPC_MOVSIII, {memimm16, simm5}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC06, OPC_MOVSLII, {memimm32, simm5}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC10, OPC_MOVLBR,  {regA, memreg8}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC10, OPC_MOVLIR,  {regA, memreg16}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC10, OPC_MOVLLR,  {regA, memreg32}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC10, OPC_MOVSBR,  {memreg8, regA}},
+  {"mov", 	XR17032_MULTI_OPCODES,	OPC10, OPC_MOVSIR,  {memreg16, regA}},
+  {"mov", 	0,			OPC10, OPC_MOVSLR,  {memreg32, regA}},
+  {"lsh", 	0,			OPC10, OPC_LSH,	  {regA, regB, regC}},
+  {"rsh", 	0,			OPC10, OPC_RSH,	  {regA, regB, regC}},
+  {"ash", 	0,			OPC10, OPC_ASH,	  {regA, regB, regC}},
+  {"ror", 	0,			OPC10, OPC_ROR,	  {regA, regB, regC}},
+  {"add", 	0,			OPC10, OPC_ADD,	  {regA, regB,
+							  regC_shift}},
+  {"sub", 	0,			OPC10, OPC_SUB,	  {regA, regB,
+							  regC_shift}},
+  {"slt", 	XR17032_SIGNED_VARIANT,	OPC10, OPC_SLT,	  {regA, regB,
+							  regC_shift}},
+  {"slt signed", 0,			OPC10, OPC_SLTS,  {regA, regB,
+							  regC_shift}},
+  {"and", 	0,			OPC10, OPC_AND,	  {regA, regB,
+							  regC_shift}},
+  {"xor", 	0,			OPC10, OPC_XOR,	  {regA, regB,
+							  regC_shift}},
+  {"or", 	0,			OPC10, OPC_OR,	  {regA, regB,
+							  regC_shift}},
+  {"nor", 	0,			OPC10, OPC_NOR,	  {regA, regB,
+							  regC_shift}},
+  {"mul", 	0,			OPC10, OPC_MUL,	  {regA, regB, regC}},
+  {"div", 	XR17032_SIGNED_VARIANT,	OPC10, OPC_DIV,	  {regA, regB, regC}},
+  {"div signed", 0,			OPC10, OPC_DIVS,  {regA, regB, regC}},
+  {"mod", 	0,			OPC10, OPC_MOD,	  {regA, regB, regC}},
+  {"ll", 	0,			OPC10, OPC_LL,	  {regA, regB}},
+  {"sc", 	0,			OPC10, OPC_SC,	  {regA, regB, regC}},
+  {"mb", 	0,			OPC10, OPC_MB,	  {}},
+  {"wmb", 	0,			OPC10, OPC_WMB,	  {}},
+  {"brk", 	0,			OPC10, OPC_BRK,	  {}},
+  {"sys", 	0,			OPC10, OPC_SYS,	  {}},
+  {"mfcr", 	0,			OPC10, OPC_MFCR,  {regA, cregC}},
+  {"mtcr", 	0,			OPC10, OPC_MTCR,  {cregC, regA}},
+  {"hlt", 	0,			OPC10, OPC_HLT,	  {}},
+  {"rfe", 	0,			OPC10, OPC_RFE,	  {}},
+};
+
+const unsigned int xr17032_num_opcodes = ARRAY_SIZE (xr17032_instruction);
+
+const reg_entry xr17032_register[] = {
+  {"zero", {zero}},
+  {"t0", {t0}},
+  {"t1", {t1}},
+  {"t2", {t2}},
+  {"t3", {t3}},
+  {"t4", {t4}},
+  {"t5", {t5}},
+  {"a0", {a0}},
+  {"a1", {a1}},
+  {"a2", {a2}},
+  {"a3", {a3}},
+  {"s0", {s0}},
+  {"s1", {s1}},
+  {"s2", {s2}},
+  {"s3", {s3}},
+  {"s4", {s4}},
+  {"s5", {s5}},
+  {"s6", {s6}},
+  {"s7", {s7}},
+  {"s8", {s8}},
+  {"s9", {s9}},
+  {"s10", {s10}},
+  {"s11", {s11}},
+  {"s12", {s12}},
+  {"s13", {s13}},
+  {"s14", {s14}},
+  {"s15", {s15}},
+  {"s16", {s16}},
+  {"s17", {s17}},
+  {"tp", {tp}},
+  {"sp", {sp}},
+  {"lr", {lr}},
+};
+
+const unsigned int xr17032_num_registers = ARRAY_SIZE(xr17032_register);
+
+const reg_entry xr17032_cregister[] = {
+  {"rs", {.creg_val = rs}},
+  {"whami", {.creg_val = whami}},
+  {"eb", {.creg_val = eb}},
+  {"epc", {.creg_val = epc}},
+  {"ebadaddr", {.creg_val = ebadaddr}},
+  {"tbmissaddr", {.creg_val = tbmissaddr}},
+  {"tbpc", {.creg_val = tbpc}},
+  {"scratch0", {.creg_val = scratch0}},
+  {"scratch1", {.creg_val = scratch1}},
+  {"scratch2", {.creg_val = scratch2}},
+  {"scratch3", {.creg_val = scratch3}},
+  {"scratch4", {.creg_val = scratch4}},
+  {"itbpte", {.creg_val = itbpte}},
+  {"itbtag", {.creg_val = itbtag}},
+  {"itbindex", {.creg_val = itbindex}},
+  {"itbctrl", {.creg_val = itbctrl}},
+  {"icachectrl", {.creg_val = icachectrl}},
+  {"itbaddr", {.creg_val = itbaddr}},
+  {"dtbpte", {.creg_val = dtbpte}},
+  {"dtbtag", {.creg_val = dtbtag}},
+  {"dtbindex", {.creg_val = dtbindex}},
+  {"dtbctrl", {.creg_val = dtbctrl}},
+  {"dcachectrl", {.creg_val = dcachectrl}},
+  {"dtbaddr", {.creg_val = dtbaddr}},
+};
+
+const unsigned int xr17032_num_cregisters = ARRAY_SIZE(xr17032_cregister);
