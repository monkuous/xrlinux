diff -urN --no-dereference binutils-clean/bfd/Makefile.am binutils-workdir/bfd/Makefile.am
--- binutils-clean/bfd/Makefile.am
+++ binutils-workdir/bfd/Makefile.am
@@ -172,6 +172,7 @@
 	cpu-visium.lo \
 	cpu-wasm32.lo \
 	cpu-xgate.lo \
+	cpu-xr17032.lo \
 	cpu-xstormy16.lo \
 	cpu-xtensa.lo \
 	cpu-z80.lo \
@@ -255,6 +256,7 @@
 	cpu-visium.c \
 	cpu-wasm32.c \
 	cpu-xgate.c \
+	cpu-xr17032.c \
 	cpu-xstormy16.c \
 	cpu-xtensa.c \
 	cpu-z80.c \
@@ -350,6 +352,7 @@
 	elf32-visium.lo \
 	elf32-wasm32.lo \
 	elf32-xgate.lo \
+	elf32-xr17032.lo \
 	elf32-xstormy16.lo \
 	elf32-xtensa.lo \
 	elf32-z80.lo \
@@ -484,6 +487,7 @@
 	elf32-visium.c \
 	elf32-wasm32.c \
 	elf32-xgate.c \
+	elf32-xr17032.c \
 	elf32-xstormy16.c \
 	elf32-xtensa.c \
 	elf32-z80.c \
diff -urN --no-dereference binutils-clean/bfd/archures.c binutils-workdir/bfd/archures.c
--- binutils-clean/bfd/archures.c
+++ binutils-workdir/bfd/archures.c
@@ -574,6 +574,8 @@
 .#define bfd_mach_amdgcn_gfx1100 0x041
 .#define bfd_mach_amdgcn_gfx1101 0x046
 .#define bfd_mach_amdgcn_gfx1102 0x047
+.  bfd_arch_xr17032,   {* XR/17032 *}
+.#define bfd_mach_xr17032       1
 .  bfd_arch_last
 .  };
 */
@@ -704,6 +706,7 @@
 extern const bfd_arch_info_type bfd_vax_arch;
 extern const bfd_arch_info_type bfd_visium_arch;
 extern const bfd_arch_info_type bfd_wasm32_arch;
+extern const bfd_arch_info_type bfd_xr17032_arch;
 extern const bfd_arch_info_type bfd_xstormy16_arch;
 extern const bfd_arch_info_type bfd_xtensa_arch;
 extern const bfd_arch_info_type bfd_xgate_arch;
@@ -790,6 +793,7 @@
     &bfd_vax_arch,
     &bfd_visium_arch,
     &bfd_wasm32_arch,
+    &bfd_xr17032_arch,
     &bfd_xstormy16_arch,
     &bfd_xtensa_arch,
     &bfd_xgate_arch,
diff -urN --no-dereference binutils-clean/bfd/bfd-in2.h binutils-workdir/bfd/bfd-in2.h
--- binutils-clean/bfd/bfd-in2.h
+++ binutils-workdir/bfd/bfd-in2.h
@@ -1842,6 +1842,8 @@
 #define bfd_mach_amdgcn_gfx1100 0x041
 #define bfd_mach_amdgcn_gfx1101 0x046
 #define bfd_mach_amdgcn_gfx1102 0x047
+  bfd_arch_xr17032,   /* XR/17032 */
+#define bfd_mach_xr17032       1
   bfd_arch_last
   };
 
@@ -6208,6 +6210,35 @@
   BFD_RELOC_IQ2000_OFFSET_21,
   BFD_RELOC_IQ2000_UHI16,
 
+  /* XR/17032 Relocations.  */
+  BFD_RELOC_XR17032_TLS_TPREL,
+  BFD_RELOC_XR17032_TLS_DTPMOD,
+  BFD_RELOC_XR17032_TLS_DTPREL,
+  BFD_RELOC_XR17032_JUMP,
+  BFD_RELOC_XR17032_BRANCH,
+  BFD_RELOC_XR17032_IMM16,
+  BFD_RELOC_XR17032_IMM16_1,
+  BFD_RELOC_XR17032_IMM16_2,
+  BFD_RELOC_XR17032_IMM16_16,
+  BFD_RELOC_XR17032_IMM16_SIGNED,
+  BFD_RELOC_XR17032_LO16,
+  BFD_RELOC_XR17032_LO16_1,
+  BFD_RELOC_XR17032_LO16_2,
+  BFD_RELOC_XR17032_HI16,
+  BFD_RELOC_XR17032_LO16_PCREL,
+  BFD_RELOC_XR17032_LO16_1_PCREL,
+  BFD_RELOC_XR17032_LO16_2_PCREL,
+  BFD_RELOC_XR17032_HI16_PCREL,
+  BFD_RELOC_XR17032_HI16_GOT,
+  BFD_RELOC_XR17032_HI16_PLT,
+  BFD_RELOC_XR17032_HI16_TLS_GOT,
+  BFD_RELOC_XR17032_HI16_TLS_GD,
+  BFD_RELOC_XR17032_LO16_TPREL,
+  BFD_RELOC_XR17032_LO16_1_TPREL,
+  BFD_RELOC_XR17032_LO16_2_TPREL,
+  BFD_RELOC_XR17032_HI16_TPREL,
+  BFD_RELOC_XR17032_CFA,
+
   /* Special Xtensa relocation used only by PLT entries in ELF shared
      objects to indicate that the runtime linker should set the value
      to one of its own internal functions or data structures.  */
diff -urN --no-dereference binutils-clean/bfd/config.bfd binutils-workdir/bfd/config.bfd
--- binutils-clean/bfd/config.bfd
+++ binutils-workdir/bfd/config.bfd
@@ -222,6 +222,7 @@
 v850*)		 targ_archs="bfd_v850_arch bfd_v850_rh850_arch" ;;
 visium*)	 targ_archs=bfd_visium_arch ;;
 x86_64*)	 targ_archs=bfd_i386_arch ;;
+xr17032*)	 targ_archs=bfd_xr17032_arch ;;
 xtensa*)	 targ_archs=bfd_xtensa_arch ;;
 z80*|r800|z180|gbz80|ez80*)	 targ_archs=bfd_z80_arch ;;
 z8k*)		 targ_archs=bfd_z8k_arch ;;
@@ -1449,6 +1450,14 @@
     targ_selvecs="xgate_elf32_vec"
     ;;
 
+  xr17032-*-linux-*)
+    targ_defvec=xr17032_elf32_vec
+    ;;
+
+  xr17032-*-elf)
+    targ_defvec=xr17032_elf32_vec
+    ;;
+
   xstormy16-*-elf)
     targ_defvec=xstormy16_elf32_vec
     ;;
diff -urN --no-dereference binutils-clean/bfd/configure.ac binutils-workdir/bfd/configure.ac
--- binutils-clean/bfd/configure.ac
+++ binutils-workdir/bfd/configure.ac
@@ -668,6 +668,7 @@
     x86_64_pe_big_vec)		 tb="$tb pe-x86_64.lo pex64igen.lo $coff"; target_size=64 ;;
     x86_64_pei_vec)		 tb="$tb pei-x86_64.lo pex64igen.lo $coff"; target_size=64 ;;
     xgate_elf32_vec)		 tb="$tb elf32-xgate.lo elf32.lo $elf" ;;
+    xr17032_elf32_vec)		 tb="$tb elf32-xr17032.lo elf32.lo elf-ifunc.lo $elf" ;;
     xstormy16_elf32_vec)	 tb="$tb elf32-xstormy16.lo elf32.lo $elf" ;;
     xtensa_elf32_be_vec)	 tb="$tb xtensa-dynconfig.lo xtensa-isa.lo xtensa-modules.lo elf32-xtensa.lo elf32.lo $elf" ;;
     xtensa_elf32_le_vec)	 tb="$tb xtensa-dynconfig.lo xtensa-isa.lo xtensa-modules.lo elf32-xtensa.lo elf32.lo $elf" ;;
diff -urN --no-dereference binutils-clean/bfd/cpu-xr17032.c binutils-workdir/bfd/cpu-xr17032.c
--- binutils-clean/bfd/cpu-xr17032.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/bfd/cpu-xr17032.c
@@ -0,0 +1,71 @@
+/* BFD support for the XR/17032 processor.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Written by monkuous
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+/* Fill the buffer with zero or nop instruction if CODE is true.  */
+
+static void *
+bfd_arch_xr17032_fill (bfd_size_type count,
+		       bool is_bigendian ATTRIBUTE_UNUSED,
+		       bool code)
+{
+  static const char nop [] = { 0x3c, 0x00, 0x00, 0x00 };
+
+  void *fill = bfd_malloc (count);
+  if (fill == NULL)
+    return fill;
+
+  void *p = fill;
+
+  if (code)
+    {
+      while (count >= sizeof(nop))
+	{
+	  memcpy(p, nop, sizeof(nop));
+	  p += sizeof(nop);
+	  count -= sizeof(nop);
+	}
+    }
+
+  memset(p, 0, count);
+
+  return fill;
+}
+
+const bfd_arch_info_type bfd_xr17032_arch =
+{
+  32,			/* Bits in a word.  */
+  32,			/* Bits in an address.  */
+  8,			/* Bits in a byte.  */
+  bfd_arch_xr17032,	/* Architecture number.  */
+  bfd_mach_xr17032,
+  "xr17032",		/* Arch name.  */
+  "xr17032",		/* Printable name.  */
+  1,			/* Section alignment power.  */
+  true,			/* The one and only.  */
+  bfd_default_compatible,
+  bfd_default_scan,
+  bfd_arch_xr17032_fill,
+  NULL,
+  0 /* Maximum offset of a reloc from the start of an insn.  */
+};
diff -urN --no-dereference binutils-clean/bfd/elf-bfd.h binutils-workdir/bfd/elf-bfd.h
--- binutils-clean/bfd/elf-bfd.h
+++ binutils-workdir/bfd/elf-bfd.h
@@ -576,6 +576,7 @@
   X86_64_ELF_DATA,
   XTENSA_ELF_DATA,
   VAX_ELF_DATA,
+  XR17032_ELF_DATA,
   GENERIC_ELF_DATA
 };
 
diff -urN --no-dereference binutils-clean/bfd/elf32-xr17032.c binutils-workdir/bfd/elf32-xr17032.c
--- binutils-clean/bfd/elf32-xr17032.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/bfd/elf32-xr17032.c
@@ -0,0 +1,4037 @@
+/* BFD back-end for XR/17032 ELF
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Written by monkuous.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "bfdlink.h"
+#include "genlink.h"
+#include "elf-bfd.h"
+#include "elf/xr17032.h"
+#include "opcode/xr17032.h"
+#include "libiberty.h"
+#include "objalloc.h"
+
+/* True if dynamic relocation is needed.  If we are creating a shared library,
+   and this is a reloc against a global symbol, or a non PC relative reloc
+   against a local symbol, then we need to copy the reloc into the shared
+   library.  However, if we are linking with -Bsymbolic, we do not need to
+   copy a reloc against a global symbol which is defined in an object we are
+   including in the link (i.e., DEF_REGULAR is set).
+
+   At this point we have not seen all the input files, so it is possible that
+   DEF_REGULAR is not set now but will be set later (it is never cleared).
+   In case of a weak definition, DEF_REGULAR may be cleared later by a strong
+   definition in a shared library.  We account for that possibility below by
+   storing information in the relocs_copied field of the hash table entry.
+   A similar situation occurs when creating shared libraries and symbol
+   visibility changes render the symbol local.
+
+   If on the other hand, we are creating an executable, we may need to keep
+   relocations for symbols satisfied by a dynamic library if we manage to
+   avoid copy relocs for the symbol.
+
+   Generate dynamic pointer relocation against STT_GNU_IFUNC symbol in the
+   non-code section (R_XR17032_32).  */
+#define XR17032_NEED_DYNAMIC_RELOC(PCREL, INFO, H, SEC) \
+  ((bfd_link_pic (INFO) \
+    && ((SEC)->flags & SEC_ALLOC) != 0 \
+    && (!(PCREL) \
+	|| ((H) != NULL \
+	    && (!(INFO)->symbolic \
+		|| (H)->root.type == bfd_link_hash_defweak \
+		|| !(H)->def_regular)))) \
+   || (!bfd_link_pic (INFO) \
+       && ((SEC)->flags & SEC_ALLOC) != 0 \
+       && (H) != NULL \
+       && ((H)->root.type == bfd_link_hash_defweak \
+	   || !(H)->def_regular)) \
+   || (!bfd_link_pic (INFO) \
+       && (H) != NULL \
+       && (H)->type == STT_GNU_IFUNC \
+       && ((SEC)->flags & SEC_CODE) == 0))
+
+/* True if dynamic relocation should be generated.  */
+#define XR17032_GENERATE_DYNAMIC_RELOC(PCREL, INFO, H, RESOLVED_TO_ZERO) \
+  ((bfd_link_pic (INFO) \
+    && ((H) == NULL \
+	|| (ELF_ST_VISIBILITY ((H)->other) == STV_DEFAULT && !(RESOLVED_TO_ZERO)) \
+	|| (H)->root.type != bfd_link_hash_undefweak) \
+    && (!(PCREL) \
+	|| !SYMBOL_CALLS_LOCAL ((INFO), (H)))) \
+   || (!bfd_link_pic (INFO) \
+       && (H) != NULL \
+       && (H)->dynindx != -1 \
+       && !(H)->non_got_ref \
+       && (((H)->def_dynamic && !(H)->def_regular) \
+	   || (H)->root.type == bfd_link_hash_undefweak \
+	   || (H)->root.type == bfd_link_hash_undefined)))
+
+/* True if this input relocation should be copied to output.  H->dynindx
+   may be -1 if this symbol was marked to become local.  */
+#define XR17032_COPY_INPUT_RELOC(INFO, H) \
+  ((H) != NULL \
+   && (H)->dynindx != -1 \
+   && (!bfd_link_pic (INFO) \
+       || !SYMBOLIC_BIND ((INFO), (H)) \
+       || !(H)->def_regular))
+
+/* True if this is actually a static link, or it is a -Bsymbolic link
+   and the symbol is defined locally, or the symbol was forced to be
+   local because of a version file.  */
+#define XR17032_RESOLVED_LOCALLY(INFO, H) \
+  (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (elf_hash_table (INFO)->dynamic_sections_created, \
+				     bfd_link_pic (INFO), (H)) \
+   || (bfd_link_pic (INFO) \
+       && SYMBOL_REFERENCES_LOCAL ((INFO), (H))))
+
+/* Set NEED_RELOC to true if TLS GD/IE needs dynamic relocations, and INDX will
+   be the dynamic index. */
+#define XR17032_TLS_GD_IE_NEED_DYN_RELOC(INFO, DYN, H, INDX, NEED_RELOC) \
+  do \
+    { \
+      if ((H) != NULL \
+	  && (H)->dynindx != -1 \
+	  && WILL_CALL_FINISH_DYNAMIC_SYMBOL ((DYN), bfd_link_pic (INFO), (H)) \
+	  && (bfd_link_dll (INFO) || !SYMBOL_REFERENCES_LOCAL ((INFO), (H)))) \
+	(INDX) = (H)->dynindx; \
+      if ((bfd_link_dll (INFO) || (INDX) != 0) \
+	  && ((H) == NULL \
+	      || ELF_ST_VISIBILITY ((H)->other) == STV_DEFAULT \
+	      || (H)->root.type != bfd_link_hash_undefweak)) \
+	(NEED_RELOC) = true; \
+    } \
+  while (0)
+
+/* The name of the dynamic interpreter.  This is put in the .interp
+   section.  */
+
+#define ELF32_DYNAMIC_INTERPRETER "/lib/ld.so.1"
+
+/* XR/17032 ELF linker hash entry.  */
+
+struct xr17032_elf_link_hash_entry
+{
+  struct elf_link_hash_entry elf;
+
+#define GOT_UNKNOWN	0
+#define GOT_NORMAL	1
+#define GOT_TLS_GD	2
+#define GOT_TLS_IE	4
+#define GOT_TLS_LE	8
+  char tls_type;
+};
+
+#define xr17032_elf_hash_entry(ent) \
+  ((struct xr17032_elf_link_hash_entry *) (ent))
+
+struct _bfd_xr17032_elf_obj_tdata
+{
+  struct elf_obj_tdata root;
+
+  /* tls_type for each local got entry.  */
+  char *local_got_tls_type;
+};
+
+#define _bfd_xr17032_elf_tdata(abfd) \
+  ((struct _bfd_xr17032_elf_obj_tdata *) (abfd)->tdata.any)
+
+#define _bfd_xr17032_elf_local_got_tls_type(abfd) \
+  (_bfd_xr17032_elf_tdata (abfd)->local_got_tls_type)
+
+#define _bfd_xr17032_elf_tls_type(abfd, h, symndx)		\
+  (*((h) != NULL ? &xr17032_elf_hash_entry (h)->tls_type	\
+     : &_bfd_xr17032_elf_local_got_tls_type (abfd) [symndx]))
+
+#define is_xr17032_elf(bfd)				\
+  (bfd_get_flavour (bfd) == bfd_target_elf_flavour	\
+   && elf_tdata (bfd) != NULL				\
+   && elf_object_id (bfd) == XR17032_ELF_DATA)
+
+struct xr17032_elf_link_hash_table
+{
+  struct elf_link_hash_table elf;
+
+  /* Short-cuts to get to dynamic linker sections.  */
+  asection *sdyntdata;
+
+  /* Used by local STT_GNU_IFUNC symbols.  */
+  htab_t loc_hash_table;
+  void * loc_hash_memory;
+
+  /* The index of the last unused .rel.iplt slot.  */
+  bfd_vma last_iplt_index;
+};
+
+/* Get the XR/17032 ELF linker hash table from a link_info structure.  */
+#define xr17032_elf_hash_table(p) \
+  ((is_elf_hash_table ((p)->hash)					\
+    && elf_hash_table_id (elf_hash_table (p)) == XR17032_ELF_DATA)	\
+   ? (struct xr17032_elf_link_hash_table *) (p)->hash : NULL)
+
+static void
+xr17032_elf_append_rela (bfd *abfd, asection *s, Elf_Internal_Rela *rel)
+{
+  const struct elf_backend_data *bed;
+  bfd_byte *loc;
+
+  bed = get_elf_backend_data (abfd);
+  loc = s->contents + (s->reloc_count++ * bed->s->sizeof_rela);
+  bed->s->swap_reloca_out (abfd, rel, loc);
+}
+
+/* PLT/GOT stuff.  */
+#define PLT_HEADER_INSNS 7
+#define PLT_ENTRY_INSNS 4
+#define PLT_HEADER_SIZE (PLT_HEADER_INSNS * 4)
+#define PLT_ENTRY_SIZE (PLT_ENTRY_INSNS * 4)
+#define GOT_ENTRY_SIZE 4
+#define TLS_GD_GOT_ENTRY_SIZE 8
+#define TLS_IE_GOT_ENTRY_SIZE 4
+#define TLSDESC_GOT_ENTRY_SIZE 8
+/* Reserve two entries of GOTPLT for ld.so, one is used for PLT resolver,
+   the other is used for link map.  Other targets also reserve one more
+   entry used for runtime profile?  */
+#define GOTPLT_HEADER_SIZE 8
+
+#define sec_addr(sec) ((sec)->output_section->vma + (sec)->output_offset)
+
+/* The relocation table used for SHT_RELA sections.  */
+
+static reloc_howto_type howto_table[] =
+{
+  /* No relocation. */
+  HOWTO (R_XR17032_NONE,		/* type */
+	 0,				/* rightshift */
+	 0,				/* size */
+	 0,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_NONE",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0,				/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 32 bit relocation. */
+  HOWTO (R_XR17032_32,			/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_32",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xffffffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Relocation against a local symbol in a shared object. */
+  HOWTO (R_XR17032_RELATIVE,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_RELATIVE",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xffffffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Relocation against a local ifunc symbol in a shared object. */
+  HOWTO (R_XR17032_IRELATIVE,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_IRELATIVE",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xffffffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  HOWTO (R_XR17032_JUMP_SLOT,		/* type */
+	 0,				/* rightshift */
+	 8,				/* size */
+	 64,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_bitfield,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_JUMP_SLOT",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0,				/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  HOWTO (R_XR17032_COPY,		/* type */
+	 0,				/* rightshift */
+	 0,				/* this one is variable size */
+	 0,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_bitfield,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_COPY",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0,				/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  HOWTO (R_XR17032_TLS_TPREL,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_TLS_TPREL",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xffffffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Dynamic TLS relocations. */
+  HOWTO (R_XR17032_TLS_DTPMOD,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_TLS_DTPMOD",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xffffffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  HOWTO (R_XR17032_TLS_DTPREL,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_TLS_DTPREL",	/* name */
+	 true,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xffffffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 8 bit relocation. */
+  HOWTO (R_XR17032_8,			/* type */
+	 0,				/* rightshift */
+	 1,				/* size */
+	 8,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_8",			/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xff,				/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 16 bit relocation. */
+  HOWTO (R_XR17032_16,			/* type */
+	 0,				/* rightshift */
+	 2,				/* size */
+	 16,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_16",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 8-bit PC relative. */
+  HOWTO (R_XR17032_8_PCREL,		/* type */
+	 0,				/* rightshift */
+	 1,				/* size */
+	 8,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_8_PCREL",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xff,				/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 16-bit PC relative. */
+  HOWTO (R_XR17032_16_PCREL,		/* type */
+	 0,				/* rightshift */
+	 2,				/* size */
+	 16,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_16_PCREL",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 32-bit PC relative. */
+  HOWTO (R_XR17032_32_PCREL,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_32_PCREL",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0xffffffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 29-bit jump target. */
+  HOWTO (R_XR17032_JUMP,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_JUMP",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_J(-1U),		/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 21-bit PC-relative branch offset. */
+  HOWTO (R_XR17032_BRANCH,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_signed,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_BRANCH",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_B(-1U),		/* dst_mask */
+	 true),				/* pcrel_offset */
+
+  /* 16-bit instruction operand. */
+  HOWTO (R_XR17032_IMM16,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_IMM16",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I(-1U),		/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 17-bit instruction operand shifted right by one bit. */
+  HOWTO (R_XR17032_IMM16_1,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_IMM16_1",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_1(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 18-bit instruction operand shifted right by two bits. */
+  HOWTO (R_XR17032_IMM16_2,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_IMM16_2",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_2(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 32-bit instruction operand shifted right by sixteen bits. */
+  HOWTO (R_XR17032_IMM16_16,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_IMM16_16",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_16(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* 16-bit signed instruction operand. */
+  HOWTO (R_XR17032_IMM16_SIGNED,	/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_IMM16_SIGNED",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_S(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Low 16 bits of a 32-bit absolute address. */
+  HOWTO (R_XR17032_LO16,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_LO16",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I(-1U),		/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Low 16 bits of a 32-bit absolute address shifted right by one bit. */
+  HOWTO (R_XR17032_LO16_1,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_LO16_1",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_1(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Low 16 bits of a 32-bit absolute address shifted right by two bits. */
+  HOWTO (R_XR17032_LO16_2,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_LO16_2",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_2(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* High 16 bits of a 32-bit absolute address. */
+  HOWTO (R_XR17032_HI16,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_HI16",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_16(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Low 16 bits of a 32-bit PC-relative address. */
+  HOWTO (R_XR17032_LO16_PCREL,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_LO16_PCREL",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I(-1U),		/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Low 16 bits of a 32-bit PC-relative address shifted right by one bit. */
+  HOWTO (R_XR17032_LO16_1_PCREL,	/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_LO16_1_PCREL",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_1(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Low 16 bits of a 32-bit PC-relative address shifted right by two bits. */
+  HOWTO (R_XR17032_LO16_2_PCREL,	/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_LO16_2_PCREL",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_2(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* High 16 bits of a 32-bit PC-relative address. */
+  HOWTO (R_XR17032_HI16_PCREL,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_HI16_PCREL",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_16(-1U),	/* dst_mask */
+	 true),				/* pcrel_offset */
+
+  /* High 16 bits of a 32-bit PC-relative GOT entry address. */
+  HOWTO (R_XR17032_HI16_GOT,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_HI16_GOT",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_16(-1U),	/* dst_mask */
+	 true),				/* pcrel_offset */
+
+  /* High 16 bits of a 32-bit PC-relative PLT entry address. */
+  HOWTO (R_XR17032_HI16_PLT,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_HI16_PLT",		/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_16(-1U),	/* dst_mask */
+	 true),				/* pcrel_offset */
+
+  /* High 16 bits of 32-bit PC-relative TLS IE GOT entry address. */
+  HOWTO (R_XR17032_HI16_TLS_GOT,	/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_HI16_TLS_GOT",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_16(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* High 16 bits of 32-bit PC-relative TLS GD GOT entry address. */
+  HOWTO (R_XR17032_HI16_TLS_GD,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_HI16_TLS_GD",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_16(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Low 16 bits of a 32-bit TP-relative address. */
+  HOWTO (R_XR17032_LO16_TPREL,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_LO16_TPREL",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I(-1U),		/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Low 16 bits of a 32-bit TP-relative address shifted right by one bit. */
+  HOWTO (R_XR17032_LO16_1_TPREL,	/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_LO16_1_TPREL",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_1(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Low 16 bits of a 32-bit TP-relative address shifted right by two bits. */
+  HOWTO (R_XR17032_LO16_2_TPREL,	/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_LO16_2_TPREL",	/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_2(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* High 16 bits of TLS LE thread pointer offset. */
+  HOWTO (R_XR17032_HI16_TPREL,		/* type */
+	 0,				/* rightshift */
+	 4,				/* size */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_signed,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_XR17032_HI16_TPREL",	/* name */
+	 true,				/* partial_inplace */
+	 0,				/* src_mask */
+	 XR_IMM_ENCODE_I_16(-1U),	/* dst_mask */
+	 false),			/* pcrel_offset */
+};
+
+/* A mapping from BFD reloc types to XR/17032 ELF reloc types.  */
+struct elf_reloc_map
+{
+  bfd_reloc_code_real_type bfd_val;
+  enum elf_xr17032_reloc_type elf_val;
+};
+
+static const struct elf_reloc_map xr17032_reloc_map[] =
+{
+  { BFD_RELOC_NONE,			R_XR17032_NONE },
+  { BFD_RELOC_32,			R_XR17032_32 },
+  { BFD_RELOC_XR17032_TLS_TPREL,	R_XR17032_TLS_TPREL },
+  { BFD_RELOC_XR17032_TLS_DTPMOD,	R_XR17032_TLS_DTPMOD },
+  { BFD_RELOC_XR17032_TLS_DTPREL,	R_XR17032_TLS_DTPREL },
+  { BFD_RELOC_8,			R_XR17032_8 },
+  { BFD_RELOC_16,			R_XR17032_16 },
+  { BFD_RELOC_8_PCREL,			R_XR17032_8_PCREL },
+  { BFD_RELOC_16_PCREL,			R_XR17032_16_PCREL },
+  { BFD_RELOC_32_PCREL,			R_XR17032_32_PCREL },
+  { BFD_RELOC_XR17032_JUMP,		R_XR17032_JUMP },
+  { BFD_RELOC_XR17032_BRANCH,		R_XR17032_BRANCH },
+  { BFD_RELOC_XR17032_IMM16,		R_XR17032_IMM16 },
+  { BFD_RELOC_XR17032_IMM16_1,		R_XR17032_IMM16_1 },
+  { BFD_RELOC_XR17032_IMM16_2,		R_XR17032_IMM16_2 },
+  { BFD_RELOC_XR17032_IMM16_16,		R_XR17032_IMM16_16 },
+  { BFD_RELOC_XR17032_IMM16_SIGNED,	R_XR17032_IMM16_SIGNED },
+  { BFD_RELOC_XR17032_LO16,		R_XR17032_LO16 },
+  { BFD_RELOC_XR17032_LO16_1,		R_XR17032_LO16_1 },
+  { BFD_RELOC_XR17032_LO16_2,		R_XR17032_LO16_2 },
+  { BFD_RELOC_XR17032_HI16,		R_XR17032_HI16 },
+  { BFD_RELOC_XR17032_LO16_PCREL,	R_XR17032_LO16_PCREL },
+  { BFD_RELOC_XR17032_LO16_1_PCREL,	R_XR17032_LO16_1_PCREL },
+  { BFD_RELOC_XR17032_LO16_2_PCREL,	R_XR17032_LO16_2_PCREL },
+  { BFD_RELOC_XR17032_HI16_PCREL,	R_XR17032_HI16_PCREL },
+  { BFD_RELOC_XR17032_HI16_GOT,		R_XR17032_HI16_GOT },
+  { BFD_RELOC_XR17032_HI16_GOT,		R_XR17032_HI16_GOT },
+  { BFD_RELOC_XR17032_HI16_TLS_GOT,	R_XR17032_HI16_TLS_GOT },
+  { BFD_RELOC_XR17032_HI16_TLS_GD,	R_XR17032_HI16_TLS_GD },
+  { BFD_RELOC_XR17032_LO16_TPREL,	R_XR17032_LO16_TPREL },
+  { BFD_RELOC_XR17032_LO16_1_TPREL,	R_XR17032_LO16_1_TPREL },
+  { BFD_RELOC_XR17032_LO16_2_TPREL,	R_XR17032_LO16_2_TPREL },
+  { BFD_RELOC_XR17032_HI16_TPREL,	R_XR17032_HI16_TPREL },
+};
+
+/* Given a BFD reloc type, return a howto structure.  */
+
+static reloc_howto_type *
+xr17032_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			   bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (xr17032_reloc_map); i++)
+    if (xr17032_reloc_map[i].bfd_val == code)
+      return &howto_table[(int) xr17032_reloc_map[i].elf_val];
+
+  bfd_set_error (bfd_error_bad_value);
+  return NULL;
+}
+
+static reloc_howto_type *
+xr17032_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED, const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (howto_table); i++)
+    if (howto_table[i].name && strcasecmp (howto_table[i].name, r_name) == 0)
+      return &howto_table[i];
+
+  return NULL;
+}
+
+static reloc_howto_type *
+xr17032_elf_rtype_to_howto (bfd *abfd, unsigned int r_type)
+{
+  if (r_type < ARRAY_SIZE (howto_table))
+    return &howto_table[r_type];
+  else
+    {
+      (*_bfd_error_handler) (_("%pB: unsupported relocation type %#x"),
+			     abfd, r_type);
+      bfd_set_error (bfd_error_bad_value);
+      return NULL;
+    }
+}
+
+/* Create an entry in an XR/17032 ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+link_hash_newfunc (struct bfd_hash_entry *entry,
+		   struct bfd_hash_table *table, const char *string)
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry =
+	bfd_hash_allocate (table,
+			   sizeof (struct xr17032_elf_link_hash_entry));
+      if (entry == NULL)
+	return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
+  if (entry != NULL)
+    {
+      struct xr17032_elf_link_hash_entry *eh;
+
+      eh = (struct xr17032_elf_link_hash_entry *) entry;
+      eh->tls_type = GOT_UNKNOWN;
+    }
+
+  return entry;
+}
+
+/* Compute a hash of a local hash entry.  We use elf_link_hash_entry
+   for local symbol so that we can handle local STT_GNU_IFUNC symbols
+   as global symbol.  We reuse indx and dynstr_index for local symbol
+   hash since they aren't used by global symbols in this backend.  */
+
+static hashval_t
+xr17032_elf_local_htab_hash (const void *ptr)
+{
+  struct elf_link_hash_entry *h = (struct elf_link_hash_entry *) ptr;
+  return ELF_LOCAL_SYMBOL_HASH (h->indx, h->dynstr_index);
+}
+
+/* Compare local hash entries.  */
+
+static int
+xr17032_elf_local_htab_eq (const void *ptr1, const void *ptr2)
+{
+  struct elf_link_hash_entry *h1 = (struct elf_link_hash_entry *) ptr1;
+  struct elf_link_hash_entry *h2 = (struct elf_link_hash_entry *) ptr2;
+
+  return h1->indx == h2->indx && h1->dynstr_index == h2->dynstr_index;
+}
+
+/* Destroy an XR/17032 elf linker hash table.  */
+
+static void
+xr17032_elf_link_hash_table_free (bfd *obfd)
+{
+  struct xr17032_elf_link_hash_table *ret
+    = (struct xr17032_elf_link_hash_table *) obfd->link.hash;
+
+  if (ret->loc_hash_table)
+    htab_delete (ret->loc_hash_table);
+  if (ret->loc_hash_memory)
+    objalloc_free ((struct objalloc *) ret->loc_hash_memory);
+
+  _bfd_elf_link_hash_table_free (obfd);
+}
+
+/* Create an XR/17032 ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+xr17032_elf_link_hash_table_create (bfd *abfd)
+{
+  struct xr17032_elf_link_hash_table *ret;
+  size_t amt = sizeof (struct xr17032_elf_link_hash_table);
+
+  ret = (struct xr17032_elf_link_hash_table *) bfd_zmalloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc,
+				      sizeof (struct xr17032_elf_link_hash_entry)))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  /* Create hash table for local ifunc.  */
+  ret->loc_hash_table = htab_try_create (1024,
+					 xr17032_elf_local_htab_hash,
+					 xr17032_elf_local_htab_eq,
+					 NULL);
+  ret->loc_hash_memory = objalloc_create ();
+  if (!ret->loc_hash_table || !ret->loc_hash_memory)
+    {
+      xr17032_elf_link_hash_table_free (abfd);
+      return NULL;
+    }
+  ret->elf.root.hash_table_free = xr17032_elf_link_hash_table_free;
+
+  return &ret->elf.root;
+}
+
+/* Treat the following cases as target special symbols, they are
+   usually omitted.  */
+
+static bool
+xr17032_elf_is_target_special_symbol (bfd *abfd, asymbol *sym)
+{
+  /* Local and empty symbols, since they are usually generated for pcrel
+     relocations.  */
+  return (!sym->name[0]
+	  || _bfd_elf_is_local_label_name (abfd, sym->name));
+}
+
+/* Used to decide how to sort relocs in an optimal manner for the
+   dynamic linker, before writing them out.  */
+
+static enum elf_reloc_type_class
+xr17032_reloc_type_class (const struct bfd_link_info *info,
+			  const asection *rel_sec ATTRIBUTE_UNUSED,
+			  const Elf_Internal_Rela *rela)
+{
+  struct xr17032_elf_link_hash_table *htab = xr17032_elf_hash_table (info);
+
+  if (htab->elf.dynsym != NULL
+      && htab->elf.dynsym->contents != NULL)
+    {
+      /* Check relocation against STT_GNU_IFUNC symbol if there are
+	 dynamic symbols.  */
+      bfd *abfd = info->output_bfd;
+      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+      unsigned long r_symndx = ELF32_R_SYM (rela->r_info);
+      if (r_symndx != STN_UNDEF)
+	{
+	  Elf_Internal_Sym sym;
+	  if (!bed->s->swap_symbol_in (abfd,
+				       (htab->elf.dynsym->contents
+					+ r_symndx * bed->s->sizeof_sym),
+				       0, &sym))
+	    {
+	      /* xgettext:c-format */
+	      _bfd_error_handler (_("%pB symbol number %lu references"
+				    " nonexistent SHT_SYMTAB_SHNDX section"),
+				  abfd, r_symndx);
+	      /* Ideally an error class should be returned here.  */
+	    }
+	  else if (ELF_ST_TYPE (sym.st_info) == STT_GNU_IFUNC)
+	    return reloc_class_ifunc;
+	}
+    }
+
+  switch (ELF32_R_TYPE (rela->r_info))
+    {
+    case R_XR17032_IRELATIVE:
+      return reloc_class_ifunc;
+    case R_XR17032_RELATIVE:
+      return reloc_class_relative;
+    case R_XR17032_JUMP_SLOT:
+      return reloc_class_plt;
+    case R_XR17032_COPY:
+      return reloc_class_copy;
+    default:
+      return reloc_class_normal;
+    }
+}
+
+static bool
+elf32_xr17032_mkobject (bfd *abfd)
+{
+  return bfd_elf_allocate_object (abfd,
+				  sizeof (struct _bfd_xr17032_elf_obj_tdata));
+}
+
+/* Copy the extra info we tack onto an elf_link_hash_entry.  */
+
+static void
+xr17032_elf_copy_indirect_symbol (struct bfd_link_info *info,
+				  struct elf_link_hash_entry *dir,
+				  struct elf_link_hash_entry *ind)
+{
+  struct xr17032_elf_link_hash_entry *edir, *eind;
+
+  edir = (struct xr17032_elf_link_hash_entry *) dir;
+  eind = (struct xr17032_elf_link_hash_entry *) ind;
+
+  if (ind->root.type == bfd_link_hash_indirect
+      && dir->got.refcount <= 0)
+    {
+      edir->tls_type = eind->tls_type;
+      eind->tls_type = GOT_UNKNOWN;
+    }
+  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+}
+
+/* Create the .got section.  */
+
+static bool
+xr17032_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)
+{
+  flagword flags;
+  asection *s, *s_got;
+  struct elf_link_hash_entry *h;
+  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  struct elf_link_hash_table *htab = elf_hash_table (info);
+
+  /* This function may be called more than once.  */
+  if (htab->sgot != NULL)
+    return true;
+
+  flags = bed->dynamic_sec_flags;
+
+  s = bfd_make_section_anyway_with_flags (abfd,
+					  (bed->rela_plts_and_copies_p
+					   ? ".rela.got" : ".rel.got"),
+					  (bed->dynamic_sec_flags
+					   | SEC_READONLY));
+  if (s == NULL
+      || !bfd_set_section_alignment (s, bed->s->log_file_align))
+    return false;
+  htab->srelgot = s;
+
+  s = s_got = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
+  if (s == NULL
+      || !bfd_set_section_alignment (s, bed->s->log_file_align))
+    return false;
+  htab->sgot = s;
+
+  /* The first bit of the global offset table is the header.  */
+  s->size += bed->got_header_size;
+
+  if (bed->want_got_plt)
+    {
+      s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
+      if (s == NULL
+	  || !bfd_set_section_alignment (s, bed->s->log_file_align))
+	return false;
+      htab->sgotplt = s;
+
+      /* Reserve room for the header.  */
+      s->size += GOTPLT_HEADER_SIZE;
+    }
+
+  if (bed->want_got_sym)
+    {
+      /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
+	 section.  We don't do this in the linker script because we don't want
+	 to define the symbol if we are not creating a global offset
+	 table.  */
+      h = _bfd_elf_define_linkage_sym (abfd, info, s_got,
+				       "_GLOBAL_OFFSET_TABLE_");
+      elf_hash_table (info)->hgot = h;
+      if (h == NULL)
+	return false;
+    }
+
+  return true;
+}
+
+/* Create .plt, .rela.plt, .got, .got.plt, .rela.got, .dynbss, and
+   .rela.bss sections in DYNOBJ, and set up shortcuts to them in our
+   hash table.  */
+
+static bool
+xr17032_elf_create_dynamic_sections (bfd *dynobj,
+				     struct bfd_link_info *info)
+{
+  struct xr17032_elf_link_hash_table *htab;
+
+  htab = xr17032_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+
+  if (!xr17032_elf_create_got_section (dynobj, info))
+    return false;
+
+  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
+    return false;
+
+  if (!bfd_link_pic (info))
+    {
+      /* Technically, this section doesn't have contents.  It is used as the
+	 target of TLS copy relocs, to copy TLS data from shared libraries into
+	 the executable.  However, if we don't mark it as loadable, then it
+	 matches the IS_TBSS test in ldlang.c, and there is no run-time address
+	 space allocated for it even though it has SEC_ALLOC.  That test is
+	 correct for .tbss, but not correct for this section.  There is also
+	 a second problem that having a section with no contents can only work
+	 if it comes after all sections with contents in the same segment,
+	 but the linker script does not guarantee that.  This is just mixed in
+	 with other .tdata.* sections.  We can fix both problems by lying and
+	 saying that there are contents.  This section is expected to be small
+	 so this should not cause a significant extra program startup cost.  */
+      htab->sdyntdata =
+	bfd_make_section_anyway_with_flags (dynobj, ".tdata.dyn",
+					    (SEC_ALLOC | SEC_THREAD_LOCAL
+					     | SEC_LOAD | SEC_DATA
+					     | SEC_HAS_CONTENTS
+					     | SEC_LINKER_CREATED));
+    }
+
+  if (!htab->elf.splt || !htab->elf.srelplt || !htab->elf.sdynbss
+      || (!bfd_link_pic (info) && (!htab->elf.srelbss || !htab->sdyntdata)))
+    abort ();
+
+  return true;
+}
+
+/* Find and/or create a hash entry for local symbol.  */
+
+static struct elf_link_hash_entry *
+xr17032_elf_get_local_sym_hash (struct xr17032_elf_link_hash_table *htab,
+				bfd *abfd, const Elf_Internal_Rela *rel,
+				bool create)
+{
+  struct xr17032_elf_link_hash_entry eh, *ret;
+  asection *sec = abfd->sections;
+  hashval_t h = ELF_LOCAL_SYMBOL_HASH (sec->id,
+				       ELF32_R_SYM (rel->r_info));
+  void **slot;
+
+  eh.elf.indx = sec->id;
+  eh.elf.dynstr_index = ELF32_R_SYM (rel->r_info);
+  slot = htab_find_slot_with_hash (htab->loc_hash_table, &eh, h,
+				   create ? INSERT : NO_INSERT);
+
+  if (!slot)
+    return NULL;
+
+  if (*slot)
+    {
+      ret = (struct xr17032_elf_link_hash_entry *) *slot;
+      return &ret->elf;
+    }
+
+  ret = (struct xr17032_elf_link_hash_entry *)
+	objalloc_alloc ((struct objalloc *) htab->loc_hash_memory,
+			sizeof (struct xr17032_elf_link_hash_entry));
+  if (ret)
+    {
+      memset (ret, 0, sizeof (*ret));
+      ret->elf.indx = sec->id;
+      ret->elf.dynstr_index = ELF32_R_SYM (rel->r_info);
+      ret->elf.dynindx = -1;
+      *slot = ret;
+    }
+  return &ret->elf;
+}
+
+static bool
+xr17032_elf_record_got_reference (bfd *abfd, struct bfd_link_info *info,
+				  struct elf_link_hash_entry *h, long symndx)
+{
+  struct xr17032_elf_link_hash_table *htab = xr17032_elf_hash_table (info);
+  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  if (htab->elf.sgot == NULL)
+    {
+      if (!xr17032_elf_create_got_section (htab->elf.dynobj, info))
+	return false;
+    }
+
+  if (h != NULL)
+    {
+      h->got.refcount += 1;
+      return true;
+    }
+
+  /* This is a global offset table entry for a local symbol.  */
+  if (elf_local_got_refcounts (abfd) == NULL)
+    {
+      bfd_size_type size = symtab_hdr->sh_info * (sizeof (bfd_vma) + 1);
+      if (!(elf_local_got_refcounts (abfd) = bfd_zalloc (abfd, size)))
+	return false;
+      _bfd_xr17032_elf_local_got_tls_type (abfd)
+	= (char *) (elf_local_got_refcounts (abfd) + symtab_hdr->sh_info);
+    }
+  elf_local_got_refcounts (abfd) [symndx] += 1;
+
+  return true;
+}
+
+static bool
+xr17032_elf_record_tls_type (bfd *abfd, struct elf_link_hash_entry *h,
+			     unsigned long symndx, char tls_type)
+{
+  char *new_tls_type = &_bfd_xr17032_elf_tls_type (abfd, h, symndx);
+
+  *new_tls_type |= tls_type;
+  if ((*new_tls_type & GOT_NORMAL) && (*new_tls_type & ~GOT_NORMAL))
+    {
+      (*_bfd_error_handler)
+	(_("%pB: `%s' accessed both as normal and thread local symbol"),
+	 abfd, h ? h->root.root.string : "<local>");
+      return false;
+    }
+  return true;
+}
+
+static bool
+bad_static_reloc (bfd *abfd, unsigned r_type, struct elf_link_hash_entry *h)
+{
+  reloc_howto_type * r = xr17032_elf_rtype_to_howto (abfd, r_type);
+
+  /* We propably can improve the information to tell users that they
+     should be recompile the code with -fPIC or -fPIE, just like what
+     x86 does.  */
+  (*_bfd_error_handler)
+    (_("%pB: relocation %s against `%s' can not be used when making a shared "
+       "object; recompile with -fPIC"),
+     abfd, r ? r->name : _("<unknown>"),
+     h != NULL ? h->root.root.string : "a local symbol");
+  bfd_set_error (bfd_error_bad_value);
+  return false;
+}
+
+/* Look through the relocs for a section during the first phase, and
+   allocate space in the global offset table or procedure linkage
+   table.  */
+
+static bool
+xr17032_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
+			  asection *sec, const Elf_Internal_Rela *relocs)
+{
+  struct xr17032_elf_link_hash_table *htab;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+  asection *sreloc = NULL;
+
+  if (bfd_link_relocatable (info))
+    return true;
+
+  htab = xr17032_elf_hash_table (info);
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+
+  if (htab->elf.dynobj == NULL)
+    htab->elf.dynobj = abfd;
+
+  for (rel = relocs; rel < relocs + sec->reloc_count; rel++)
+    {
+      unsigned int r_type;
+      unsigned int r_symndx;
+      struct elf_link_hash_entry *h;
+      bool is_abs_symbol = false;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      r_type = ELF32_R_TYPE (rel->r_info);
+
+      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
+	{
+	  (*_bfd_error_handler) (_("%pB: bad symbol index: %d"),
+				 abfd, r_symndx);
+	  return false;
+	}
+
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  /* A local symbol.  */
+	  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
+							  abfd, r_symndx);
+	  if (isym == NULL)
+	    return false;
+
+	  is_abs_symbol = isym->st_shndx == SHN_ABS ? true : false;
+
+	  /* Check relocation against local STT_GNU_IFUNC symbol.  */
+	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
+	    {
+	      h = xr17032_elf_get_local_sym_hash (htab, abfd, rel, true);
+	      if (h == NULL)
+		return false;
+
+	      /* Fake STT_GNU_IFUNC global symbol.  */
+	      h->root.root.string = bfd_elf_sym_name (abfd, symtab_hdr,
+						      isym, NULL);
+	      h->type = STT_GNU_IFUNC;
+	      h->def_regular = 1;
+	      h->ref_regular = 1;
+	      h->forced_local = 1;
+	      h->root.type = bfd_link_hash_defined;
+	    }
+	  else
+	    h = NULL;
+	}
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+	  is_abs_symbol = bfd_is_abs_symbol (&h->root) ? true : false;
+	}
+
+      if (h != NULL)
+	{
+	  switch (r_type)
+	    {
+	    case R_XR17032_32:
+	    case R_XR17032_JUMP:
+	    case R_XR17032_LO16:
+	    case R_XR17032_LO16_1:
+	    case R_XR17032_LO16_2:
+	    case R_XR17032_HI16:
+	    case R_XR17032_HI16_PCREL:
+	    case R_XR17032_HI16_GOT:
+	    case R_XR17032_HI16_PLT:
+	      /* Create the ifunc sections, iplt and ipltgot, for static
+		 executables.  */
+	      if (h->type == STT_GNU_IFUNC
+		  && !_bfd_elf_create_ifunc_sections (htab->elf.dynobj, info))
+		return false;
+	      break;
+
+	    default:
+	      break;
+	    }
+
+	  /* It is referenced by a non-shared object.  */
+	  h->ref_regular = 1;
+	}
+
+      switch (r_type)
+	{
+	case R_XR17032_HI16_TLS_GD:
+	  if (!xr17032_elf_record_got_reference (abfd, info, h, r_symndx)
+	      || !xr17032_elf_record_tls_type (abfd, h, r_symndx, GOT_TLS_GD))
+	    return false;
+	  break;
+
+	case R_XR17032_HI16_TLS_GOT:
+	  if (bfd_link_dll (info))
+	    info->flags |= DF_STATIC_TLS;
+	  if (!xr17032_elf_record_got_reference (abfd, info, h, r_symndx)
+	      || !xr17032_elf_record_tls_type (abfd, h, r_symndx, GOT_TLS_IE))
+	    return false;
+	  break;
+
+	case R_XR17032_HI16_GOT:
+	  if (!xr17032_elf_record_got_reference (abfd, info, h, r_symndx)
+	      || !xr17032_elf_record_tls_type (abfd, h, r_symndx, GOT_NORMAL))
+	    return false;
+	  break;
+
+	case R_XR17032_JUMP:
+	  if (bfd_link_pic (info))
+	    return bad_static_reloc (abfd, r_type, h);
+	  /* Fall through. */
+
+	case R_XR17032_HI16_PLT:
+	  /* These symbol requires a procedure linkage table entry.
+	     We actually build the entry in adjust_dynamic_symbol,
+	     because these might be a case of linking PIC code without
+	     linking in any dynamic objects, in which case we don't
+	     need to generate a procedure linkage table after all.  */
+
+	  /* If it is a local symbol, then we resolve it directly
+	     without creating a PLT entry.  */
+	  if (h == NULL)
+	    continue;
+
+	  h->needs_plt = 1;
+	  h->plt.refcount += 1;
+	  break;
+
+	case R_XR17032_HI16_PCREL:
+	  if (h != NULL
+	      && h->type == STT_GNU_IFUNC)
+	    {
+	      h->non_got_ref = 1;
+	      h->pointer_equality_needed = 1;
+
+	      /* We don't use the HI16_PCREL in the data section,
+		 so we always need the plt when it refers to
+		 ifunc symbol.  */
+	      h->plt.refcount += 1;
+	    }
+
+	  /* The non-preemptible absolute symbol shouldn't be referneced with
+	     pc-relative relocation when generating shared object.  However,
+	     HI16/LO16_PCREL relocs are always bind locally when generating
+	     shared object, so all absolute symbol referenced need to be
+	     disallowed, except they are defined in linker script.
+
+	     Maybe we should add this check for all pc-relative relocations.  */
+	  if (bfd_link_pic (info)
+	      /* (h == NULL || SYMBOL_REFERENCES_LOCAL (info, h))  */
+	      && is_abs_symbol)
+	    {
+	      if (h != NULL && (h)->root.ldscript_def)
+		/* Disallow the absolute symbol defined in linker script here
+		   will cause the glibc-linux toolchain build failed, so regard
+		   them as pc-relative symbols, just like what x86 did.  */
+		;
+	      else
+		{
+		  const char *name;
+		  if (h->root.root.string)
+		    name = h->root.root.string;
+		  else
+		    {
+		      Elf_Internal_Sym *sym;
+		      sym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, abfd,
+						   r_symndx);
+		      name = bfd_elf_sym_name (abfd, symtab_hdr, sym, NULL);
+		    }
+
+		  reloc_howto_type *r_t =
+			xr17032_elf_rtype_to_howto (abfd, r_type);
+		  _bfd_error_handler
+		    (_("%pB: relocation %s against absolute symbol `%s' can "
+		       "not be used when making a shared object"),
+		     abfd, r_t ? r_t->name : _("<unknown>"), name);
+		  bfd_set_error (bfd_error_bad_value);
+		  return false;
+		}
+	    }
+	  /* Fall through.  */
+
+	case R_XR17032_BRANCH:
+	  /* In shared libraries and pie, these relocs are known
+	     to bind locally.  */
+	  if (bfd_link_pic (info))
+	    break;
+	  goto static_reloc;
+
+	case R_XR17032_HI16_TPREL:
+	  /* This is not allowed in the pic, but okay in pie.  */
+	  if (!bfd_link_executable (info))
+	    return bad_static_reloc (abfd, r_type, h);
+	  if (h != NULL)
+	    xr17032_elf_record_tls_type (abfd, h, r_symndx, GOT_TLS_LE);
+	  break;
+
+	case R_XR17032_8:
+	case R_XR17032_16:
+	case R_XR17032_IMM16:
+	case R_XR17032_IMM16_1:
+	case R_XR17032_IMM16_2:
+	case R_XR17032_IMM16_16:
+	case R_XR17032_IMM16_SIGNED:
+	case R_XR17032_LO16:
+	case R_XR17032_LO16_1:
+	case R_XR17032_LO16_2:
+	case R_XR17032_HI16:
+	  if (bfd_link_pic (info))
+	    return bad_static_reloc (abfd, r_type, h);
+	  goto static_reloc;
+
+	case R_XR17032_32:
+	case R_XR17032_COPY:
+	case R_XR17032_JUMP_SLOT:
+	case R_XR17032_RELATIVE:
+	  /* Fall through.  */
+
+	static_reloc:
+
+	  if (h != NULL
+	      && (!bfd_link_pic (info)
+		  || h->type == STT_GNU_IFUNC))
+	    {
+	      /* This reloc might not bind locally.  */
+	      h->non_got_ref = 1;
+	      h->pointer_equality_needed = 1;
+
+	      if (!h->def_regular
+		  || (sec->flags & (SEC_CODE | SEC_READONLY)) != 0)
+		{
+		  /* We may need a .plt entry if the symbol is a function
+		     defined in a shared lib or is a function referenced
+		     from the code or read-only section.  */
+		  h->plt.refcount += 1;
+		}
+	    }
+
+	  reloc_howto_type *r = xr17032_elf_rtype_to_howto (abfd, r_type);
+	  if (XR17032_NEED_DYNAMIC_RELOC (r->pc_relative, info, h, sec))
+	    {
+	      struct elf_dyn_relocs *p;
+	      struct elf_dyn_relocs **head;
+
+	      /* When creating a shared object, we must copy these
+		 relocs into the output file.  We create a reloc
+		 section in dynobj and make room for the reloc.  */
+	      if (sreloc == NULL)
+		{
+		  sreloc = _bfd_elf_make_dynamic_reloc_section
+		    (sec, htab->elf.dynobj, 2, abfd, /*rela?*/ true);
+
+		  if (sreloc == NULL)
+		    return false;
+		}
+
+	      /* If this is a global symbol, we count the number of
+		 relocations we need for this symbol.  */
+	      if (h != NULL)
+		head = &h->dyn_relocs;
+	      else
+		{
+		  /* Track dynamic relocs needed for local syms too.
+		     We really need local syms available to do this
+		     easily.  Oh well.  */
+
+		  asection *s;
+		  void *vpp;
+		  Elf_Internal_Sym *isym;
+
+		  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
+						abfd, r_symndx);
+		  if (isym == NULL)
+		    return false;
+
+		  s = bfd_section_from_elf_index (abfd, isym->st_shndx);
+		  if (s == NULL)
+		    s = sec;
+
+		  vpp = &elf_section_data (s)->local_dynrel;
+		  head = (struct elf_dyn_relocs **) vpp;
+		}
+
+	      p = *head;
+	      if (p == NULL || p->sec != sec)
+		{
+		  size_t amt = sizeof *p;
+		  p = ((struct elf_dyn_relocs *)
+		       bfd_alloc (htab->elf.dynobj, amt));
+		  if (p == NULL)
+		    return false;
+		  p->next = *head;
+		  *head = p;
+		  p->sec = sec;
+		  p->count = 0;
+		  p->pc_count = 0;
+		}
+
+	      p->count += 1;
+	      p->pc_count += r == NULL ? 0 : r->pc_relative;
+	    }
+
+	  break;
+
+	default:
+	  break;
+	}
+    }
+
+  return true;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bool
+xr17032_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
+				   struct elf_link_hash_entry *h)
+{
+  struct xr17032_elf_link_hash_table *htab;
+  struct xr17032_elf_link_hash_entry * eh;
+  bfd *dynobj;
+  asection *s, *srel;
+
+  htab = xr17032_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+
+  dynobj = htab->elf.dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+	      && (h->needs_plt
+		  || h->type == STT_GNU_IFUNC
+		  || h->is_weakalias
+		  || (h->def_dynamic
+		      && h->ref_regular
+		      && !h->def_regular)));
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later
+     (although we could actually do it here).  */
+  if (h->type == STT_FUNC || h->type == STT_GNU_IFUNC || h->needs_plt)
+    {
+      if (h->plt.refcount <= 0
+	  || (h->type != STT_GNU_IFUNC
+	      && (SYMBOL_CALLS_LOCAL (info, h)
+		  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
+		      && h->root.type == bfd_link_hash_undefweak))))
+	{
+	  /* This case can occur if we saw a R_XR17032_JUMP_PLT reloc in an
+	     input file, but the symbol was never referred to by a dynamic
+	     object, or if all references were garbage collected.  In such
+	     a case, we don't actually need to build a PLT entry.  */
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+
+      return true;
+    }
+  else
+    h->plt.offset = (bfd_vma) -1;
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->is_weakalias)
+    {
+      struct elf_link_hash_entry *def = weakdef (h);
+      BFD_ASSERT (def->root.type == bfd_link_hash_defined);
+      h->root.u.def.section = def->root.u.def.section;
+      h->root.u.def.value = def->root.u.def.value;
+      return true;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (bfd_link_pic (info))
+    return true;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (!h->non_got_ref)
+    return true;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return true;
+    }
+
+  /* If we don't find any dynamic relocs in read-only sections, then
+     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
+  if (!_bfd_elf_readonly_dynrelocs (h))
+    {
+      h->non_got_ref = 0;
+      return true;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  /* We must generate a R_XR17032_COPY reloc to tell the dynamic linker
+     to copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
+     .rel.bss section we are going to use.  */
+  eh = (struct xr17032_elf_link_hash_entry *) h;
+  if (eh->tls_type & ~GOT_NORMAL)
+    {
+      s = htab->sdyntdata;
+      srel = htab->elf.srelbss;
+    }
+  else if ((h->root.u.def.section->flags & SEC_READONLY) != 0)
+    {
+      s = htab->elf.sdynrelro;
+      srel = htab->elf.sreldynrelro;
+    }
+  else
+    {
+      s = htab->elf.sdynbss;
+      srel = htab->elf.srelbss;
+    }
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
+    {
+      srel->size += sizeof (Elf32_External_Rela);
+      h->needs_copy = 1;
+    }
+
+  return _bfd_elf_adjust_dynamic_copy (info, h, s);
+}
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   dynamic relocs.  */
+
+static bool
+allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
+{
+  struct bfd_link_info *info;
+  struct xr17032_elf_link_hash_table *htab;
+  struct elf_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return true;
+
+  info = (struct bfd_link_info *) inf;
+  htab = xr17032_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+
+  /* Since STT_GNU_IFUNC symbols must go through PLT, we handle them
+     in the allocate_ifunc_dynrelocs and allocate_local_ifunc_dynrelocs,
+     if they are defined and referenced in a non-shared object.  */
+  if (h->type == STT_GNU_IFUNC
+      && h->def_regular)
+    return true;
+  else if (htab->elf.dynamic_sections_created
+	   && h->plt.refcount > 0)
+    {
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return false;
+	}
+
+      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h))
+	{
+	  asection *s = htab->elf.splt;
+
+	  if (s->size == 0)
+	    s->size = PLT_HEADER_SIZE;
+
+	  h->plt.offset = s->size;
+
+	  /* Make room for this entry.  */
+	  s->size += PLT_ENTRY_SIZE;
+
+	  /* We also need to make an entry in the .got.plt section.  */
+	  htab->elf.sgotplt->size += GOT_ENTRY_SIZE;
+
+	  /* We also need to make an entry in the .rela.plt section.  */
+	  htab->elf.srelplt->size += sizeof (Elf32_External_Rela);
+
+	  /* If this symbol is not defined in a regular file, and we are
+	     not generating a shared library, then set the symbol to this
+	     location in the .plt.  This is required to make function
+	     pointers compare as equal between the normal executable and
+	     the shared library.  */
+	  if (! bfd_link_pic (info)
+	      && !h->def_regular)
+	    {
+	      h->root.u.def.section = s;
+	      h->root.u.def.value = h->plt.offset;
+	    }
+	}
+      else
+	{
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+    }
+  else
+    {
+      h->plt.offset = (bfd_vma) -1;
+      h->needs_plt = 0;
+    }
+
+  if (h->got.refcount > 0)
+    {
+      asection *s;
+      bool dyn;
+      int tls_type = xr17032_elf_hash_entry (h)->tls_type;
+
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return false;
+	}
+
+      s = htab->elf.sgot;
+      h->got.offset = s->size;
+      dyn = htab->elf.dynamic_sections_created;
+      if (tls_type & (GOT_TLS_GD | GOT_TLS_IE))
+	{
+	  int indx = 0;
+	  bool need_reloc = false;
+	  XR17032_TLS_GD_IE_NEED_DYN_RELOC(info, dyn, h, indx, need_reloc);
+
+	  /* TLS_GD needs two dynamic relocs and two GOT slots.  */
+	  if (tls_type & GOT_TLS_GD)
+	    {
+	      s->size += TLS_GD_GOT_ENTRY_SIZE;
+	      if (need_reloc)
+		htab->elf.srelgot->size += 2 * sizeof (Elf32_External_Rela);
+	    }
+
+	  /* TLS_IE needs one dynamic reloc and one GOT slot.  */
+	  if (tls_type & GOT_TLS_IE)
+	    {
+	      s->size += TLS_IE_GOT_ENTRY_SIZE;
+	      if (need_reloc)
+		htab->elf.srelgot->size += sizeof (Elf32_External_Rela);
+	    }
+	}
+      else
+	{
+	  s->size += GOT_ENTRY_SIZE;
+	  if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h)
+	      && ! UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
+	    htab->elf.srelgot->size += sizeof (Elf32_External_Rela);
+	}
+    }
+  else
+    h->got.offset = (bfd_vma) -1;
+
+  if (h->dyn_relocs == NULL)
+    return true;
+
+  /* In the shared -Bsymbolic case, discard space allocated for
+     dynamic pc-relative relocs against symbols which turn out to be
+     defined in regular objects.  For the normal shared case, discard
+     space for pc-relative relocs that have become local due to symbol
+     visibility changes.  */
+
+  if (bfd_link_pic (info))
+    {
+      if (SYMBOL_CALLS_LOCAL (info, h))
+	{
+	  struct elf_dyn_relocs **pp;
+
+	  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )
+	    {
+	      p->count -= p->pc_count;
+	      p->pc_count = 0;
+	      if (p->count == 0)
+		*pp = p->next;
+	      else
+		pp = &p->next;
+	    }
+	}
+
+      /* Also discard relocs on undefined weak syms with non-default
+	 visibility.  */
+      if (h->dyn_relocs != NULL
+	  && h->root.type == bfd_link_hash_undefweak)
+	{
+	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
+	      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
+	    h->dyn_relocs = NULL;
+
+	  /* Make sure undefined weak symbols are output as a dynamic
+	     symbol in PIEs.  */
+	  else if (h->dynindx == -1
+		   && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return false;
+	    }
+	}
+    }
+  else
+    {
+      /* For the non-shared case, discard space for relocs against
+	 symbols which turn out to need copy relocs or are not
+	 dynamic.  */
+
+      if (!h->non_got_ref
+	  && ((h->def_dynamic
+	       && !h->def_regular)
+	      || (htab->elf.dynamic_sections_created
+		  && (h->root.type == bfd_link_hash_undefweak
+		      || h->root.type == bfd_link_hash_undefined))))
+	{
+	  /* Make sure this symbol is output as a dynamic symbol.
+	     Undefined weak syms won't yet be marked as dynamic.  */
+	  if (h->dynindx == -1
+	      && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return false;
+	    }
+
+	  /* If that succeeded, we know we'll be keeping all the
+	     relocs.  */
+	  if (h->dynindx != -1)
+	    goto keep;
+	}
+
+      h->dyn_relocs = NULL;
+
+    keep: ;
+    }
+
+  /* Finally, allocate space.  */
+  for (p = h->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *sreloc = elf_section_data (p->sec)->sreloc;
+      sreloc->size += p->count * sizeof (Elf32_External_Rela);
+    }
+
+  return true;
+}
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   ifunc dynamic relocs.  */
+
+static bool
+allocate_ifunc_dynrelocs (struct elf_link_hash_entry *h,
+			  void *inf)
+{
+  struct bfd_link_info *info;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return true;
+
+  if (h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  info = (struct bfd_link_info *) inf;
+
+  /* Since STT_GNU_IFUNC symbol must go through PLT, we handle it
+     here if it is defined and referenced in a non-shared object.  */
+  if (h->type == STT_GNU_IFUNC
+      && h->def_regular)
+    return _bfd_elf_allocate_ifunc_dyn_relocs (info, h,
+					       &h->dyn_relocs,
+					       PLT_ENTRY_SIZE,
+					       PLT_HEADER_SIZE,
+					       GOT_ENTRY_SIZE,
+					       true);
+  return true;
+}
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   local ifunc dynamic relocs.  */
+
+static int
+allocate_local_ifunc_dynrelocs (void **slot, void *inf)
+{
+  struct elf_link_hash_entry *h
+    = (struct elf_link_hash_entry *) *slot;
+
+  if (h->type != STT_GNU_IFUNC
+      || !h->def_regular
+      || !h->ref_regular
+      || !h->forced_local
+      || h->root.type != bfd_link_hash_defined)
+    abort ();
+
+  return allocate_ifunc_dynrelocs (h, inf);
+}
+
+static bool
+xr17032_elf_late_size_sections (bfd *output_bfd, struct bfd_link_info *info)
+{
+  struct xr17032_elf_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd *ibfd;
+
+  htab = xr17032_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+  dynobj = htab->elf.dynobj;
+  if (dynobj == NULL)
+    return true;
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (bfd_link_executable (info) && !info->nointerp)
+	{
+	  s = bfd_get_linker_section (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  s->size = strlen (ELF32_DYNAMIC_INTERPRETER) + 1;
+	  s->contents = (unsigned char *) ELF32_DYNAMIC_INTERPRETER;
+	}
+    }
+
+  /* Set up .got offsets for local syms, and space for local dynamic
+     relocs.  */
+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link.next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_signed_vma *end_local_got;
+      char *local_tls_type;
+      bfd_size_type locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+      asection *srel;
+
+      if (! is_xr17032_elf (ibfd))
+	continue;
+
+      for (s = ibfd->sections; s != NULL; s = s->next)
+	{
+	  struct elf_dyn_relocs *p;
+
+	  for (p = elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
+	    {
+	      if (!bfd_is_abs_section (p->sec)
+		  && bfd_is_abs_section (p->sec->output_section))
+		{
+		  /* Input section has been discarded, either because
+		     it is a copy of a linkonce section or due to
+		     linker script /DISCARD/, so we'll be discarding
+		     the relocs too.  */
+		}
+	      else if (p->count != 0)
+		{
+		  srel = elf_section_data (p->sec)->sreloc;
+		  srel->size += p->count * sizeof (Elf32_External_Rela);
+		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
+		    info->flags |= DF_TEXTREL;
+		}
+	    }
+	}
+
+      local_got = elf_local_got_refcounts (ibfd);
+      if (!local_got)
+	continue;
+
+      symtab_hdr = &elf_symtab_hdr (ibfd);
+      locsymcount = symtab_hdr->sh_info;
+      end_local_got = local_got + locsymcount;
+      local_tls_type = _bfd_xr17032_elf_local_got_tls_type (ibfd);
+      s = htab->elf.sgot;
+      srel = htab->elf.srelgot;
+      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
+	{
+	  if (*local_got > 0)
+	    {
+	      *local_got = s->size;
+	      if (*local_tls_type & (GOT_TLS_GD | GOT_TLS_IE))
+		{
+		  if (*local_tls_type & GOT_TLS_GD)
+		    {
+		      s->size += TLS_GD_GOT_ENTRY_SIZE;
+		      if (bfd_link_dll (info))
+			srel->size += sizeof (Elf32_External_Rela);
+		    }
+		  if (*local_tls_type & GOT_TLS_IE)
+		    {
+		      s->size += TLS_IE_GOT_ENTRY_SIZE;
+		      if (bfd_link_dll (info))
+			srel->size += sizeof (Elf32_External_Rela);
+		    }
+		}
+	      else
+		{
+		  s->size += GOT_ENTRY_SIZE;
+		  if (bfd_link_pic (info))
+		    srel->size += sizeof (Elf32_External_Rela);
+		}
+	    }
+	  else
+	    *local_got = (bfd_vma) -1;
+	}
+    }
+
+  /* Allocate .plt and .got entries and space dynamic relocs for
+     global symbols.  */
+  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
+
+  /* Allocate .plt and .got entries and space dynamic relocs for
+     global ifunc symbols.  */
+  elf_link_hash_traverse (&htab->elf, allocate_ifunc_dynrelocs, info);
+
+  /* Allocate .plt and .got entries and space dynamic relocs for
+     local ifunc symbols.  */
+  htab_traverse (htab->loc_hash_table, allocate_local_ifunc_dynrelocs, info);
+
+  /* Used to resolve the dynamic relocs overwite problems when
+     generating static executable.  */
+  if (htab->elf.irelplt)
+    htab->last_iplt_index = htab->elf.irelplt->reloc_count - 1;
+
+  if (htab->elf.sgotplt)
+    {
+      struct elf_link_hash_entry *got;
+      got = elf_link_hash_lookup (elf_hash_table (info),
+				  "_GLOBAL_OFFSET_TABLE_",
+				  false, false, false);
+
+      /* Don't allocate .got.plt section if there are no GOT nor PLT
+	 entries and there is no refeence to _GLOBAL_OFFSET_TABLE_.  */
+      if ((got == NULL
+	   || !got->ref_regular_nonweak)
+	  && (htab->elf.sgotplt->size == GOTPLT_HEADER_SIZE)
+	  && (htab->elf.splt == NULL
+	      || htab->elf.splt->size == 0)
+	  && (htab->elf.sgot == NULL
+	      || (htab->elf.sgot->size
+		  == get_elf_backend_data (output_bfd)->got_header_size)))
+	htab->elf.sgotplt->size = 0;
+    }
+
+  /* The check_relocs and adjust_dynamic_symbol entry points have
+     determined the sizes of the various dynamic sections.  Allocate
+     memory for them.  */
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      if (s == htab->elf.splt
+	  || s == htab->elf.sgot
+	  || s == htab->elf.sgotplt
+	  || s == htab->elf.iplt
+	  || s == htab->elf.igotplt
+	  || s == htab->elf.sdynbss
+	  || s == htab->elf.sdynrelro
+	  || s == htab->sdyntdata)
+	{
+	  /* Strip this section if we don't need it; see the
+	     comment below.  */
+	}
+      else if (startswith (s->name, ".rela"))
+	{
+	  if (s->size != 0)
+	    {
+	      /* We use the reloc_count field as a counter if we need
+		 to copy relocs into the output file.  */
+	      s->reloc_count = 0;
+	    }
+	}
+      else
+	{
+	  /* It's not one of our sections.  */
+	  continue;
+	}
+
+      if (s->size == 0)
+	{
+	  /* If we don't need this section, strip it from the
+	     output file.  This is mostly to handle .rela.bss and
+	     .rela.plt.  We must create both sections in
+	     create_dynamic_sections, because they must be created
+	     before the linker maps input sections to output
+	     sections.  The linker does that before
+	     adjust_dynamic_symbol is called, and it is that
+	     function which decides whether anything needs to go
+	     into these sections.  */
+	  s->flags |= SEC_EXCLUDE;
+	  continue;
+	}
+
+      if ((s->flags & SEC_HAS_CONTENTS) == 0)
+	continue;
+
+      /* Allocate memory for the section contents.  Zero the memory
+	 for the benefit of .rela.plt, which has 4 unused entries
+	 at the beginning, and we don't want garbage.  */
+      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
+      if (s->contents == NULL)
+	return false;
+    }
+
+  /* Add dynamic entries.  */
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      if (!_bfd_elf_add_dynamic_tags (output_bfd, info, true))
+	return false;
+    }
+
+  return true;
+}
+
+/* Emplace a static relocation.  */
+
+static bfd_reloc_status_type
+perform_relocation (const reloc_howto_type *howto,
+		    const Elf_Internal_Rela *rel,
+		    bfd_vma value,
+		    asection *input_section,
+		    bfd *input_bfd,
+		    bfd_byte *contents)
+{
+  if (howto->pc_relative)
+    value -= sec_addr (input_section) + rel->r_offset;
+
+  value += rel->r_addend;
+
+  switch (ELF32_R_TYPE (rel->r_info))
+    {
+    case R_XR17032_32:
+    case R_XR17032_TLS_DTPREL:
+    case R_XR17032_8:
+    case R_XR17032_16:
+    case R_XR17032_8_PCREL:
+    case R_XR17032_16_PCREL:
+    case R_XR17032_32_PCREL:
+      break;
+
+    case R_XR17032_JUMP:
+      if (!XR_IMM_VALID_J (value, sec_addr (input_section) + rel->r_offset))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_J (value);
+      break;
+
+    case R_XR17032_BRANCH:
+      if (!XR_IMM_VALID_B (value))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_B (value);
+      break;
+
+    case R_XR17032_IMM16:
+      if (!XR_IMM_VALID_I (value))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_I (value);
+      break;
+
+    case R_XR17032_IMM16_1:
+      if (!XR_IMM_VALID_I_1 (value))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_I_1 (value);
+      break;
+
+    case R_XR17032_IMM16_2:
+      if (!XR_IMM_VALID_I_2 (value))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_I_2 (value);
+      break;
+
+    case R_XR17032_IMM16_16:
+      if (!XR_IMM_VALID_I_16 (value))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_I_16 (value);
+      break;
+
+    case R_XR17032_IMM16_SIGNED:
+      if (!XR_IMM_VALID_I_S (value))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_I_S (value);
+      break;
+
+    case R_XR17032_LO16:
+    case R_XR17032_LO16_TPREL:
+    case R_XR17032_LO16_PCREL:
+      value = XR_IMM_LOW_PART (value);
+      if (!XR_IMM_VALID_I (value))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_I (value);
+      break;
+
+    case R_XR17032_LO16_1:
+    case R_XR17032_LO16_1_TPREL:
+    case R_XR17032_LO16_1_PCREL:
+      value = XR_IMM_LOW_PART (value);
+      if (!XR_IMM_VALID_I_1 (value))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_I_1 (value);
+      break;
+
+    case R_XR17032_LO16_2:
+    case R_XR17032_LO16_2_TPREL:
+    case R_XR17032_LO16_2_PCREL:
+      value = XR_IMM_LOW_PART (value);
+      if (!XR_IMM_VALID_I_2 (value))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_I_2 (value);
+      break;
+
+    case R_XR17032_HI16:
+    case R_XR17032_HI16_PCREL:
+    case R_XR17032_HI16_GOT:
+    case R_XR17032_HI16_TLS_GOT:
+    case R_XR17032_HI16_TLS_GD:
+    case R_XR17032_HI16_TPREL:
+      value = XR_IMM_HIGH_PART (value);
+      if (!XR_IMM_VALID_I_16 (value))
+	return bfd_reloc_overflow;
+      value = XR_IMM_ENCODE_I_16 (value);
+      break;
+
+    default:
+      return bfd_reloc_notsupported;
+    }
+
+  bfd_vma word = bfd_get (howto->bitsize, input_bfd, contents + rel->r_offset);
+  word = (word & ~howto->dst_mask) | (value & howto->dst_mask);
+  bfd_put (howto->bitsize, input_bfd, word, contents + rel->r_offset);
+
+  return bfd_reloc_ok;
+}
+
+/* Remember all PC-relative high-part relocs we've encountered to help us
+   later resolve the corresponding low-part relocs.  */
+
+typedef struct
+{
+  /* PC value.  */
+  bfd_vma address;
+  /* Relocation value with addend.  */
+  bfd_vma value;
+  /* Original reloc type.  */
+  int type;
+} xr17032_pcrel_hi_reloc;
+
+typedef struct xr17032_pcrel_lo_reloc
+{
+  /* PC value of auipc.  */
+  bfd_vma address;
+  /* Internal relocation.  */
+  Elf_Internal_Rela *reloc;
+  /* Record the following information helps to resolve the %pcrel
+     which cross different input section.  For now we build a hash
+     for pcrel at the start of xr17032_elf_relocate_section, and then
+     free the hash at the end.  But xr17032_elf_relocate_section only
+     handles an input section at a time, so that means we can only
+     resolve the %pcrel_hi and %pcrel_lo which are in the same input
+     section.  Otherwise, we will report dangerous relocation errors
+     for those %pcrel which are not in the same input section.  */
+  asection *input_section;
+  struct bfd_link_info *info;
+  reloc_howto_type *howto;
+  bfd_byte *contents;
+  /* The next xr17032_pcrel_lo_reloc.  */
+  struct xr17032_pcrel_lo_reloc *next;
+} xr17032_pcrel_lo_reloc;
+
+typedef struct
+{
+  /* Hash table for xr17032_pcrel_hi_reloc.  */
+  htab_t hi_relocs;
+  /* Linked list for xr17032_pcrel_lo_reloc.  */
+  xr17032_pcrel_lo_reloc *lo_relocs;
+} xr17032_pcrel_relocs;
+
+static hashval_t
+xr17032_pcrel_reloc_hash (const void *entry)
+{
+  const xr17032_pcrel_hi_reloc *e = entry;
+  return (hashval_t)(e->address >> 2);
+}
+
+static int
+xr17032_pcrel_reloc_eq (const void *entry1, const void *entry2)
+{
+  const xr17032_pcrel_hi_reloc *e1 = entry1, *e2 = entry2;
+  return e1->address == e2->address;
+}
+
+static bool
+xr17032_init_pcrel_relocs (xr17032_pcrel_relocs *p)
+{
+  p->lo_relocs = NULL;
+  p->hi_relocs = htab_create (1024, xr17032_pcrel_reloc_hash,
+			      xr17032_pcrel_reloc_eq, free);
+  return p->hi_relocs != NULL;
+}
+
+static void
+xr17032_free_pcrel_relocs (xr17032_pcrel_relocs *p)
+{
+  xr17032_pcrel_lo_reloc *cur = p->lo_relocs;
+
+  while (cur != NULL)
+    {
+      xr17032_pcrel_lo_reloc *next = cur->next;
+      free (cur);
+      cur = next;
+    }
+
+  htab_delete (p->hi_relocs);
+}
+
+static bool
+xr17032_record_pcrel_hi_reloc (xr17032_pcrel_relocs *p,
+			       bfd_vma addr,
+			       bfd_vma value,
+			       int type)
+{
+  bfd_vma offset = value - addr;
+  xr17032_pcrel_hi_reloc entry = {addr, offset, type};
+  xr17032_pcrel_hi_reloc **slot =
+    (xr17032_pcrel_hi_reloc **) htab_find_slot (p->hi_relocs, &entry, INSERT);
+
+  BFD_ASSERT (*slot == NULL);
+  *slot = (xr17032_pcrel_hi_reloc *) bfd_malloc (sizeof (xr17032_pcrel_hi_reloc));
+  if (*slot == NULL)
+    return false;
+  **slot = entry;
+  return true;
+}
+
+static bool
+xr17032_record_pcrel_lo_reloc (xr17032_pcrel_relocs *p,
+			       bfd_vma addr,
+			       Elf_Internal_Rela *reloc,
+			       asection *input_section,
+			       struct bfd_link_info *info,
+			       reloc_howto_type *howto,
+			       bfd_byte *contents)
+{
+  xr17032_pcrel_lo_reloc *entry;
+  entry = (xr17032_pcrel_lo_reloc *) bfd_malloc (sizeof (xr17032_pcrel_lo_reloc));
+  if (entry == NULL)
+    return false;
+  *entry = (xr17032_pcrel_lo_reloc) {addr, reloc, input_section, info,
+				     howto, contents, p->lo_relocs};
+  p->lo_relocs = entry;
+  return true;
+}
+
+static bool
+xr17032_resolve_pcrel_lo_relocs (xr17032_pcrel_relocs *p)
+{
+  xr17032_pcrel_lo_reloc *r;
+
+  for (r = p->lo_relocs; r != NULL; r = r->next)
+    {
+      bfd *input_bfd = r->input_section->owner;
+
+      xr17032_pcrel_hi_reloc search = {r->address, 0, 0};
+      xr17032_pcrel_hi_reloc *entry = htab_find (p->hi_relocs, &search);
+      /* There may be a risk if the %pcrel_lo with addend refers to
+	 an IFUNC symbol.  The %pcrel_hi has been relocated to plt,
+	 so the corresponding %pcrel_lo with addend looks wrong.  */
+      char *string = NULL;
+      if (entry == NULL)
+	string = _("%pcrel_lo missing matching %pcrel_hi");
+      else if (entry->type == R_XR17032_HI16_GOT
+	       && r->reloc->r_addend != 0)
+	string = _("%pcrel_lo with addend isn't allowed for R_XR17032_HI16_GOT");
+      else if (XR_IMM_HIGH_PART(entry->value)
+	       != XR_IMM_HIGH_PART(entry->value + r->reloc->r_addend))
+	{
+	  /* Check the overflow when adding reloc addend.  */
+	  string = bfd_asprintf (_("%%pcrel_lo overflow with an addend,"
+				   " the value of %%pcrel_hi is 0x%" PRIx64
+				   " without any addend, but may be 0x%" PRIx64
+				   " after adding the %%pcrel_lo addend"),
+				 (int64_t) XR_IMM_HIGH_PART(entry->value),
+				 (int64_t) XR_IMM_HIGH_PART(entry->value + r->reloc->r_addend));
+	  if (string == NULL)
+	    string = _("%pcrel_lo overflow with an addend");
+	}
+
+      if (string != NULL)
+	{
+	  (*r->info->callbacks->reloc_dangerous)
+	    (r->info, string, input_bfd, r->input_section, r->reloc->r_offset);
+	  return true;
+	}
+
+      perform_relocation (r->howto, r->reloc, entry->value, r->input_section,
+			  input_bfd, r->contents);
+    }
+
+  return true;
+}
+
+/* Return the relocation value for a TLS dtp-relative reloc.  */
+
+static bfd_vma
+dtpoff (struct bfd_link_info *info, bfd_vma address)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+  return address - elf_hash_table (info)->tls_sec->vma;
+}
+
+/* Return the relocation value for a static TLS tp-relative relocation.  */
+
+static bfd_vma
+tpoff (struct bfd_link_info *info, bfd_vma address)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+  return address - elf_hash_table (info)->tls_sec->vma;
+}
+
+/* Relocate an XR/17032 ELF section.
+
+   The RELOCATE_SECTION function is called by the new ELF backend linker
+   to handle the relocations for a section.
+
+   The relocs are always passed as Rela structures.
+
+   This function is responsible for adjusting the section contents as
+   necessary, and (if generating a relocatable output file) adjusting
+   the reloc addend as necessary.
+
+   This function does not have to worry about setting the reloc
+   address or the reloc symbol index.
+
+   LOCAL_SYMS is a pointer to the swapped in local symbols.
+
+   LOCAL_SECTIONS is an array giving the section in the input file
+   corresponding to the st_shndx field of each local symbol.
+
+   The global hash table entry for the global symbols can be found
+   via elf_sym_hashes (input_bfd).
+
+   When generating relocatable output, this function must handle
+   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
+   going to be the section symbol corresponding to the output
+   section, which means that the addend must be adjusted
+   accordingly.  */
+
+static int
+xr17032_elf_relocate_section (bfd *output_bfd,
+			      struct bfd_link_info *info,
+			      bfd *input_bfd,
+			      asection *input_section,
+			      bfd_byte *contents,
+			      Elf_Internal_Rela *relocs,
+			      Elf_Internal_Sym *local_syms,
+			      asection **local_sections)
+{
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+  xr17032_pcrel_relocs pcrel_relocs;
+  bool ret = false;
+  struct xr17032_elf_link_hash_table *htab = xr17032_elf_hash_table (info);
+  Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (input_bfd);
+  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
+  bfd_vma *local_got_offsets = elf_local_got_offsets (input_bfd);
+
+  if (!xr17032_init_pcrel_relocs (&pcrel_relocs))
+    return false;
+
+  relend = relocs + input_section->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_symndx;
+      struct elf_link_hash_entry *h;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      bfd_vma relocation;
+      bfd_reloc_status_type r = bfd_reloc_ok;
+      const char *name = NULL;
+      bfd_vma off, ie_off, desc_off;
+      bool unresolved_reloc, is_ie = false, is_desc = false;
+      bfd_vma pc = sec_addr (input_section) + rel->r_offset;
+      int r_type = ELF32_R_TYPE (rel->r_info), tls_type;
+      reloc_howto_type *howto = xr17032_elf_rtype_to_howto (input_bfd, r_type);
+      const char *msg = NULL;
+      bool resolved_to_zero;
+
+      if (howto == NULL)
+	continue;
+
+      /* This is a final link.  */
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+      unresolved_reloc = false;
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+
+	  /* Relocate against local STT_GNU_IFUNC symbol.  */
+	  if (!bfd_link_relocatable (info)
+	      && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
+	    {
+	      h = xr17032_elf_get_local_sym_hash (htab, input_bfd, rel, false);
+	      if (h == NULL)
+		abort ();
+
+	      /* Set STT_GNU_IFUNC symbol value.  */
+	      h->root.u.def.value = sym->st_value;
+	      h->root.u.def.section = sec;
+	    }
+	}
+      else
+	{
+	  bool warned, ignored;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned, ignored);
+	  if (warned)
+	    {
+	      /* To avoid generating warning messages about truncated
+		 relocations, set the relocation's address to be the same as
+		 the start of this section.  */
+	      if (input_section->output_section != NULL)
+		relocation = input_section->output_section->vma;
+	      else
+		relocation = 0;
+	    }
+	}
+
+      if (sec != NULL && discarded_section (sec))
+	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+					 rel, 1, relend, howto, 0, contents);
+
+      if (bfd_link_relocatable (info))
+	continue;
+
+      /* Since STT_GNU_IFUNC symbol must go through PLT, we handle
+	 it here if it is defined in a non-shared object.  */
+      if (h != NULL
+	  && h->type == STT_GNU_IFUNC
+	  && h->def_regular)
+	{
+	  asection *plt, *base_got;
+
+	  if ((input_section->flags & SEC_ALLOC) == 0)
+	    {
+	      /* If this is a SHT_NOTE section without SHF_ALLOC, treat
+		 STT_GNU_IFUNC symbol as STT_FUNC.  */
+	      if (elf_section_type (input_section) == SHT_NOTE)
+		goto skip_ifunc;
+
+	      /* Dynamic relocs are not propagated for SEC_DEBUGGING
+		 sections because such sections are not SEC_ALLOC and
+		 thus ld.so will not process them.  */
+	      if ((input_section->flags & SEC_DEBUGGING) != 0)
+		continue;
+
+	      abort ();
+	    }
+	  else if (h->plt.offset == (bfd_vma) -1
+		   /* The following relocation may not need the .plt entries
+		      when all references to a STT_GNU_IFUNC symbols are done
+		      via GOT or static function pointers.  */
+		   && r_type != R_XR17032_32
+		   && r_type != R_XR17032_LO16
+		   && r_type != R_XR17032_LO16_1
+		   && r_type != R_XR17032_LO16_2
+		   && r_type != R_XR17032_HI16
+		   && r_type != R_XR17032_HI16_GOT)
+	    goto bad_ifunc_reloc;
+
+	  /* STT_GNU_IFUNC symbol must go through PLT.  */
+	  plt = htab->elf.splt ? htab->elf.splt : htab->elf.iplt;
+	  relocation = plt->output_section->vma
+		       + plt->output_offset
+		       + h->plt.offset;
+
+	  switch (r_type)
+	    {
+	    case R_XR17032_32:
+	      if (rel->r_addend != 0)
+		{
+		  if (h->root.root.string)
+		    name = h->root.root.string;
+		  else
+		    name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym, NULL);
+
+		  _bfd_error_handler
+		    /* xgettext:c-format */
+		    (_("%pB: relocation %s against STT_GNU_IFUNC "
+		       "symbol `%s' has non-zero addend: %" PRId64),
+		     input_bfd, howto->name, name, (int64_t) rel->r_addend);
+		  bfd_set_error (bfd_error_bad_value);
+		  return false;
+		}
+
+		/* Generate dynamic relocation only when there is a non-GOT
+		   reference in a shared object or there is no PLT.  */
+		if ((bfd_link_pic (info) && h->non_got_ref)
+		    || h->plt.offset == (bfd_vma) -1)
+		  {
+		    Elf_Internal_Rela outrel;
+
+		    /* Need a dynamic relocation to get the real function
+		       address.  */
+		    outrel.r_offset = _bfd_elf_section_offset (output_bfd,
+							       info,
+							       input_section,
+							       rel->r_offset);
+		    if (outrel.r_offset == (bfd_vma) -1
+			|| outrel.r_offset == (bfd_vma) -2)
+		      abort ();
+
+		    outrel.r_offset += input_section->output_section->vma
+				       + input_section->output_offset;
+
+		    if (h->dynindx == -1
+			|| h->forced_local
+			|| bfd_link_executable (info))
+		      {
+			info->callbacks->minfo
+			  (_("Local IFUNC function `%s' in %pB\n"),
+			   h->root.root.string,
+			   h->root.u.def.section->owner);
+
+			/* This symbol is resolved locally.  */
+			outrel.r_info = ELF32_R_INFO (0, R_XR17032_IRELATIVE);
+			outrel.r_addend = h->root.u.def.value
+			  + h->root.u.def.section->output_section->vma
+			  + h->root.u.def.section->output_offset;
+		      }
+		    else
+		      {
+			outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
+			outrel.r_addend = 0;
+		      }
+
+		    /* Dynamic relocations are stored in
+		       1. .rela.ifunc section in PIC object.
+		       2. .rela.got section in dynamic executable.
+		       3. .rela.iplt section in static executable.  */
+		    if (bfd_link_pic (info))
+		      xr17032_elf_append_rela (output_bfd, htab->elf.irelifunc,
+					       &outrel);
+		    else if (htab->elf.splt != NULL)
+		      xr17032_elf_append_rela (output_bfd, htab->elf.srelgot,
+					       &outrel);
+		    else
+		      {
+			/* Do not use xr17032_elf_append_rela to add dynamic
+			   relocs into .rela.iplt, since it may cause the
+			   overwrite problems.  This is same as what we did
+			   in the xr17032_elf_finish_dynamic_symbol.  */
+			const struct elf_backend_data *bed =
+				get_elf_backend_data (output_bfd);
+			bfd_vma iplt_idx = htab->last_iplt_index--;
+			bfd_byte *loc = htab->elf.irelplt->contents
+					+ iplt_idx * sizeof (Elf32_External_Rela);
+			bed->s->swap_reloca_out (output_bfd, &outrel, loc);
+		      }
+
+		    /* If this reloc is against an external symbol, we
+		       do not want to fiddle with the addend.  Otherwise,
+		       we need to include the symbol value so that it
+		       becomes an addend for the dynamic reloc.  For an
+		       internal symbol, we have updated addend.  */
+		    continue;
+		  }
+		goto do_relocation;
+
+	      case R_XR17032_HI16_GOT:
+		base_got = htab->elf.sgot;
+		off = h->got.offset;
+
+		if (base_got == NULL)
+		  abort ();
+
+		if (off == (bfd_vma) -1)
+		  {
+		    bfd_vma plt_idx;
+
+		    /* We can't use h->got.offset here to save state, or
+		       even just remember the offset, as finish_dynamic_symbol
+		       would use that as offset into .got.  */
+
+		    if (htab->elf.splt != NULL)
+		      {
+			plt_idx = (h->plt.offset - PLT_HEADER_SIZE)
+				  / PLT_ENTRY_SIZE;
+			off = GOTPLT_HEADER_SIZE + (plt_idx * GOT_ENTRY_SIZE);
+			base_got = htab->elf.sgotplt;
+		      }
+		    else
+		      {
+			plt_idx = h->plt.offset / PLT_ENTRY_SIZE;
+			off = plt_idx * GOT_ENTRY_SIZE;
+			base_got = htab->elf.igotplt;
+		      }
+
+		    if (h->dynindx == -1
+			|| h->forced_local
+			|| info->symbolic)
+		      {
+			/* This references the local definition.  We must
+			   initialize this entry in the global offset table.
+			   Since the offset must always be a multiple of 8,
+			   we use the least significant bit to record
+			   whether we have initialized it already.
+
+			   When doing a dynamic link, we create a .rela.got
+			   relocation entry to initialize the value.  This
+			   is done in the finish_dynamic_symbol routine.   */
+			if ((off & 1) != 0)
+			  off &= ~1;
+			else
+			  {
+			    bfd_put_32 (output_bfd, relocation,
+					base_got->contents + off);
+			    /* Note that this is harmless for the case,
+			       as -1 | 1 still is -1.  */
+			    h->got.offset |= 1;
+			  }
+		      }
+		  }
+
+		relocation = base_got->output_section->vma
+			     + base_got->output_offset + off;
+
+		if (!xr17032_record_pcrel_hi_reloc (&pcrel_relocs, pc,
+						    relocation, r_type))
+		  r = bfd_reloc_overflow;
+		goto do_relocation;
+
+	      case R_XR17032_JUMP:
+	      case R_XR17032_HI16:
+	      case R_XR17032_LO16:
+	      case R_XR17032_LO16_1:
+	      case R_XR17032_LO16_2:
+		goto do_relocation;
+
+	      case R_XR17032_HI16_PCREL:
+		if (!xr17032_record_pcrel_hi_reloc (&pcrel_relocs, pc,
+						    relocation, r_type))
+		  r = bfd_reloc_overflow;
+		goto do_relocation;
+
+	    default:
+	    bad_ifunc_reloc:
+	      if (h->root.root.string)
+		name = h->root.root.string;
+	      else
+		/* The entry of local ifunc is fake in global hash table,
+		   we should find the name by the original local symbol.  */
+		name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym, NULL);
+
+	      _bfd_error_handler
+	      /* xgettext:c-format */
+	      (_("%pB: relocation %s against STT_GNU_IFUNC "
+		 "symbol `%s' isn't supported"), input_bfd,
+	       howto->name, name);
+	      bfd_set_error (bfd_error_bad_value);
+	      return false;
+	    }
+	}
+
+    skip_ifunc:
+      if (h != NULL)
+	name = h->root.root.string;
+      else
+	{
+	  name = (bfd_elf_string_from_elf_section
+		  (input_bfd, symtab_hdr->sh_link, sym->st_name));
+	  if (name == NULL || *name == '\0')
+	    name = bfd_section_name (sec);
+	}
+
+      resolved_to_zero = (h != NULL
+			  && UNDEFWEAK_NO_DYNAMIC_RELOC (info, h));
+
+      switch (r_type)
+	{
+	case R_XR17032_NONE:
+	case R_XR17032_COPY:
+	case R_XR17032_JUMP_SLOT:
+	case R_XR17032_RELATIVE:
+	  /* These require nothing of us at all.  */
+	  continue;
+
+	case R_XR17032_8:
+	case R_XR17032_16:
+	case R_XR17032_32_PCREL:
+	case R_XR17032_BRANCH:
+	case R_XR17032_IMM16:
+	case R_XR17032_IMM16_1:
+	case R_XR17032_IMM16_2:
+	case R_XR17032_IMM16_16:
+	case R_XR17032_IMM16_SIGNED:
+	case R_XR17032_LO16:
+	case R_XR17032_LO16_1:
+	case R_XR17032_LO16_2:
+	case R_XR17032_HI16:
+	  /* These require no special handling beyond perform_relocation.  */
+	  break;
+
+	case R_XR17032_HI16_GOT:
+	  if (h != NULL)
+	    {
+	      off = h->got.offset;
+	      BFD_ASSERT (off != (bfd_vma) -1);
+
+	      if (XR17032_RESOLVED_LOCALLY (info, h))
+		{
+		  /* We must initialize this entry in the global offset table.
+		     Since the offset must always be a multiple of the word
+		     size, we use the least significant bit to record whether
+		     we have initialized it already.
+
+		     When doing a dynamic link, we create a .rela.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+		  if ((off & 1) != 0)
+		    off &= ~1;
+		  else
+		    {
+		      bfd_put_32 (output_bfd, relocation,
+				  htab->elf.sgot->contents + off);
+		      h->got.offset |= 1;
+		    }
+		}
+	      else
+		unresolved_reloc = false;
+	    }
+	  else
+	    {
+	      BFD_ASSERT (local_got_offsets != NULL
+			  && local_got_offsets[r_symndx] != (bfd_vma) -1);
+
+	      off = local_got_offsets[r_symndx];
+
+	      /* The offset must always be a multiple of the word size.
+		 So, we can use the least significant bit to record
+		 whether we have already processed this entry.  */
+	      if ((off & 1) != 0)
+		off &= ~1;
+	      else
+		{
+		  if (bfd_link_pic (info))
+		    {
+		      asection *s;
+		      Elf_Internal_Rela outrel;
+
+		      /* We need to generate a R_XR17032_RELATIVE reloc
+			 for the dynamic linker.  */
+		      s = htab->elf.srelgot;
+		      BFD_ASSERT (s != NULL);
+
+		      outrel.r_offset = sec_addr (htab->elf.sgot) + off;
+		      outrel.r_info =
+			ELF32_R_INFO (0, R_XR17032_RELATIVE);
+		      outrel.r_addend = relocation;
+		      relocation = 0;
+		      xr17032_elf_append_rela (output_bfd, s, &outrel);
+		    }
+
+		  bfd_put_32 (output_bfd, relocation,
+			      htab->elf.sgot->contents + off);
+		  local_got_offsets[r_symndx] |= 1;
+		}
+	    }
+
+	  if (rel->r_addend != 0)
+	    {
+	      msg = _("The addend isn't allowed for R_XR17032_HI16_GOT");
+	      r = bfd_reloc_dangerous;
+	    }
+	  else
+	    {
+	      /* Address of got entry.  */
+	      relocation = sec_addr (htab->elf.sgot) + off;
+	      /* Update howto if relocation is changed.  */
+	      howto = xr17032_elf_rtype_to_howto (input_bfd,
+						  ELF32_R_TYPE (rel->r_info));
+	      if (howto == NULL)
+		r = bfd_reloc_notsupported;
+	      else if (!xr17032_record_pcrel_hi_reloc (&pcrel_relocs, pc,
+						       relocation + rel->r_addend,
+						       r_type))
+		r = bfd_reloc_overflow;
+	    }
+	  break;
+
+	case R_XR17032_JUMP:
+	  /* Handle a jump to an undefined weak function.  This won't be
+	     relaxed, so we have to handle it here.  */
+	  if (h != NULL && h->root.type == bfd_link_hash_undefweak
+	      && (!bfd_link_pic (info) || h->plt.offset == (bfd_vma)-1))
+	    {
+	      relocation = 0;
+	    }
+
+	  if (bfd_link_pic (info) && h != NULL)
+	    {
+	      if (h->plt.offset != (bfd_vma)-1)
+		{
+		  /* Refer to the PLT entry.  */
+		  relocation = sec_addr (htab->elf.splt) + h->plt.offset;
+		  unresolved_reloc = false;
+		}
+	      else if (!SYMBOL_REFERENCES_LOCAL (info, h)
+		       && (input_section->flags & SEC_ALLOC) != 0
+		       && (input_section->flags & SEC_READONLY) != 0
+		       && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
+		{
+		  msg = bfd_asprintf (_("%%X%%P: relocation %s against `%s'"
+					" which may bind externally"
+					" can not be used"
+					" when making a shared object;"
+					" recompile with -fPIC\n"),
+				      howto->name, h->root.root.string);
+		  r = bfd_reloc_notsupported;
+		}
+	    }
+	  break;
+
+	case R_XR17032_HI16_TPREL:
+	  relocation = tpoff (info, relocation);
+	  break;
+
+	case R_XR17032_LO16_TPREL:
+	case R_XR17032_LO16_1_TPREL:
+	case R_XR17032_LO16_2_TPREL:
+	  relocation = tpoff (info, relocation);
+	  break;
+
+	case R_XR17032_HI16_PCREL:
+	  /* Update howto if relocation is changed.  */
+	  howto = xr17032_elf_rtype_to_howto (input_bfd,
+					      ELF32_R_TYPE (rel->r_info));
+	  if (howto == NULL)
+	    r = bfd_reloc_notsupported;
+	  else if (!xr17032_record_pcrel_hi_reloc (&pcrel_relocs, pc,
+						   relocation + rel->r_addend,
+						   r_type))
+	    r = bfd_reloc_overflow;
+	  break;
+
+	case R_XR17032_LO16_PCREL:
+	case R_XR17032_LO16_1_PCREL:
+	case R_XR17032_LO16_2_PCREL:
+	  /* We don't allow section symbols plus addends as the adr address.  */
+	  if (((sym != NULL && (ELF_ST_TYPE (sym->st_info) == STT_SECTION))
+	       || (h != NULL && h->type == STT_SECTION))
+	      && rel->r_addend)
+	    {
+	      msg = _("%pcrel_lo section symbol with an addend");
+	      r = bfd_reloc_dangerous;
+	      break;
+	    }
+
+	  if (xr17032_record_pcrel_lo_reloc (&pcrel_relocs, relocation, rel,
+					     input_section, info, howto,
+					     contents))
+	    continue;
+	  r = bfd_reloc_overflow;
+	  break;
+
+	case R_XR17032_TLS_DTPREL:
+	  relocation = dtpoff (info, relocation);
+	  break;
+
+	case R_XR17032_32:
+	  if ((input_section->flags & SEC_ALLOC) == 0)
+	    break;
+
+	  if (XR17032_GENERATE_DYNAMIC_RELOC (howto->pc_relative, info, h,
+					      resolved_to_zero))
+	    {
+	      Elf_Internal_Rela outrel;
+	      asection *sreloc;
+
+	      /* When generating a shared object, these relocations
+		 are copied into the output file to be resolved at run
+		 time.  */
+
+	      outrel.r_offset =
+		_bfd_elf_section_offset (output_bfd, info, input_section,
+					 rel->r_offset);
+	      bool skip = false;
+	      bool relocate = false;
+	      if (outrel.r_offset == (bfd_vma) -1)
+		skip = true;
+	      else if (outrel.r_offset == (bfd_vma) -2)
+		{
+		  skip = true;
+		  relocate = true;
+		}
+	      else if (h != NULL && bfd_is_abs_symbol (&h->root))
+		{
+		  /* Don't need dynamic reloc when the ABS symbol is
+		     non-dynamic or forced to local.  Maybe just use
+		     SYMBOL_REFERENCES_LOCAL to check?  */
+		  skip = (h->forced_local || (h->dynindx == -1));
+		  relocate = skip;
+		}
+
+	      outrel.r_offset += sec_addr (input_section);
+
+	      if (skip)
+		memset (&outrel, 0, sizeof outrel);	/* R_XR17032_NONE.  */
+	      else if (XR17032_COPY_INPUT_RELOC (info, h))
+		{
+		  /* Maybe just use !SYMBOL_REFERENCES_LOCAL to check?  */
+		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
+		  outrel.r_addend = rel->r_addend;
+		}
+	      else
+		{
+		  /* This symbol is local, or marked to become local.  */
+		  outrel.r_info = ELF32_R_INFO (0, R_XR17032_RELATIVE);
+		  outrel.r_addend = relocation + rel->r_addend;
+		}
+
+	      sreloc = elf_section_data (input_section)->sreloc;
+	      xr17032_elf_append_rela (output_bfd, sreloc, &outrel);
+	      if (!relocate)
+		continue;
+	    }
+	  break;
+
+	case R_XR17032_HI16_TLS_GOT:
+	  is_ie = true;
+	  goto tls;
+
+	case R_XR17032_HI16_TLS_GD:
+	tls:
+	  if (h != NULL)
+	    {
+	      off = h->got.offset;
+	      h->got.offset |= 1;
+	    }
+	  else
+	    {
+	      off = local_got_offsets[r_symndx];
+	      local_got_offsets[r_symndx] |= 1;
+	    }
+
+	  tls_type = _bfd_xr17032_elf_tls_type (input_bfd, h, r_symndx);
+	  BFD_ASSERT (tls_type & (GOT_TLS_IE | GOT_TLS_GD));
+	  /* When more than one TLS type is used, the GD slot comes first,
+	     then IE, then finally TLSDESC.  */
+	  ie_off = 0;
+	  if (tls_type & GOT_TLS_GD)
+	    ie_off += TLS_GD_GOT_ENTRY_SIZE;
+
+	  desc_off = ie_off;
+	  if (tls_type & GOT_TLS_IE)
+	    desc_off += TLS_IE_GOT_ENTRY_SIZE;
+
+	  if ((off & 1) != 0)
+	    off &= ~1;
+	  else
+	    {
+	      Elf_Internal_Rela outrel;
+	      int indx = 0;
+	      bool need_relocs = false;
+
+	      if (htab->elf.srelgot == NULL)
+		abort ();
+
+	      bool dyn = elf_hash_table (info)->dynamic_sections_created;
+	      XR17032_TLS_GD_IE_NEED_DYN_RELOC (info, dyn, h, indx, need_relocs);
+
+	      /* The GOT entries have not been initialized yet.  Do it
+		 now, and emit any relocations.  */
+	      if (tls_type & GOT_TLS_GD)
+		{
+		  if (need_relocs)
+		    {
+		      outrel.r_offset = sec_addr (htab->elf.sgot) + off;
+		      outrel.r_addend = 0;
+		      outrel.r_info = ELF32_R_INFO (indx, R_XR17032_TLS_DTPMOD);
+		      bfd_put_32 (output_bfd, 0,
+				  htab->elf.sgot->contents + off);
+		      xr17032_elf_append_rela (output_bfd, htab->elf.srelgot, &outrel);
+		      if (indx == 0)
+			{
+			  BFD_ASSERT (! unresolved_reloc);
+			  bfd_put_32 (output_bfd,
+				      dtpoff (info, relocation),
+				      (htab->elf.sgot->contents + off + 4));
+			}
+		      else
+			{
+			  bfd_put_32 (output_bfd, 0,
+				      (htab->elf.sgot->contents + off + 4));
+			  outrel.r_info = ELF32_R_INFO (indx, R_XR17032_TLS_DTPREL);
+			  outrel.r_offset += 4;
+			  xr17032_elf_append_rela (output_bfd, htab->elf.srelgot, &outrel);
+			}
+		    }
+		  else
+		    {
+		      /* If we are not emitting relocations for a
+			 general dynamic reference, then we must be in a
+			 static link or an executable link with the
+			 symbol binding locally.  Mark it as belonging
+			 to module 1, the executable.  */
+		      bfd_put_32 (output_bfd, 1,
+				  htab->elf.sgot->contents + off);
+		      bfd_put_32 (output_bfd,
+				  dtpoff (info, relocation),
+				  (htab->elf.sgot->contents + off + 4));
+		   }
+		}
+
+	      if (tls_type & GOT_TLS_IE)
+		{
+		  if (need_relocs)
+		    {
+		      bfd_put_32 (output_bfd, 0,
+				  htab->elf.sgot->contents + off + ie_off);
+		      outrel.r_offset = sec_addr (htab->elf.sgot)
+					+ off + ie_off;
+		      outrel.r_addend = 0;
+		      if (indx == 0)
+			outrel.r_addend = tpoff (info, relocation);
+		      outrel.r_info = ELF32_R_INFO (indx, R_XR17032_TLS_TPREL);
+		      xr17032_elf_append_rela (output_bfd, htab->elf.srelgot, &outrel);
+		    }
+		  else
+		    {
+		      bfd_put_32 (output_bfd, tpoff (info, relocation),
+				  htab->elf.sgot->contents + off + ie_off);
+		    }
+		}
+	    }
+
+	  BFD_ASSERT (off < (bfd_vma) -2);
+	  relocation = sec_addr (htab->elf.sgot) + off;
+	  if (is_ie)
+	    relocation += ie_off;
+	  else if (is_desc)
+	    relocation += desc_off;
+	  if (!xr17032_record_pcrel_hi_reloc (&pcrel_relocs, pc,
+					      relocation, r_type))
+	    r = bfd_reloc_overflow;
+	  unresolved_reloc = false;
+	  break;
+
+	default:
+	  r = bfd_reloc_notsupported;
+	}
+
+      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
+	 because such sections are not SEC_ALLOC and thus ld.so will
+	 not process them.  */
+      if (unresolved_reloc
+	  && !((input_section->flags & SEC_DEBUGGING) != 0
+	       && h->def_dynamic)
+	  && _bfd_elf_section_offset (output_bfd, info, input_section,
+				      rel->r_offset) != (bfd_vma) -1)
+	{
+	  msg = bfd_asprintf (_("%%X%%P: unresolvable %s relocation against "
+				"symbol `%s'\n"),
+			      howto->name,
+			      h->root.root.string);
+	  r = bfd_reloc_notsupported;
+	}
+
+ do_relocation:
+      if (r == bfd_reloc_ok)
+	r = perform_relocation (howto, rel, relocation, input_section,
+				input_bfd, contents);
+
+      /* We should have already detected the error and set message before.
+	 If the error message isn't set since the linker runs out of memory
+	 or we don't set it before, then we should set the default message
+	 with the "internal error" string here.  */
+      switch (r)
+	{
+	case bfd_reloc_ok:
+	  continue;
+
+	case bfd_reloc_overflow:
+	  info->callbacks->reloc_overflow
+	    (info, (h ? &h->root : NULL), name, howto->name,
+	     (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
+	  break;
+
+	case bfd_reloc_undefined:
+	  info->callbacks->undefined_symbol
+	    (info, name, input_bfd, input_section, rel->r_offset,
+	     true);
+	  break;
+
+	case bfd_reloc_outofrange:
+	  if (msg == NULL)
+	    msg = _("%X%P: internal error: out of range error\n");
+	  break;
+
+	case bfd_reloc_notsupported:
+	  if (msg == NULL)
+	    msg = _("%X%P: internal error: unsupported relocation error\n");
+	  break;
+
+	case bfd_reloc_dangerous:
+	  /* The error message should already be set.  */
+	  if (msg == NULL)
+	    msg = _("dangerous relocation error");
+	  info->callbacks->reloc_dangerous
+	    (info, msg, input_bfd, input_section, rel->r_offset);
+	  break;
+
+	default:
+	  msg = _("%X%P: internal error: unknown error\n");
+	  break;
+	}
+
+      /* Do not report error message for the dangerous relocation again.  */
+      if (msg && r != bfd_reloc_dangerous)
+	info->callbacks->einfo (msg);
+
+      /* We already reported the error via a callback, so don't try to report
+	 it again by returning false.  That leads to spurious errors.  */
+      ret = true;
+      goto out;
+    }
+
+  ret = xr17032_resolve_pcrel_lo_relocs (&pcrel_relocs);
+ out:
+  xr17032_free_pcrel_relocs (&pcrel_relocs);
+  return ret;
+}
+
+/* Generate a PLT header.  */
+
+static bool
+xr17032_make_plt_header (bfd_vma gotplt_addr, bfd_vma addr, uint32_t *entry)
+{
+  bfd_vma gotplt_offset_high = XR_IMM_HIGH_PART (gotplt_addr - addr);
+  bfd_vma gotplt_offset_low = XR_IMM_LOW_PART (gotplt_addr - addr);
+
+  /* adr  t2, %hi(.got.plt)
+     sub  t1, t1, t3                        # shifted .got.plt offset + hdr size + 12
+     mov  t3, long [t2 + %lo(.got.plt)]     # _dl_runtime_resolve
+     subi t1, t1, hdr size + 12             # shifted .got.plt offset
+     add  t1, zero, t1 RSH log2(16/4)       # .got.plt offset
+     mov  t0, long [t2 + %lo(.got.plt) + 4] # link map
+     jalr zero, t3, 0  */
+
+  entry[0] = XR_INSN_I_16P (ADR,  T2, gotplt_offset_high);
+  entry[1] = XR_INSN_R     (SUB,  T1, T1, T3, LSH, 0);
+  entry[2] = XR_INSN_I_2   (LL,   T3, T2, gotplt_offset_low);
+  entry[3] = XR_INSN_I     (SUBI, T1, T1, PLT_HEADER_SIZE + 12);
+  entry[4] = XR_INSN_R     (ADD,  T1, ZERO, T1, RSH, 2);
+  entry[5] = XR_INSN_I_2   (LL,   T0, T0, gotplt_offset_low + 4);
+  entry[6] = XR_INSN_I_2   (JALR, ZERO, T3, 0);
+
+  return true;
+}
+
+/* Generate a PLT entry.  */
+
+static bool
+xr17032_make_plt_entry (bfd_vma got, bfd_vma addr, uint32_t *entry)
+{
+
+  /* adr  t3, %hi(.got.plt entry)
+     mov  t3, long [t3 + %lo(.got.plt entry)]
+     jalr t1, t3, 0
+     nop  */
+
+  entry[0] = XR_INSN_I_16P (ADR,  T3, XR_IMM_HIGH_PART (got - addr));
+  entry[1] = XR_INSN_I_2   (LL,   T3, T3, XR_IMM_LOW_PART (got - addr));
+  entry[2] = XR_INSN_I_2   (JALR, T1, T3, 0);
+  entry[3] = XR_NOP;
+
+  return true;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static bool
+xr17032_elf_finish_dynamic_symbol (bfd *output_bfd,
+				   struct bfd_link_info *info,
+				   struct elf_link_hash_entry *h,
+				   Elf_Internal_Sym *sym)
+{
+  struct xr17032_elf_link_hash_table *htab = xr17032_elf_hash_table (info);
+  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
+
+  if (h->plt.offset != (bfd_vma) -1)
+    {
+      /* We've decided to create a PLT entry for this symbol.  */
+      bfd_byte *loc;
+      bfd_vma i, header_address, plt_idx, got_offset, got_address;
+      uint32_t plt_entry[PLT_ENTRY_INSNS];
+      Elf_Internal_Rela rela;
+      asection *plt, *gotplt, *relplt;
+
+      /* When building a static executable, use .iplt, .igot.plt and
+	 .rela.iplt sections for STT_GNU_IFUNC symbols.  */
+      if (htab->elf.splt != NULL)
+        {
+          plt = htab->elf.splt;
+          gotplt = htab->elf.sgotplt;
+          relplt = htab->elf.srelplt;
+        }
+      else
+        {
+          plt = htab->elf.iplt;
+          gotplt = htab->elf.igotplt;
+          relplt = htab->elf.irelplt;
+        }
+
+      /* This symbol has an entry in the procedure linkage table.  Set
+         it up.  */
+      if ((h->dynindx == -1
+	   && !((h->forced_local || bfd_link_executable (info))
+		&& h->def_regular
+		&& h->type == STT_GNU_IFUNC))
+	  || plt == NULL
+	  || gotplt == NULL
+	  || relplt == NULL)
+	abort ();
+
+      /* Calculate the address of the PLT header.  */
+      header_address = sec_addr (plt);
+
+      /* Calculate the index of the entry and the offset of .got.plt entry.
+	 For static executables, we don't reserve anything.  */
+      if (plt == htab->elf.splt)
+	{
+	  plt_idx = (h->plt.offset - PLT_HEADER_SIZE) / PLT_ENTRY_SIZE;
+	  got_offset = GOTPLT_HEADER_SIZE + (plt_idx * GOT_ENTRY_SIZE);
+	}
+      else
+	{
+	  plt_idx = h->plt.offset / PLT_ENTRY_SIZE;
+	  got_offset = plt_idx * GOT_ENTRY_SIZE;
+	}
+
+      /* Calculate the address of the .got.plt entry.  */
+      got_address = sec_addr (gotplt) + got_offset;
+
+      /* Find out where the .plt entry should go.  */
+      loc = plt->contents + h->plt.offset;
+
+      /* Fill in the PLT entry itself.  */
+      if (! xr17032_make_plt_entry (got_address, header_address + h->plt.offset,
+				    plt_entry))
+	return false;
+
+      for (i = 0; i < PLT_ENTRY_INSNS; i++)
+	bfd_putl32 (plt_entry[i], loc + 4*i);
+
+      /* Fill in the initial value of the .got.plt entry.  */
+      loc = gotplt->contents + (got_address - sec_addr (gotplt));
+      bfd_put_32 (output_bfd, sec_addr (plt), loc);
+
+      rela.r_offset = got_address;
+
+      if (h->dynindx == -1
+	  || ((bfd_link_executable (info)
+	       || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
+	      && h->def_regular
+	      && h->type == STT_GNU_IFUNC))
+	{
+	  info->callbacks->minfo (_("Local IFUNC function `%s' in %pB\n"),
+				  h->root.root.string,
+				  h->root.u.def.section->owner);
+
+	  /* If an STT_GNU_IFUNC symbol is locally defined, generate
+	     R_XR17032_IRELATIVE instead of R_XR17032_JUMP_SLOT.  */
+	  asection *sec = h->root.u.def.section;
+	  rela.r_info = ELF32_R_INFO (0, R_XR17032_IRELATIVE);
+	  rela.r_addend = h->root.u.def.value
+			  + sec->output_section->vma
+			  + sec->output_offset;
+	}
+      else
+	{
+	  /* Fill in the entry in the .rela.plt section.  */
+	  rela.r_info = ELF32_R_INFO (h->dynindx, R_XR17032_JUMP_SLOT);
+	  rela.r_addend = 0;
+	}
+
+      loc = relplt->contents + plt_idx * sizeof (Elf32_External_Rela);
+      bed->s->swap_reloca_out (output_bfd, &rela, loc);
+
+      if (!h->def_regular)
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value alone.  */
+	  sym->st_shndx = SHN_UNDEF;
+	  /* If the symbol is weak, we do need to clear the value.
+	     Otherwise, the PLT entry would provide a definition for
+	     the symbol even if the symbol wasn't defined anywhere,
+	     and so the symbol would never be NULL.  */
+	  if (!h->ref_regular_nonweak)
+	    sym->st_value = 0;
+	}
+    }
+
+  if (h->got.offset != (bfd_vma) -1
+      && !(xr17032_elf_hash_entry (h)->tls_type & (GOT_TLS_GD | GOT_TLS_IE))
+      && !UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))
+    {
+      asection *sgot;
+      asection *srela;
+      Elf_Internal_Rela rela;
+      bool use_elf_append_rela = true;
+
+      /* This symbol has an entry in the GOT.  Set it up.  */
+
+      sgot = htab->elf.sgot;
+      srela = htab->elf.srelgot;
+      BFD_ASSERT (sgot != NULL && srela != NULL);
+
+      rela.r_offset = sec_addr (sgot) + (h->got.offset &~ (bfd_vma) 1);
+
+      /* Handle the ifunc symbol in GOT entry.  */
+      if (h->def_regular
+	  && h->type == STT_GNU_IFUNC)
+	{
+	  if (h->plt.offset == (bfd_vma) -1)
+	    {
+	      /* STT_GNU_IFUNC is referenced without PLT.  */
+
+	      if (htab->elf.splt == NULL)
+		{
+		  /* Use .rela.iplt section to store .got relocations
+		     in static executable.  */
+		  srela = htab->elf.irelplt;
+
+		  /* Do not use xr17032_elf_append_rela to add dynamic
+		     relocs.  */
+		  use_elf_append_rela = false;
+		}
+
+	      if (SYMBOL_REFERENCES_LOCAL (info, h))
+		{
+		  info->callbacks->minfo (_("Local IFUNC function `%s' in %pB\n"),
+					  h->root.root.string,
+					  h->root.u.def.section->owner);
+
+		  rela.r_info = ELF32_R_INFO (0, R_XR17032_IRELATIVE);
+		  rela.r_addend = (h->root.u.def.value
+				   + h->root.u.def.section->output_section->vma
+				   + h->root.u.def.section->output_offset);
+		}
+	      else
+		{
+		  /* Generate R_XR17032_32.  */
+		  BFD_ASSERT ((h->got.offset & 1) == 0);
+		  BFD_ASSERT (h->dynindx != -1);
+		  rela.r_info = ELF32_R_INFO (h->dynindx, R_XR17032_32);
+		  rela.r_addend = 0;
+		}
+	    }
+	  else if (bfd_link_pic (info))
+	    {
+	      /* Generate R_XR17032_32.  */
+	      BFD_ASSERT ((h->got.offset & 1) == 0);
+	      BFD_ASSERT (h->dynindx != -1);
+	      rela.r_info = ELF32_R_INFO (h->dynindx, R_XR17032_32);
+	      rela.r_addend = 0;
+	    }
+	  else
+	    {
+	      asection *plt;
+
+	      if (!h->pointer_equality_needed)
+		abort ();
+
+	      /* For non-shared object, we can't use .got.plt, which
+		 contains the real function address if we need pointer
+		 equality.  We load the GOT entry with the PLT entry.  */
+	      plt = htab->elf.splt ? htab->elf.splt : htab->elf.iplt;
+	      bfd_put_32 (output_bfd, (plt->output_section->vma
+				       + plt->output_offset
+				       + h->plt.offset),
+			  htab->elf.sgot->contents
+			  + (h->got.offset & ~(bfd_vma) 1));
+	      return true;
+	    }
+	}
+      else if (bfd_link_pic (info)
+	       && SYMBOL_REFERENCES_LOCAL (info, h))
+	{
+	  /* If this is a local symbol reference, we just want to emit
+	     a RELATIVE reloc.  This can happen if it is a -Bsymbolic link,
+	     or a pie link, or the symbol was forced to be local because
+	     of a version file.  The entry in the global offset table will
+	     already have been initialized in the relocate_section function.  */
+	  BFD_ASSERT ((h->got.offset & 1) != 0);
+	  asection *sec = h->root.u.def.section;
+	  rela.r_info = ELF32_R_INFO (0, R_XR17032_RELATIVE);
+	  rela.r_addend = (h->root.u.def.value
+			   + sec->output_section->vma
+			   + sec->output_offset);
+	}
+      else
+	{
+	  BFD_ASSERT ((h->got.offset & 1) == 0);
+	  BFD_ASSERT (h->dynindx != -1);
+	  rela.r_info = ELF32_R_INFO (h->dynindx, R_XR17032_32);
+	  rela.r_addend = 0;
+	}
+
+      bfd_put_32 (output_bfd, 0,
+		  sgot->contents + (h->got.offset & ~(bfd_vma) 1));
+
+      if (use_elf_append_rela)
+	xr17032_elf_append_rela (output_bfd, srela, &rela);
+      else
+	{
+	  /* Use xr17032_elf_append_rela to add the dynamic relocs into
+	     .rela.iplt may cause the overwrite problems.  Since we insert
+	     the relocs for PLT didn't handle the reloc_index of .rela.iplt,
+	     but the xr17032_elf_append_rela adds the relocs to the place
+	     that are calculated from the reloc_index (in seqential).
+
+	     One solution is that add these dynamic relocs (GOT IFUNC)
+	     from the last of .rela.iplt section.  */
+	  bfd_vma iplt_idx = htab->last_iplt_index--;
+	  bfd_byte *loc = srela->contents
+			  + iplt_idx * sizeof (Elf32_External_Rela);
+	  bed->s->swap_reloca_out (output_bfd, &rela, loc);
+	}
+    }
+
+  if (h->needs_copy)
+    {
+      Elf_Internal_Rela rela;
+      asection *s;
+
+      /* This symbols needs a copy reloc.  Set it up.  */
+      BFD_ASSERT (h->dynindx != -1);
+
+      rela.r_offset = sec_addr (h->root.u.def.section) + h->root.u.def.value;
+      rela.r_info = ELF32_R_INFO (h->dynindx, R_XR17032_COPY);
+      rela.r_addend = 0;
+      if (h->root.u.def.section == htab->elf.sdynrelro)
+	s = htab->elf.sreldynrelro;
+      else
+	s = htab->elf.srelbss;
+      xr17032_elf_append_rela (output_bfd, s, &rela);
+    }
+
+  /* Mark some specially defined symbols as absolute.  */
+  if (h == htab->elf.hdynamic
+      || (h == htab->elf.hgot || h == htab->elf.hplt))
+    sym->st_shndx = SHN_ABS;
+
+  return true;
+}
+
+/* Finish up local dynamic symbol handling.  We set the contents of
+   various dynamic sections here.  */
+
+static int
+xr17032_elf_finish_local_dynamic_symbol (void **slot, void *inf)
+{
+  struct elf_link_hash_entry *h = (struct elf_link_hash_entry *) *slot;
+  struct bfd_link_info *info = (struct bfd_link_info *) inf;
+
+  return xr17032_elf_finish_dynamic_symbol (info->output_bfd, info, h, NULL);
+}
+
+/* Finish up the dynamic sections.  */
+
+static bool
+xr17032_finish_dyn (bfd *output_bfd, struct bfd_link_info *info,
+		    bfd *dynobj, asection *sdyn)
+{
+  struct xr17032_elf_link_hash_table *htab = xr17032_elf_hash_table (info);
+  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
+  size_t dynsize = bed->s->sizeof_dyn;
+  bfd_byte *dyncon, *dynconend;
+
+  dynconend = sdyn->contents + sdyn->size;
+  for (dyncon = sdyn->contents; dyncon < dynconend; dyncon += dynsize)
+    {
+      Elf_Internal_Dyn dyn;
+      asection *s;
+
+      bed->s->swap_dyn_in (dynobj, dyncon, &dyn);
+
+      switch (dyn.d_tag)
+	{
+	case DT_PLTGOT:
+	  s = htab->elf.sgotplt;
+	  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	  break;
+	case DT_JMPREL:
+	  s = htab->elf.srelplt;
+	  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	  break;
+	case DT_PLTRELSZ:
+	  s = htab->elf.srelplt;
+	  dyn.d_un.d_val = s->size;
+	  break;
+	default:
+	  continue;
+	}
+
+      bed->s->swap_dyn_out (output_bfd, &dyn, dyncon);
+    }
+  return true;
+}
+
+static bool
+xr17032_elf_finish_dynamic_sections (bfd *output_bfd,
+				     struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  asection *sdyn;
+  struct xr17032_elf_link_hash_table *htab;
+
+  htab = xr17032_elf_hash_table (info);
+  BFD_ASSERT (htab != NULL);
+  dynobj = htab->elf.dynobj;
+
+  sdyn = bfd_get_linker_section (dynobj, ".dynamic");
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      asection *splt;
+      bool ret;
+
+      splt = htab->elf.splt;
+      BFD_ASSERT (splt != NULL && sdyn != NULL);
+
+      ret = xr17032_finish_dyn (output_bfd, info, dynobj, sdyn);
+
+      if (!ret)
+	return ret;
+
+      /* Fill in the head and tail entries in the procedure linkage table.  */
+      if (splt->size > 0)
+	{
+	  int i;
+	  uint32_t plt_header[PLT_HEADER_INSNS];
+	  ret = xr17032_make_plt_header (sec_addr (htab->elf.sgotplt),
+				         sec_addr (splt), plt_header);
+	  if (!ret)
+	    return ret;
+
+	  for (i = 0; i < PLT_HEADER_INSNS; i++)
+	    bfd_putl32 (plt_header[i], splt->contents + 4*i);
+
+	  elf_section_data (splt->output_section)->this_hdr.sh_entsize
+	    = PLT_ENTRY_SIZE;
+	}
+    }
+
+  if (htab->elf.sgotplt && htab->elf.sgotplt->size > 0)
+    {
+      asection *output_section = htab->elf.sgotplt->output_section;
+
+      if (bfd_is_abs_section (output_section))
+	{
+	  (*_bfd_error_handler)
+	    (_("discarded output section: `%pA'"), htab->elf.sgotplt);
+	  return false;
+	}
+
+      /* Write the first two entries in .got.plt, needed for the dynamic
+	 linker.  */
+      bfd_put_32 (output_bfd, (bfd_vma) -1, htab->elf.sgotplt->contents);
+      bfd_put_32 (output_bfd, (bfd_vma) 0,
+		  htab->elf.sgotplt->contents + GOT_ENTRY_SIZE);
+
+      elf_section_data (output_section)->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
+    }
+
+  if (htab->elf.sgot && htab->elf.sgot->size > 0)
+    {
+      asection *output_section = htab->elf.sgot->output_section;
+
+      if (!bfd_is_abs_section (output_section))
+	{
+	  /* Set the first entry in the global offset table to the address of
+	     the dynamic section.  */
+	  bfd_vma val = sdyn ? sec_addr (sdyn) : 0;
+	  bfd_put_32 (output_bfd, val, htab->elf.sgot->contents);
+
+	  elf_section_data (output_section)->this_hdr.sh_entsize = GOT_ENTRY_SIZE;
+	}
+    }
+
+  /* Fill PLT and GOT entries for local STT_GNU_IFUNC symbols.  */
+  htab_traverse (htab->loc_hash_table,
+		 xr17032_elf_finish_local_dynamic_symbol,
+		 info);
+
+  return true;
+}
+
+/* Return address for Ith PLT stub in section PLT, for relocation REL
+   or (bfd_vma) -1 if it should not be included.  */
+
+static bfd_vma
+xr17032_elf_plt_sym_val (bfd_vma i, const asection *plt,
+			 const arelent *rel ATTRIBUTE_UNUSED)
+{
+  return plt->vma + PLT_HEADER_SIZE + i * PLT_ENTRY_SIZE;
+}
+
+#define PRSTATUS_SIZE			204
+#define PRSTATUS_OFFSET_PR_CURSIG	12
+#define PRSTATUS_OFFSET_PR_PID		24
+#define PRSTATUS_OFFSET_PR_REG		72
+#define ELF_GREGSET_T_SIZE		128
+#define PRPSINFO_SIZE			128
+#define PRPSINFO_OFFSET_PR_PID		16
+#define PRPSINFO_OFFSET_PR_FNAME	32
+#define PRPSINFO_OFFSET_PR_PSARGS	48
+#define PRPSINFO_PR_FNAME_LENGTH	16
+#define PRPSINFO_PR_PSARGS_LENGTH	80
+
+/* Support for core dump NOTE sections.  */
+
+static bool
+xr17032_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+      default:
+	return false;
+
+      case PRSTATUS_SIZE: /* sizeof(struct elf_prstatus) on Linux/RISC-V.  */
+	/* pr_cursig */
+	elf_tdata (abfd)->core->signal
+	  = bfd_get_16 (abfd, note->descdata + PRSTATUS_OFFSET_PR_CURSIG);
+
+	/* pr_pid */
+	elf_tdata (abfd)->core->lwpid
+	  = bfd_get_32 (abfd, note->descdata + PRSTATUS_OFFSET_PR_PID);
+	break;
+    }
+
+  /* Make a ".reg/999" section.  */
+  return _bfd_elfcore_make_pseudosection (abfd, ".reg", ELF_GREGSET_T_SIZE,
+					  note->descpos + PRSTATUS_OFFSET_PR_REG);
+}
+
+static bool
+xr17032_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+      default:
+	return false;
+
+      case PRPSINFO_SIZE: /* sizeof(struct elf_prpsinfo) on Linux/RISC-V.  */
+	/* pr_pid */
+	elf_tdata (abfd)->core->pid
+	  = bfd_get_32 (abfd, note->descdata + PRPSINFO_OFFSET_PR_PID);
+
+	/* pr_fname */
+	elf_tdata (abfd)->core->program = _bfd_elfcore_strndup
+	  (abfd, note->descdata + PRPSINFO_OFFSET_PR_FNAME,
+           PRPSINFO_PR_FNAME_LENGTH);
+
+	/* pr_psargs */
+	elf_tdata (abfd)->core->command = _bfd_elfcore_strndup
+	  (abfd, note->descdata + PRPSINFO_OFFSET_PR_PSARGS,
+           PRPSINFO_PR_PSARGS_LENGTH);
+	break;
+    }
+
+  /* Note that for some reason, a spurious space is tacked
+     onto the end of the args in some (at least one anyway)
+     implementations, so strip it off if it exists.  */
+
+  {
+    char *command = elf_tdata (abfd)->core->command;
+    int n = strlen (command);
+
+    if (0 < n && command[n - 1] == ' ')
+      command[n - 1] = '\0';
+  }
+
+  return true;
+}
+
+/* Write PRSTATUS and PRPSINFO note into core file.  This will be called
+   before the generic code in elf.c.  By checking the compiler defines we
+   only perform any action here if the generic code would otherwise not be
+   able to help us.  The intention is that bare metal core dumps (where the
+   prstatus_t and/or prpsinfo_t might not be available) will use this code,
+   while non bare metal tools will use the generic elf code.  */
+
+static char *
+xr17032_write_core_note (bfd *abfd ATTRIBUTE_UNUSED,
+                         char *buf ATTRIBUTE_UNUSED,
+                         int *bufsiz ATTRIBUTE_UNUSED,
+                         int note_type ATTRIBUTE_UNUSED, ...)
+{
+  switch (note_type)
+    {
+    default:
+      return NULL;
+
+#if !defined (HAVE_PRPSINFO_T)
+    case NT_PRPSINFO:
+      {
+	char data[PRPSINFO_SIZE] ATTRIBUTE_NONSTRING;
+	va_list ap;
+
+	va_start (ap, note_type);
+	memset (data, 0, sizeof (data));
+	strncpy (data + PRPSINFO_OFFSET_PR_FNAME, va_arg (ap, const char *),
+                 PRPSINFO_PR_FNAME_LENGTH);
+#if GCC_VERSION == 8000 || GCC_VERSION == 8001
+	DIAGNOSTIC_PUSH;
+	/* GCC 8.0 and 8.1 warn about 80 equals destination size with
+	   -Wstringop-truncation:
+	   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85643
+	 */
+	DIAGNOSTIC_IGNORE_STRINGOP_TRUNCATION;
+#endif
+	strncpy (data + PRPSINFO_OFFSET_PR_PSARGS, va_arg (ap, const char *),
+                 PRPSINFO_PR_PSARGS_LENGTH);
+#if GCC_VERSION == 8000 || GCC_VERSION == 8001
+	DIAGNOSTIC_POP;
+#endif
+	va_end (ap);
+	return elfcore_write_note (abfd, buf, bufsiz,
+				   "CORE", note_type, data, sizeof (data));
+      }
+#endif /* !HAVE_PRPSINFO_T */
+
+#if !defined (HAVE_PRSTATUS_T)
+    case NT_PRSTATUS:
+      {
+        char data[PRSTATUS_SIZE];
+        va_list ap;
+        long pid;
+        int cursig;
+        const void *greg;
+
+        va_start (ap, note_type);
+        memset (data, 0, sizeof(data));
+        pid = va_arg (ap, long);
+        bfd_put_32 (abfd, pid, data + PRSTATUS_OFFSET_PR_PID);
+        cursig = va_arg (ap, int);
+        bfd_put_16 (abfd, cursig, data + PRSTATUS_OFFSET_PR_CURSIG);
+        greg = va_arg (ap, const void *);
+        memcpy (data + PRSTATUS_OFFSET_PR_REG, greg,
+                PRSTATUS_SIZE - PRSTATUS_OFFSET_PR_REG - 4);
+        va_end (ap);
+        return elfcore_write_note (abfd, buf, bufsiz,
+                                   "CORE", note_type, data, sizeof (data));
+      }
+#endif /* !HAVE_PRSTATUS_T */
+    }
+}
+
+static bool
+xr17032_info_to_howto_rela (bfd *abfd,
+			    arelent *cache_ptr,
+			    Elf_Internal_Rela *dst)
+{
+  cache_ptr->howto = xr17032_elf_rtype_to_howto (abfd, ELF32_R_TYPE (dst->r_info));
+  return cache_ptr->howto != NULL;
+}
+
+#define ELF_ARCH				bfd_arch_xr17032
+#define ELF_TARGET_ID				XR17032_ELF_DATA
+#define ELF_MACHINE_CODE			EM_XR17032
+#define ELF_MAXPAGESIZE				0x1000
+#define ELF_COMMONPAGESIZE			0x1000
+
+#define TARGET_LITTLE_SYM			xr17032_elf32_vec
+#define TARGET_LITTLE_NAME			"elf32-xr17032"
+
+#define bfd_elf32_bfd_reloc_name_lookup		xr17032_reloc_name_lookup
+#define bfd_elf32_bfd_reloc_type_lookup		xr17032_reloc_type_lookup
+#define bfd_elf32_bfd_link_hash_table_create	\
+  xr17032_elf_link_hash_table_create
+#define bfd_elf32_bfd_is_target_special_symbol	\
+  xr17032_elf_is_target_special_symbol
+#define bfd_elf32_mkobject			elf32_xr17032_mkobject
+
+#define elf_backend_reloc_type_class		xr17032_reloc_type_class
+#define elf_backend_copy_indirect_symbol	xr17032_elf_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections	\
+  xr17032_elf_create_dynamic_sections
+#define elf_backend_check_relocs		xr17032_elf_check_relocs
+#define elf_backend_adjust_dynamic_symbol	\
+  xr17032_elf_adjust_dynamic_symbol
+#define elf_backend_late_size_sections		xr17032_elf_late_size_sections
+#define elf_backend_relocate_section		xr17032_elf_relocate_section
+#define elf_backend_finish_dynamic_symbol	\
+  xr17032_elf_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections	\
+  xr17032_elf_finish_dynamic_sections
+#define elf_backend_plt_sym_val			xr17032_elf_plt_sym_val
+#define elf_backend_grok_prstatus		xr17032_elf_grok_prstatus
+#define elf_backend_grok_psinfo			xr17032_elf_grok_psinfo
+#define elf_backend_write_core_note		xr17032_write_core_note
+#define elf_info_to_howto_rel			NULL
+#define elf_info_to_howto			xr17032_info_to_howto_rela
+
+#define elf_backend_init_index_section		_bfd_elf_init_1_index_section
+
+#define elf_backend_can_gc_sections		1
+#define elf_backend_can_refcount		1
+#define elf_backend_want_got_plt		1
+#define elf_backend_plt_readonly		1
+#define elf_backend_plt_alignment		4
+#define elf_backend_want_plt_sym		1
+#define elf_backend_got_header_size		4
+#define elf_backend_want_dynrelro		1
+#define elf_backend_rela_normal			1
+#define elf_backend_default_execstack		0
+
+#include "elf32-target.h"
diff -urN --no-dereference binutils-clean/bfd/libbfd.h binutils-workdir/bfd/libbfd.h
--- binutils-clean/bfd/libbfd.h
+++ binutils-workdir/bfd/libbfd.h
@@ -2910,6 +2910,33 @@
   "BFD_RELOC_IQ2000_OFFSET_16",
   "BFD_RELOC_IQ2000_OFFSET_21",
   "BFD_RELOC_IQ2000_UHI16",
+  "BFD_RELOC_XR17032_TLS_TPREL",
+  "BFD_RELOC_XR17032_TLS_DTPMOD",
+  "BFD_RELOC_XR17032_TLS_DTPREL",
+  "BFD_RELOC_XR17032_JUMP",
+  "BFD_RELOC_XR17032_BRANCH",
+  "BFD_RELOC_XR17032_IMM16",
+  "BFD_RELOC_XR17032_IMM16_1",
+  "BFD_RELOC_XR17032_IMM16_2",
+  "BFD_RELOC_XR17032_IMM16_16",
+  "BFD_RELOC_XR17032_IMM16_SIGNED",
+  "BFD_RELOC_XR17032_LO16",
+  "BFD_RELOC_XR17032_LO16_1",
+  "BFD_RELOC_XR17032_LO16_2",
+  "BFD_RELOC_XR17032_HI16",
+  "BFD_RELOC_XR17032_LO16_PCREL",
+  "BFD_RELOC_XR17032_LO16_1_PCREL",
+  "BFD_RELOC_XR17032_LO16_2_PCREL",
+  "BFD_RELOC_XR17032_HI16_PCREL",
+  "BFD_RELOC_XR17032_HI16_GOT",
+  "BFD_RELOC_XR17032_HI16_PLT",
+  "BFD_RELOC_XR17032_HI16_TLS_GOT",
+  "BFD_RELOC_XR17032_HI16_TLS_GD",
+  "BFD_RELOC_XR17032_LO16_TPREL",
+  "BFD_RELOC_XR17032_LO16_1_TPREL",
+  "BFD_RELOC_XR17032_LO16_2_TPREL",
+  "BFD_RELOC_XR17032_HI16_TPREL",
+  "BFD_RELOC_XR17032_CFA",
   "BFD_RELOC_XTENSA_RTLD",
   "BFD_RELOC_XTENSA_GLOB_DAT",
   "BFD_RELOC_XTENSA_JMP_SLOT",
diff -urN --no-dereference binutils-clean/bfd/reloc.c binutils-workdir/bfd/reloc.c
--- binutils-clean/bfd/reloc.c
+++ binutils-workdir/bfd/reloc.c
@@ -6244,6 +6244,63 @@
   IQ2000 Relocations.
 
 ENUM
+  BFD_RELOC_XR17032_TLS_TPREL
+ENUMX
+  BFD_RELOC_XR17032_TLS_DTPMOD
+ENUMX
+  BFD_RELOC_XR17032_TLS_DTPREL
+ENUMX
+  BFD_RELOC_XR17032_JUMP
+ENUMX
+  BFD_RELOC_XR17032_BRANCH
+ENUMX
+  BFD_RELOC_XR17032_IMM16
+ENUMX
+  BFD_RELOC_XR17032_IMM16_1
+ENUMX
+  BFD_RELOC_XR17032_IMM16_2
+ENUMX
+  BFD_RELOC_XR17032_IMM16_16
+ENUMX
+  BFD_RELOC_XR17032_IMM16_SIGNED
+ENUMX
+  BFD_RELOC_XR17032_LO16
+ENUMX
+  BFD_RELOC_XR17032_LO16_1
+ENUMX
+  BFD_RELOC_XR17032_LO16_2
+ENUMX
+  BFD_RELOC_XR17032_HI16
+ENUMX
+  BFD_RELOC_XR17032_LO16_PCREL
+ENUMX
+  BFD_RELOC_XR17032_LO16_1_PCREL
+ENUMX
+  BFD_RELOC_XR17032_LO16_2_PCREL
+ENUMX
+  BFD_RELOC_XR17032_HI16_PCREL
+ENUMX
+  BFD_RELOC_XR17032_HI16_GOT
+ENUMX
+  BFD_RELOC_XR17032_HI16_PLT
+ENUMX
+  BFD_RELOC_XR17032_HI16_TLS_GOT
+ENUMX
+  BFD_RELOC_XR17032_HI16_TLS_GD
+ENUMX
+  BFD_RELOC_XR17032_LO16_TPREL
+ENUMX
+  BFD_RELOC_XR17032_LO16_1_TPREL
+ENUMX
+  BFD_RELOC_XR17032_LO16_2_TPREL
+ENUMX
+  BFD_RELOC_XR17032_HI16_TPREL
+ENUMX
+  BFD_RELOC_XR17032_CFA
+ENUMDOC
+  XR/17032 Relocations.
+
+ENUM
   BFD_RELOC_XTENSA_RTLD
 ENUMDOC
   Special Xtensa relocation used only by PLT entries in ELF shared
diff -urN --no-dereference binutils-clean/bfd/targets.c binutils-workdir/bfd/targets.c
--- binutils-clean/bfd/targets.c
+++ binutils-workdir/bfd/targets.c
@@ -946,6 +946,7 @@
 extern const bfd_target x86_64_pe_big_vec;
 extern const bfd_target x86_64_pei_vec;
 extern const bfd_target xgate_elf32_vec;
+extern const bfd_target xr17032_elf32_vec;
 extern const bfd_target xstormy16_elf32_vec;
 extern const bfd_target xtensa_elf32_be_vec;
 extern const bfd_target xtensa_elf32_le_vec;
@@ -1361,6 +1362,8 @@
 
 	&xgate_elf32_vec,
 
+	&xr17032_elf32_vec,
+
 	&xstormy16_elf32_vec,
 
 	&xtensa_elf32_be_vec,
diff -urN --no-dereference binutils-clean/binutils/readelf.c binutils-workdir/binutils/readelf.c
--- binutils-clean/binutils/readelf.c
+++ binutils-workdir/binutils/readelf.c
@@ -165,6 +165,7 @@
 #include "elf/wasm32.h"
 #include "elf/x86-64.h"
 #include "elf/xgate.h"
+#include "elf/xr17032.h"
 #include "elf/xstormy16.h"
 #include "elf/xtensa.h"
 #include "elf/z80.h"
@@ -1208,6 +1209,7 @@
     case EM_XGATE:
     case EM_NFP:
     case EM_BPF:
+    case EM_XR17032:
       return false;
 
       /* Targets that use RELA relocations.  */
@@ -2395,6 +2397,10 @@
 	case EM_AMDGPU:
 	  rtype = elf_amdgpu_reloc_type (type);
 	  break;
+
+	case EM_XR17032:
+	  rtype = elf_xr17032_reloc_type (type);
+	  break;
 	}
 
       if (rtype == NULL)
@@ -3452,6 +3458,7 @@
     case EM_ADAPTEVA_EPIPHANY:	return "Adapteva EPIPHANY";
     case EM_CYGNUS_FRV:		return "Fujitsu FR-V";
     case EM_S12Z:               return "Freescale S12Z";
+    case EM_XR17032:		return "XR/17032";
 
     default:
       snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
@@ -11656,6 +11663,7 @@
     { EM_TI_C6000, arm_process_unwind },
     { EM_386, no_processor_specific_unwind },
     { EM_X86_64, no_processor_specific_unwind },
+    { EM_XR17032, no_processor_specific_unwind },
     { 0, NULL }
   };
   int i;
@@ -15569,6 +15577,8 @@
       return reloc_type == 10; /* R_X86_64_32.  */
     case EM_XGATE:
       return reloc_type == 4; /* R_XGATE_32.  */
+    case EM_XR17032:
+      return reloc_type == 13; /* R_XR17032_ABS32. */
     case EM_XSTORMY16:
       return reloc_type == 1; /* R_XSTROMY16_32.  */
     case EM_XTENSA_OLD:
@@ -15657,6 +15667,8 @@
       return reloc_type == 2;  /* R_X86_64_PC32.  */
     case EM_VAX:
       return reloc_type == 4;  /* R_VAX_PCREL32.  */
+    case EM_XR17032:
+      return reloc_type == 16; /* R_XR17032_PCREL32. */
     case EM_XTENSA_OLD:
     case EM_XTENSA:
       return reloc_type == 14; /* R_XTENSA_32_PCREL.  */
@@ -16108,6 +16120,7 @@
     case EM_TILEPRO: /* R_TILEPRO_NONE.  */
     case EM_TI_C6000:/* R_C6000_NONE.  */
     case EM_X86_64:  /* R_X86_64_NONE.  */
+    case EM_XR17032: /* R_XR17032_NONE. */
     case EM_Z80:     /* R_Z80_NONE. */
     case EM_WEBASSEMBLY: /* R_WASM32_NONE.  */
       return reloc_type == 0;
diff -urN --no-dereference binutils-clean/gas/Makefile.am binutils-workdir/gas/Makefile.am
--- binutils-clean/gas/Makefile.am
+++ binutils-workdir/gas/Makefile.am
@@ -210,6 +210,7 @@
 	config/tc-vax.c \
 	config/tc-visium.c \
 	config/tc-wasm32.c \
+	config/tc-xr17032.c \
 	config/tc-xstormy16.c \
 	config/tc-xgate.c \
 	config/tc-xtensa.c \
@@ -283,6 +284,7 @@
 	config/tc-vax.h \
 	config/tc-visium.h \
 	config/tc-wasm32.h \
+	config/tc-xr17032.h \
 	config/tc-xstormy16.h \
 	config/tc-xgate.h \
 	config/tc-xtensa.h \
diff -urN --no-dereference binutils-clean/gas/config/tc-xr17032.c binutils-workdir/gas/config/tc-xr17032.c
--- binutils-clean/gas/config/tc-xr17032.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/gas/config/tc-xr17032.c
@@ -0,0 +1,1371 @@
+/* tc-xr17032.c -- Assembler code for the XR/17032 CPU core.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+
+   Contributed by monkuous
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "as.h"
+#include "config.h"
+#include "subsegs.h"
+#include "safe-ctype.h"
+
+#include "itbl-ops.h"
+#include "dwarf2dbg.h"
+#include "dw2gencfi.h"
+
+#include "elf/xr17032.h"
+#include "opcode/xr17032.h"
+
+#include <stdint.h>
+
+/* Chars that mean this number is a floating point constant.
+   As in 0f12.456 or 0d1.2345e12.  */
+const char FLT_CHARS[] = "rRsSfFdDxXpPhH";
+
+const char md_shortopts[] = "";
+
+const struct option md_longopts[] =
+{
+  {NULL, no_argument, NULL, 0}
+};
+const size_t md_longopts_size = sizeof (md_longopts);
+
+/* Handle of the OPCODE hash table.  */
+static htab_t op_hash = NULL;
+
+static htab_t reg_names_hash = NULL;
+static htab_t control_reg_names_hash = NULL;
+static htab_t shift_op_names_hash = NULL;
+static htab_t mem_size_names_hash = NULL;
+
+/* This array holds the chars that always start a comment.  If the
+   pre-processor is disabled, these aren't very useful.  */
+const char comment_chars[] = "#";
+
+/* This array holds the chars that only start a comment at the beginning of
+   a line.  If the line seems to have the form '# 123 filename'
+   .line and .file directives will appear in the pre-processed output
+
+   Note that input_file.c hand checks for '#' at the beginning of the
+   first line of the input file.  This is because the compiler outputs
+   #NO_APP at the beginning of its output.
+
+   Also note that C style comments are always supported.  */
+const char line_comment_chars[] = "#";
+
+/* This array holds machine specific line separator characters.  */
+const char line_separator_chars[] = ";";
+
+/* Chars that can be used to separate mant from exp in floating point nums.  */
+const char EXP_CHARS[] = "eE";
+
+static bool probing_insn_operands;
+
+static symbolS *deferred_sym_rootP;
+static symbolS *deferred_sym_lastP;
+/* Since symbols can't easily be freed, try to recycle ones which weren't
+   committed.  */
+static symbolS *orphan_sym_rootP;
+static symbolS *orphan_sym_lastP;
+
+static char *expr_parse_end;
+
+void
+md_number_to_chars (char *buf, valueT val, int n)
+{
+  number_to_chars_littleendian (buf, val, n);
+}
+
+int
+md_parse_option (int c ATTRIBUTE_UNUSED, const char *arg ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+/* Common hash table initialization function for instruction.  */
+
+static htab_t
+init_opcode_hash (const xr17032_opcode *opcodes)
+{
+  int i = 0;
+  htab_t hash = str_htab_create ();
+
+  while (opcodes[i].mnemonic)
+    {
+      const char *name = opcodes[i].mnemonic;
+      if (str_hash_insert (hash, name, &opcodes[i], 0) != NULL)
+	as_fatal (_("internal: duplicate %s"), name);
+
+      do
+	{
+	  ++i;
+	}
+      while (opcodes[i].mnemonic && !strcmp (opcodes[i].mnemonic, name));
+    }
+
+  return hash;
+}
+
+static void
+hash_reg_name (htab_t htab, const char *name, unsigned n)
+{
+  if (!name)
+    return;
+  void *hash = (void *)(uintptr_t)(n + 1);
+  if (str_hash_insert (htab, name, hash, 0) != NULL)
+    as_fatal (_("internal: duplicate %s"), name);
+}
+
+static void
+hash_reg_names (htab_t htab, const char *const *names)
+{
+  unsigned i;
+
+  for (i = 0; i < XR_NUM_REGISTERS; i++)
+    hash_reg_name (htab, names[i], i);
+}
+
+/* Record all PC-relative high-part relocation that we have encountered to
+   help us resolve the corresponding low-part relocation later.  */
+typedef struct
+{
+  const asection *sec;
+  bfd_vma address;
+  symbolS *symbol;
+  bfd_vma target;
+} xr17032_pcrel_hi_fixup;
+
+/* Handle of the pcrel_hi hash table.  */
+static htab_t xr17032_pcrel_hi_fixup_hash;
+
+/* Get the key of a entry from the pcrel_hi hash table.  */
+
+static hashval_t
+xr17032_pcrel_fixup_hash (const void *entry)
+{
+  const xr17032_pcrel_hi_fixup *e = entry;
+
+  /* the pcrel_hi with same address may reside in different segments,
+     to ensure uniqueness, the segment ID needs to be included in the
+     hash key calculation.
+     Temporarily using the prime number 499 as a multiplier, but it
+     might not be large enough.  */
+  return e->address + 499 * e->sec->id;
+}
+
+/* Compare the keys between two entries fo the pcrel_hi hash table.  */
+
+static int
+xr17032_pcrel_fixup_eq (const void *entry1, const void *entry2)
+{
+  const xr17032_pcrel_hi_fixup *e1 = entry1, *e2 = entry2;
+  return e1->sec->id == e2->sec->id
+	  && e1->address == e2->address;
+}
+
+/* Record the pcrel_hi relocation.  */
+
+static bool
+xr17032_record_pcrel_fixup (htab_t p, const asection *sec, bfd_vma address,
+			  symbolS *symbol, bfd_vma target)
+{
+  xr17032_pcrel_hi_fixup entry = {sec, address, symbol, target};
+  xr17032_pcrel_hi_fixup **slot =
+	(xr17032_pcrel_hi_fixup **) htab_find_slot (p, &entry, INSERT);
+  if (slot == NULL)
+    return false;
+
+  *slot = (xr17032_pcrel_hi_fixup *) xmalloc (sizeof (xr17032_pcrel_hi_fixup));
+  if (*slot == NULL)
+    return false;
+  **slot = entry;
+  return true;
+}
+
+/* This function is called once, at assembler startup time.  It should set up
+   all the tables, etc. that the MD part of the assembler will need.  */
+
+void
+md_begin (void)
+{
+  if (! bfd_set_arch_mach (stdoutput, bfd_arch_xr17032, bfd_mach_xr17032))
+    as_warn (_("could not set architecture and machine"));
+
+  op_hash = init_opcode_hash (xr17032_opcodes);
+
+  reg_names_hash = str_htab_create ();
+  hash_reg_names (reg_names_hash, xr17032_reg_names);
+  control_reg_names_hash = str_htab_create ();
+  hash_reg_names (control_reg_names_hash, xr17032_control_reg_names);
+
+  shift_op_names_hash = str_htab_create ();
+  str_hash_insert (shift_op_names_hash, "LSH", (void *)(uintptr_t)1, 0);
+  str_hash_insert (shift_op_names_hash, "RSH", (void *)(uintptr_t)2, 0);
+  str_hash_insert (shift_op_names_hash, "ASH", (void *)(uintptr_t)3, 0);
+  str_hash_insert (shift_op_names_hash, "ROR", (void *)(uintptr_t)4, 0);
+
+  mem_size_names_hash = str_htab_create ();
+  str_hash_insert (mem_size_names_hash, "byte", (void *)(uintptr_t)1, 0);
+  str_hash_insert (mem_size_names_hash, "int", (void *)(uintptr_t)2, 0);
+  str_hash_insert (mem_size_names_hash, "long", (void *)(uintptr_t)3, 0);
+
+  xr17032_pcrel_hi_fixup_hash = htab_create (1024, xr17032_pcrel_fixup_hash,
+					     xr17032_pcrel_fixup_eq, free);
+
+  /* Set the default alignment for the text section.  */
+  record_alignment (text_section, 2);
+}
+
+void
+md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
+{
+}
+
+static unsigned int
+reg_lookup_internal (const char *s, htab_t htab)
+{
+  void *r;
+
+  r = str_hash_find (htab, s);
+  if (r == NULL)
+    return -1;
+
+  return (uintptr_t)r - 1;
+}
+
+int
+tc_xr17032_regname_to_dw2regnum (char *regname)
+{
+  int reg;
+
+  if ((reg = reg_lookup_internal (regname, reg_names_hash)) >= 0)
+    return reg;
+
+  if ((reg = reg_lookup_internal (regname, control_reg_names_hash)) >= 0)
+    return reg + 32;
+
+  as_bad (_("unknown register `%s'"), regname);
+  return -1;
+}
+
+/* Standard calling conventions leave the CFA at SP on entry.  */
+
+void
+xr17032_cfi_frame_initial_instructions (void)
+{
+  cfi_add_CFA_def_cfa (XR_REGISTER_SP, 0);
+}
+
+bool xr17032_parse_name (const char *name, struct expressionS *ep,
+			 enum expr_mode mode)
+{
+  unsigned int regno;
+  symbolS *sym;
+
+  if (!probing_insn_operands)
+    return false;
+
+  gas_assert (mode == expr_normal);
+
+  regno = reg_lookup_internal (name, reg_names_hash);
+  if (regno == (unsigned int)-1)
+    return false;
+
+  if (symbol_find (name) != NULL)
+    return false;
+
+  /* Create a symbol without adding it to the symbol table yet.
+     Insertion will happen only once we commit to using the insn
+     we're probing operands for.  */
+  for (sym = deferred_sym_rootP; sym; sym = symbol_next (sym))
+    if (strcmp (name, S_GET_NAME (sym)) == 0)
+      break;
+  if (!sym)
+    {
+      for (sym = orphan_sym_rootP; sym; sym = symbol_next (sym))
+	if (strcmp (name, S_GET_NAME (sym)) == 0)
+	  {
+	    symbol_remove (sym, &orphan_sym_rootP, &orphan_sym_lastP);
+	    break;
+	  }
+      if (!sym)
+	sym = symbol_create (name, undefined_section,
+			     &zero_address_frag, 0);
+
+      symbol_append (sym, deferred_sym_lastP, &deferred_sym_rootP,
+		     &deferred_sym_lastP);
+    }
+
+  ep->X_op = O_symbol;
+  ep->X_add_symbol = sym;
+  ep->X_add_number = 0;
+
+  return true;
+}
+
+/* Called just before the assembler exits.  */
+
+void
+xr17032_md_end (void)
+{
+  htab_delete (xr17032_pcrel_hi_fixup_hash);
+}
+
+const char *
+md_atof (int type, char *litP, int *sizeP)
+{
+  return ieee_md_atof (type, litP, sizeP, target_big_endian);
+}
+
+void
+xr17032_pop_insert (void)
+{
+}
+
+/* Because the value of .cfi_remember_state may changed after relaxation,
+   we insert a fix to relocate it again in link-time.  */
+
+void
+xr17032_pre_output_hook (void)
+{
+  const frchainS *frch;
+  segT s;
+
+  /* Save the current segment info.  */
+  segT seg = now_seg;
+  subsegT subseg = now_subseg;
+
+  for (s = stdoutput->sections; s; s = s->next)
+    for (frch = seg_info (s)->frchainP; frch; frch = frch->frch_next)
+      {
+	fragS *frag;
+
+	for (frag = frch->frch_root; frag; frag = frag->fr_next)
+	  {
+	    if (frag->fr_type == rs_cfa)
+	      {
+		expressionS exp;
+		expressionS *symval;
+
+		symval = symbol_get_value_expression (frag->fr_symbol);
+		exp.X_op = O_subtract;
+		exp.X_add_symbol = symval->X_add_symbol;
+		exp.X_add_number = 0;
+		exp.X_op_symbol = symval->X_op_symbol;
+
+		/* We must set the segment before creating a frag after all
+		   frag chains have been chained together.  */
+		subseg_set (s, frch->frch_subseg);
+
+		fix_new_exp (frag, (int) frag->fr_offset, 1, &exp, 0,
+			     BFD_RELOC_XR17032_CFA);
+	      }
+	  }
+      }
+
+  /* Restore the original segment info.  */
+  subseg_set (seg, subseg);
+}
+
+int
+md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
+			       asection *segtype ATTRIBUTE_UNUSED)
+{
+  return -1;
+}
+
+/* Relax a machine dependent frag.  This returns the amount by which
+   the current size of the frag should change.  */
+
+void
+md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT asec ATTRIBUTE_UNUSED,
+		 fragS *fragp ATTRIBUTE_UNUSED)
+{
+}
+
+/* Translate internal representation of relocation info to BFD target
+   format.  */
+
+arelent *
+tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
+{
+  arelent *reloc;
+
+  reloc = notes_alloc (sizeof (arelent));
+  reloc->sym_ptr_ptr = notes_alloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->addend = fixp->fx_addnumber;
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("cannot represent %s relocation in object file"),
+		    bfd_get_reloc_code_name (fixp->fx_r_type));
+      return NULL;
+    }
+
+  return reloc;
+}
+
+long
+md_pcrel_from (fixS *fixP)
+{
+  return fixP->fx_where + fixP->fx_frag->fr_address;
+}
+
+static uint32_t
+xr17032_apply_const_reloc (bfd_reloc_code_real_type reloc_type, bfd_vma value)
+{
+  switch (reloc_type)
+    {
+    case BFD_RELOC_32:
+      return value;
+
+    case BFD_RELOC_XR17032_IMM16:
+    case BFD_RELOC_XR17032_IMM16_SIGNED:
+    case BFD_RELOC_XR17032_LO16:
+      return XR_IMM_ENCODE_I (XR_IMM_LOW_PART (value));
+
+    case BFD_RELOC_XR17032_IMM16_1:
+    case BFD_RELOC_XR17032_LO16_1:
+      return XR_IMM_ENCODE_I_1 (XR_IMM_LOW_PART (value));
+
+    case BFD_RELOC_XR17032_IMM16_2:
+    case BFD_RELOC_XR17032_LO16_2:
+      return XR_IMM_ENCODE_I_2 (XR_IMM_LOW_PART (value));
+
+    case BFD_RELOC_XR17032_IMM16_16:
+    case BFD_RELOC_XR17032_HI16:
+      return XR_IMM_ENCODE_I_16 (XR_IMM_HIGH_PART (value));
+
+    default:
+      abort ();
+    }
+}
+
+/* Apply a fixup to the object file.  */
+
+void
+md_apply_fix (fixS *fixP, valueT *valP, segT seg)
+{
+  bfd_byte *buf = (bfd_byte *) (fixP->fx_frag->fr_literal + fixP->fx_where);
+  segT sub_segment;
+
+  /* Remember value for tc_gen_reloc.  */
+  fixP->fx_addnumber = *valP;
+
+  if (fixP->fx_pcrel)
+    {
+      switch (fixP->fx_r_type)
+	{
+	default:
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("requires nonexistent pc-relative reloc equivalent"));
+	  break;
+	case BFD_RELOC_8:
+	  fixP->fx_r_type = BFD_RELOC_8_PCREL;
+	  break;
+	case BFD_RELOC_16:
+	  fixP->fx_r_type = BFD_RELOC_16_PCREL;
+	  break;
+	case BFD_RELOC_32:
+	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
+	  break;
+	case BFD_RELOC_8_PCREL:
+	case BFD_RELOC_16_PCREL:
+	case BFD_RELOC_32_PCREL:
+	case BFD_RELOC_XR17032_BRANCH:
+	case BFD_RELOC_XR17032_HI16_PCREL:
+	case BFD_RELOC_XR17032_HI16_GOT:
+	case BFD_RELOC_XR17032_HI16_PLT:
+	case BFD_RELOC_XR17032_HI16_TLS_GOT:
+	case BFD_RELOC_XR17032_HI16_TLS_GD:
+	  break;
+	}
+    }
+
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_XR17032_IMM16:
+    case BFD_RELOC_XR17032_IMM16_1:
+    case BFD_RELOC_XR17032_IMM16_2:
+    case BFD_RELOC_XR17032_IMM16_16:
+    case BFD_RELOC_XR17032_IMM16_SIGNED:
+    case BFD_RELOC_XR17032_HI16:
+    case BFD_RELOC_XR17032_LO16:
+    case BFD_RELOC_XR17032_LO16_1:
+    case BFD_RELOC_XR17032_LO16_2:
+      bfd_putl32 (xr17032_apply_const_reloc (fixP->fx_r_type, *valP)
+		  | bfd_getl32 (buf), buf);
+      if (fixP->fx_addsy == NULL)
+	fixP->fx_done = true;
+      break;
+
+    case BFD_RELOC_XR17032_HI16_GOT:
+      break;
+
+    case BFD_RELOC_XR17032_HI16_TPREL:
+    case BFD_RELOC_XR17032_LO16_TPREL:
+    case BFD_RELOC_XR17032_LO16_1_TPREL:
+    case BFD_RELOC_XR17032_LO16_2_TPREL:
+    case BFD_RELOC_XR17032_HI16_TLS_GOT:
+    case BFD_RELOC_XR17032_HI16_TLS_GD:
+    case BFD_RELOC_XR17032_TLS_DTPREL:
+      if (fixP->fx_addsy != NULL)
+	S_SET_THREAD_LOCAL (fixP->fx_addsy);
+      else
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("TLS relocation against a constant"));
+      break;
+
+    case BFD_RELOC_32:
+      /* Use pc-relative relocation for FDE initial location.
+	 The symbol address in .eh_frame may be adjusted in
+	 _bfd_elf_discard_section_eh_frame, and the content of
+	 .eh_frame will be adjusted in _bfd_elf_write_section_eh_frame.
+	 Therefore, we cannot insert a relocation whose addend symbol is
+	 in .eh_frame.  Othrewise, the value may be adjusted twice.  */
+      if (fixP->fx_addsy && fixP->fx_subsy
+	  && (sub_segment = S_GET_SEGMENT (fixP->fx_subsy))
+	  && strcmp (sub_segment->name, ".eh_frame") == 0
+	  && S_GET_VALUE (fixP->fx_subsy)
+	     == fixP->fx_frag->fr_address + fixP->fx_where)
+	{
+	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
+	  fixP->fx_subsy = NULL;
+	  break;
+	}
+      /* Fall through.  */
+    case BFD_RELOC_16:
+    case BFD_RELOC_8:
+    case BFD_RELOC_XR17032_CFA:
+    case BFD_RELOC_RVA:
+      /* If we are deleting this reloc entry, we must fill in the
+	 value now.  This can happen if we have a .word which is not
+	 resolved when it appears but is later defined.  */
+      if (fixP->fx_addsy == NULL)
+	{
+	  gas_assert (fixP->fx_size <= sizeof (valueT));
+	  md_number_to_chars ((char *) buf, *valP, fixP->fx_size);
+	  fixP->fx_done = 1;
+	}
+      break;
+
+    case BFD_RELOC_XR17032_JUMP:
+      if (fixP->fx_addsy)
+	{
+	  /* Fill in a tentative value to improve objdump readability.  */
+	  bfd_vma target = S_GET_VALUE (fixP->fx_addsy) + *valP;
+	  bfd_putl32 (bfd_getl32 (buf) | XR_IMM_ENCODE_J (target), buf);
+	}
+      break;
+
+    case BFD_RELOC_XR17032_BRANCH:
+      if (fixP->fx_addsy)
+	{
+	  /* Fill in a tentative value to improve objdump readability.  */
+	  bfd_vma target = S_GET_VALUE (fixP->fx_addsy) + *valP;
+	  bfd_vma delta = target - md_pcrel_from (fixP);
+	  bfd_putl32 (bfd_getl32 (buf) | XR_IMM_ENCODE_B (delta), buf);
+	  if (S_IS_LOCAL (fixP->fx_addsy)
+	      && S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	    fixP->fx_done = 1;
+	}
+      break;
+
+    case BFD_RELOC_8_PCREL:
+    case BFD_RELOC_16_PCREL:
+    case BFD_RELOC_32_PCREL:
+      if (fixP->fx_addsy)
+	{
+	  /* Fill in a tentative value to improve objdump readability.  */
+	  bfd_vma target = S_GET_VALUE (fixP->fx_addsy) + *valP;
+	  bfd_vma delta = target - md_pcrel_from (fixP);
+
+	  if (fixP->fx_r_type == BFD_RELOC_8_PCREL)
+	    *buf = delta;
+	  else if (fixP->fx_r_type == BFD_RELOC_16_PCREL)
+	    bfd_putl16 (delta, buf);
+	  else
+	    bfd_putl32 (delta, buf);
+
+	  if (S_IS_LOCAL (fixP->fx_addsy)
+	    && S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	    fixP->fx_done = 1;
+	}
+      break;
+
+    case BFD_RELOC_XR17032_HI16_PCREL:
+      /* Record and evaluate the pcrel_hi relocation with local symbol.
+	 Fill in value and set fx_done.  */
+      if (fixP->fx_addsy
+	  && S_IS_LOCAL (fixP->fx_addsy)
+	  && S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	{
+	  bfd_vma target = S_GET_VALUE (fixP->fx_addsy) + *valP;
+	  bfd_vma value = target - md_pcrel_from (fixP);
+
+	  /* Record HI16_PCREL.  */
+	  if (!xr17032_record_pcrel_fixup (xr17032_pcrel_hi_fixup_hash,
+					   (const asection *) seg,
+					   md_pcrel_from (fixP),
+					   fixP->fx_addsy,
+					   target))
+	    as_warn (_("too many pcrel_hi"));
+
+	  bfd_putl32 (bfd_getl32 (buf)
+		      | XR_IMM_ENCODE_I_16 (XR_IMM_HIGH_PART (value)),
+		      buf);
+	  fixP->fx_done = 1;
+	}
+      break;
+
+    case BFD_RELOC_XR17032_LO16_PCREL:
+    case BFD_RELOC_XR17032_LO16_1_PCREL:
+    case BFD_RELOC_XR17032_LO16_2_PCREL:
+      /* Resolve the pcrel_lo relocation with local symbol.
+	 Fill in value and set fx_done.  */
+      {
+	bfd_vma location_pcrel_hi = S_GET_VALUE (fixP->fx_addsy) + *valP;
+	xr17032_pcrel_hi_fixup search =
+		{(const asection *) seg, location_pcrel_hi, 0, 0};
+	xr17032_pcrel_hi_fixup *entry = htab_find (xr17032_pcrel_hi_fixup_hash,
+						   &search);
+	if (entry && entry->symbol
+	    && S_IS_LOCAL (entry->symbol)
+	    && S_GET_SEGMENT (entry->symbol) == seg)
+	  {
+	    bfd_vma target = entry->target;
+	    bfd_vma value = target - entry->address;
+
+	    if (fixP->fx_r_type == BFD_RELOC_XR17032_LO16_PCREL)
+	      bfd_putl32 (bfd_getl32 (buf) | XR_IMM_ENCODE_I (value), buf);
+	    else if (fixP->fx_r_type == BFD_RELOC_XR17032_LO16_1_PCREL)
+	      bfd_putl32 (bfd_getl32 (buf) | XR_IMM_ENCODE_I_1 (value), buf);
+	    else
+	      bfd_putl32 (bfd_getl32 (buf) | XR_IMM_ENCODE_I_2 (value), buf);
+	    fixP->fx_done = 1;
+	  }
+      }
+      break;
+
+    default:
+      /* We ignore generic BFD relocations we don't know about.  */
+      if (bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type) != NULL)
+	as_fatal (_("internal: bad relocation #%d"), fixP->fx_r_type);
+    }
+
+  if (fixP->fx_subsy != NULL)
+    as_bad_subtract (fixP);
+}
+
+/* Information about an instruction, including its format, operands
+   and fixups.  */
+struct xr17032_cl_insn
+{
+  /* The opcode's entry in xr17032_opcodes.  */
+  const xr17032_opcode *insn_mo;
+
+  /* The encoded instruction bits.  */
+  uint32_t insn_opcode;
+
+  /* The frag that contains the instruction.  */
+  struct frag *frag;
+
+  /* The offset into FRAG of the first instruction byte.  */
+  long where;
+
+  /* The relocs associated with the instruction, if any.  */
+  fixS *fixp;
+};
+
+/* This structure contains information about errors that occur within the
+   xr17032_ip function */
+struct xr17032_ip_error
+{
+  /* General error message */
+  const char* msg;
+
+  /* Statement that caused the error */
+  char* statement;
+
+  /* Missing extension that needs to be enabled */
+  const char* missing_ext;
+};
+
+/* Initialise INSN from opcode entry MO.  Leave its position unspecified.  */
+
+static void
+create_insn (struct xr17032_cl_insn *insn, const xr17032_opcode *mo)
+{
+  insn->insn_mo = mo;
+  insn->insn_opcode = mo->opcode_bits;
+  insn->frag = NULL;
+  insn->where = 0;
+  insn->fixp = NULL;
+}
+
+static bool
+reg_lookup (char **s, htab_t htab, unsigned int *regnop)
+{
+  char *e;
+  char save_c;
+  int reg = -1;
+
+  /* Find end of name.  */
+  e = *s;
+  if (is_name_beginner (*e))
+    ++e;
+  while (is_part_of_name (*e))
+    ++e;
+
+  /* Terminate name.  */
+  save_c = *e;
+  *e = '\0';
+
+  /* Look for the register.  Advance to next token if one was recognized.  */
+  if ((reg = reg_lookup_internal (*s, htab)) >= 0)
+    *s = e;
+
+  *e = save_c;
+  if (regnop)
+    *regnop = reg;
+  return reg >= 0;
+}
+
+struct percent_op_match
+{
+  const char *str;
+  bfd_reloc_code_real_type reloc;
+};
+
+static const struct percent_op_match percent_op_imm[] =
+{
+  {"lo", BFD_RELOC_XR17032_LO16},
+  {"pcrel_lo", BFD_RELOC_XR17032_LO16_PCREL},
+  {"tprel_lo", BFD_RELOC_XR17032_LO16_TPREL},
+  {0, 0}
+};
+
+static const struct percent_op_match percent_op_imm_1[] =
+{
+  {"lo", BFD_RELOC_XR17032_LO16_1},
+  {"pcrel_lo", BFD_RELOC_XR17032_LO16_1_PCREL},
+  {"tprel_lo", BFD_RELOC_XR17032_LO16_1_TPREL},
+  {0, 0}
+};
+
+static const struct percent_op_match percent_op_imm_2[] =
+{
+  {"lo", BFD_RELOC_XR17032_LO16_2},
+  {"pcrel_lo", BFD_RELOC_XR17032_LO16_2_PCREL},
+  {"tprel_lo", BFD_RELOC_XR17032_LO16_2_TPREL},
+  {0, 0}
+};
+
+static const struct percent_op_match percent_op_imm_16[] =
+{
+  {"hi", BFD_RELOC_XR17032_HI16},
+  {"pcrel_hi", BFD_RELOC_XR17032_HI16_PCREL},
+  {"got_pcrel_hi", BFD_RELOC_XR17032_HI16_GOT},
+  {"plt_pcrel_hi", BFD_RELOC_XR17032_HI16_PLT},
+  {"tls_ie_pcrel_hi", BFD_RELOC_XR17032_HI16_TLS_GOT},
+  {"tls_gd_pcrel_hi", BFD_RELOC_XR17032_HI16_TLS_GD},
+  {"tprel_hi", BFD_RELOC_XR17032_HI16_TPREL},
+  {0, 0}
+};
+
+static const struct percent_op_match percent_op_null[] =
+{
+  {0, 0}
+};
+
+static void
+my_getExpression (expressionS *ep, char *str)
+{
+  char *save_in;
+
+  save_in = input_line_pointer;
+  input_line_pointer = str;
+  expression (ep);
+  expr_parse_end = input_line_pointer;
+  input_line_pointer = save_in;
+}
+
+/* Return true if *STR points to a relocation operator.  When returning true,
+   move *STR over the operator and store its relocation code in *RELOC.
+   Leave both *STR and *RELOC alone when returning false.  */
+
+static bool
+parse_relocation (char **str, bfd_reloc_code_real_type *reloc,
+		  const struct percent_op_match *percent_op)
+{
+  for ( ; percent_op->str; percent_op++)
+    if (strncasecmp (*str + 1, percent_op->str, strlen (percent_op->str)) == 0)
+      {
+	size_t len = 1 + strlen (percent_op->str);
+
+	while (ISSPACE ((*str)[len]))
+	  ++len;
+	if ((*str)[len] != '(')
+	  continue;
+
+	*str += len;
+	*reloc = percent_op->reloc;
+
+	/* Check whether the output BFD supports this relocation.
+	   If not, issue an error and fall back on something safe.  */
+	if (*reloc != BFD_RELOC_UNUSED
+	    && !bfd_reloc_type_lookup (stdoutput, *reloc))
+	  {
+	    as_bad ("internal: relocation %s isn't supported by the "
+		    "current ABI", percent_op->str);
+	    *reloc = BFD_RELOC_UNUSED;
+	  }
+	return true;
+      }
+  return false;
+}
+
+/* Parse string STR as a 16-bit relocatable operand.  Store the
+   expression in *EP and the relocation, if any, in RELOC.
+   Return the number of relocation operators used (0 or 1).
+
+   On exit, EXPR_PARSE_END points to the first character after the
+   expression.  */
+
+static size_t
+my_getSmallExpression (expressionS *ep, bfd_reloc_code_real_type *reloc,
+		       char *str, const struct percent_op_match *percent_op)
+{
+  size_t reloc_index;
+  unsigned crux_depth, str_depth;
+  bool orig_probing = probing_insn_operands;
+  char *crux;
+
+  /* Search for the start of the main expression.
+
+     End the loop with CRUX pointing to the start of the main expression and
+     with CRUX_DEPTH containing the number of open brackets at that point.  */
+  reloc_index = -1;
+  str_depth = 0;
+  do
+    {
+      reloc_index++;
+      crux = str;
+      crux_depth = str_depth;
+
+      /* Skip over whitespace and brackets, keeping count of the number
+	 of brackets.  */
+      while (*str == ' ' || *str == '\t' || *str == '(')
+	if (*str++ == '(')
+	  str_depth++;
+    }
+  while (*str == '%'
+	 && reloc_index < 1
+	 && parse_relocation (&str, reloc, percent_op));
+
+  if (*str == '%')
+    {
+       /* expression() will choke on anything looking like an (unrecognized)
+	  relocation specifier.  Don't even call it, avoiding multiple (and
+	  perhaps redundant) error messages; our caller will issue one.  */
+       ep->X_op = O_illegal;
+       return 0;
+    }
+
+  /* Anything inside parentheses or subject to a relocation operator cannot
+     be a register and hence can be treated the same as operands to
+     directives (other than .insn).  */
+  if (str_depth || reloc_index)
+    probing_insn_operands = false;
+
+  my_getExpression (ep, crux);
+  str = expr_parse_end;
+
+  probing_insn_operands = orig_probing;
+
+  /* Match every open bracket.  */
+  while (crux_depth > 0 && (*str == ')' || *str == ' ' || *str == '\t'))
+    if (*str++ == ')')
+      crux_depth--;
+
+  if (crux_depth > 0)
+    as_bad ("unclosed '('");
+
+  expr_parse_end = str;
+
+  return reloc_index;
+}
+
+/* Is the given value a zero-extended 32-bit value?  Or a negated one?  */
+#define IS_ZEXT_32BIT_NUM(x)						\
+  (((x) &~ (offsetT) 0xffffffff) == 0					\
+   || (((x) &~ (offsetT) 0xffffffff) == ~ (offsetT) 0xffffffff))
+
+/* Sign-extend 32-bit mode constants that have bit 31 set and all higher bits
+   unset.  */
+
+static void
+normalize_constant_expr (expressionS *ex)
+{
+  if ((ex->X_op == O_constant || ex->X_op == O_symbol)
+      && IS_ZEXT_32BIT_NUM (ex->X_add_number))
+    ex->X_add_number = (((ex->X_add_number & 0xffffffff) ^ 0x80000000)
+			- 0x80000000);
+}
+
+/* Fail if an expression EX is not a constant.  IP is the instruction using EX.  */
+
+static void
+check_absolute_expr (struct xr17032_cl_insn *ip, expressionS *ex)
+{
+  if (ex->X_op == O_big)
+    as_bad (_("unsupported large constant"));
+  else if (ex->X_op != O_constant)
+    as_bad (_("instruction %s requires absolute expression"),
+	    ip->insn_mo->mnemonic);
+  normalize_constant_expr (ex);
+}
+
+/* This routine assembles an instruction into its binary format.  As a
+   side effect, it sets the global variable imm_reloc to the type of
+   relocation to do if one of the operands is an address expression.  */
+
+static struct xr17032_ip_error
+xr17032_ip (char *str, struct xr17032_cl_insn *ip, expressionS *imm_expr,
+	    bfd_reloc_code_real_type *imm_reloc, htab_t hash)
+{
+  /* The operand string defined in the xr17032_opcodes.  */
+  const xr17032_operand *oparg;
+  /* The parsed operands from assembly.  */
+  char *asarg, *asargStart;
+  char save_c = 0;
+  const xr17032_opcode *insn = NULL;
+  unsigned int regno;
+  const struct percent_op_match *p;
+  struct xr17032_ip_error error;
+  error.msg = "unrecognized opcode";
+  error.statement = str;
+  error.missing_ext = NULL;
+
+  /* Parse the name of the instruction.  Terminate the string if whitespace
+     is found so that str_hash_find only sees the name part of the string.  */
+  for (asarg = str; *asarg!= '\0'; ++asarg)
+    if (ISSPACE (*asarg))
+      {
+	save_c = *asarg;
+	*asarg++ = '\0';
+	break;
+      }
+
+  if (!strncmp (asarg, "signed", 6) && (!asarg[6] || ISSPACE(asarg[6])))
+    {
+      char *old_asarg = asarg;
+      asarg[-1] = ' ';
+      asarg += 6;
+      char save_c2 = *asarg;
+      *asarg++ = '\0';
+
+      insn = (xr17032_opcode *) str_hash_find (hash, str);
+      if (!insn)
+	{
+	  asarg[-1] = save_c2;
+	  asarg = old_asarg;
+	  asarg[-1] = save_c;
+	}
+    }
+
+  if (!insn)
+    insn = (xr17032_opcode *) str_hash_find (hash, str);
+
+  probing_insn_operands = true;
+
+  asargStart = asarg;
+  for ( ; insn && insn->mnemonic && strcmp (insn->mnemonic, str) == 0; insn++)
+    {
+      /* Reset error message of the previous round.  */
+      error.msg = _("illegal operands");
+      error.missing_ext = NULL;
+
+      /* Purge deferred symbols from the previous round, if any.  */
+      while (deferred_sym_rootP)
+	{
+	  symbolS *sym = deferred_sym_rootP;
+
+	  symbol_remove (sym, &deferred_sym_rootP, &deferred_sym_lastP);
+	  symbol_append (sym, orphan_sym_lastP, &orphan_sym_rootP,
+			 &orphan_sym_lastP);
+	}
+
+      create_insn (ip, insn);
+
+      imm_expr->X_op = O_absent;
+      *imm_reloc = BFD_RELOC_UNUSED;
+
+      for (oparg = insn->operands;; ++oparg)
+	{
+	  p = percent_op_null;
+
+	  asarg += strspn (asarg, " \t");
+
+	  if (oparg != insn->operands && *asarg == ']')
+	    {
+	      if (oparg[-1] != XR_OP_MEM8_IMM && oparg[-1] != XR_OP_MEM16_IMM
+		  && oparg[-1] != XR_OP_MEM32_IMM && oparg[-1] != XR_OP_MEM8_REG
+		  && oparg[-1] != XR_OP_MEM16_REG && oparg[-1] != XR_OP_MEM32_REG)
+		break;
+
+	      asarg++;
+	      asarg += strspn (asarg, " \t");
+	    }
+
+	  if (oparg - insn->operands >= XR_MAX_OPERANDS || *oparg == XR_OP_NONE)
+	    {
+	      if (*asarg != '\0')
+		break;
+
+	      /* Successful assembly.  */
+	      error.msg = NULL;
+
+	      /* Commit deferred symbols, if any.  */
+	      while (deferred_sym_rootP)
+		{
+		  symbolS *sym = deferred_sym_rootP;
+
+		  symbol_remove (sym, &deferred_sym_rootP,
+				 &deferred_sym_lastP);
+		  symbol_append (sym, symbol_lastP, &symbol_rootP,
+				 &symbol_lastP);
+		  symbol_table_insert (sym);
+		}
+	      goto out;
+	    }
+
+	  if (oparg != insn->operands)
+	    {
+	      if (*asarg++ != ',')
+		break;
+
+	      asarg += strspn (asarg, " \t");
+	    }
+
+	  switch (*oparg)
+	    {
+	    case XR_OP_JUMP: /* 29-bit absolute address.  */
+	     *imm_reloc = BFD_RELOC_XR17032_JUMP;
+	      my_getExpression (imm_expr, asarg);
+	      asarg = expr_parse_end;
+	      continue;
+
+	    case XR_OP_BRANCH: /* 21-bit PC-relative offset.  */
+	      *imm_reloc = BFD_RELOC_XR17032_BRANCH;
+	      my_getExpression (imm_expr, asarg);
+	      asarg = expr_parse_end;
+	      continue;
+
+	    case XR_OP_IMM_SMALL: /* Small signed immediate, -16 - 15.  */
+	      my_getExpression (imm_expr, asarg);
+	      check_absolute_expr (ip, imm_expr);
+	      if ((unsigned long) imm_expr->X_add_number + 16 > 31)
+		as_bad (_("immediate too large (%"PRIu64")"),
+			imm_expr->X_add_number);
+	      ip->insn_opcode |= (imm_expr->X_add_number & 31) << 11;
+	      imm_expr->X_op = O_absent;
+	      asarg = expr_parse_end;
+	      continue;
+
+	    case XR_OP_IMM:
+	    imm:
+	      p = percent_op_imm;
+	      *imm_reloc = BFD_RELOC_XR17032_IMM16;
+	      goto imm_low;
+	    case XR_OP_IMM_1:
+	    imm_1:
+	      p = percent_op_imm_1;
+	      *imm_reloc = BFD_RELOC_XR17032_IMM16_1;
+	      goto imm_low;
+	    case XR_OP_IMM_2:
+	    imm_2:
+	      p = percent_op_imm_2;
+	      *imm_reloc = BFD_RELOC_XR17032_IMM16_2;
+	    imm_low:
+	      my_getSmallExpression (imm_expr, imm_reloc, asarg, p);
+	      asarg = expr_parse_end;
+	      continue;
+
+	    case XR_OP_IMM_16: /* Upper 16 bits.  */
+	      p = percent_op_imm_16;
+	      *imm_reloc = BFD_RELOC_XR17032_IMM16_16;
+	      my_getSmallExpression (imm_expr, imm_reloc, asarg, p);
+	      asarg = expr_parse_end;
+	      continue;
+
+	    case XR_OP_IMM_SIGN:
+	      *imm_reloc = BFD_RELOC_XR17032_IMM16_SIGNED;
+	      my_getSmallExpression (imm_expr, imm_reloc, asarg, p);
+	      asarg = expr_parse_end;
+	      continue;
+
+	    case XR_OP_REG_A: /* Register A.  */
+	    case XR_OP_REG_B: /* Register B.  */
+	    case XR_OP_REG_C: /* Register C.  */
+	      if (reg_lookup (&asarg, reg_names_hash, &regno))
+		{
+		  /* Now that we have assembled one operand, we use the args
+		     string to figure out where it goes in the instruction.  */
+		  switch (*oparg)
+		    {
+		    case XR_OP_REG_A:
+		      ip->insn_opcode |= regno << 6;
+		      continue;
+		    case XR_OP_REG_B:
+		      ip->insn_opcode |= regno << 11;
+		      continue;
+		    case XR_OP_REG_C:
+		      ip->insn_opcode |= regno << 16;
+		      continue;
+		    default:
+		      break;
+		    }
+		}
+	      break;
+
+	    case XR_OP_REG_C_SHIFT: /* Register C with inline shift.  */
+	    reg_c_shift:
+	      if (reg_lookup (&asarg, reg_names_hash, &regno))
+		{
+		  asarg += strspn(asarg, " \t");
+
+		  ip->insn_opcode |= regno << 16;
+
+		  unsigned int shift_op;
+
+		  if (reg_lookup (&asarg, shift_op_names_hash, &shift_op))
+		    {
+		      my_getExpression (imm_expr, asarg);
+		      check_absolute_expr (ip, imm_expr);
+		      if ((unsigned long) imm_expr->X_add_number > 31)
+			as_bad (_("immediate too large (%"PRIu64")"),
+				imm_expr->X_add_number);
+		      imm_expr->X_op = O_absent;
+		      asarg = expr_parse_end;
+
+		      ip->insn_opcode |= shift_op << 26;
+		      ip->insn_opcode |= imm_expr->X_add_number << 21;
+		    }
+
+		  continue;
+		}
+	      break;
+
+	    case XR_OP_CREG: /* Control register.  */
+	      if (reg_lookup (&asarg, control_reg_names_hash, &regno))
+		{
+		  ip->insn_opcode |= regno << 16;
+		  continue;
+		}
+	      break;
+
+	    case XR_OP_MEM8_IMM: /* 8-bit memory location, immediate offset */
+	    case XR_OP_MEM16_IMM: /* 16-bit memory location, immediate offset */
+	    case XR_OP_MEM32_IMM: /* 32-bit memory location, immediate offset */
+	    case XR_OP_MEM8_REG: /* 8-bit memory location, register offset */
+	    case XR_OP_MEM16_REG: /* 16-bit memory location, register offset */
+	    case XR_OP_MEM32_REG: /* 32-bit memory location, register offset */
+	    {
+	      unsigned int shift;
+	      if (reg_lookup (&asarg, mem_size_names_hash, &shift))
+		{
+		  unsigned int wanted_shift;
+		  switch (*oparg)
+		    {
+		    case XR_OP_MEM8_IMM:
+		    case XR_OP_MEM8_REG:
+		      wanted_shift = 0;
+		      break;
+		    case XR_OP_MEM16_IMM:
+		    case XR_OP_MEM16_REG:
+		      wanted_shift = 1;
+		      break;
+		    case XR_OP_MEM32_IMM:
+		    case XR_OP_MEM32_REG:
+		      wanted_shift = 2;
+		      break;
+		    default:
+		      wanted_shift = -1;
+		      break;
+		    }
+
+		  if (shift != wanted_shift)
+		    break;
+
+		  asarg += strspn(asarg, " \t");
+
+		  if (*asarg++ != '[')
+		    break;
+
+		  char *loc_start = asarg;
+
+		  if (reg_lookup (&asarg, reg_names_hash, &regno))
+		    asarg += strspn(asarg, " \t");
+		  else
+		    regno = XR_REGISTER_ZERO;
+
+		  switch (*oparg)
+		    {
+		    case XR_OP_MEM8_IMM:
+		    case XR_OP_MEM16_IMM:
+		    case XR_OP_MEM32_IMM:
+		      if (oparg == insn->operands)
+			ip->insn_opcode |= regno << 6;
+		      else
+			ip->insn_opcode |= regno << 11;
+
+		      if (asarg != loc_start && *asarg++ != '+')
+			continue;
+
+		      if (*oparg == XR_OP_MEM8_IMM)
+			goto imm;
+		      else if (*oparg == XR_OP_MEM16_IMM)
+			goto imm_1;
+		      else if (*oparg == XR_OP_MEM32_IMM)
+			goto imm_2;
+
+		      break;
+		    case XR_OP_MEM8_REG:
+		    case XR_OP_MEM16_REG:
+		    case XR_OP_MEM32_REG:
+		      if (asarg != loc_start && *asarg++ != '+')
+			break;
+
+		      ip->insn_opcode |= regno << 11;
+		      goto reg_c_shift;
+		    default:
+		      break;
+		    }
+		}
+	      break;
+	    }
+	    default:
+	      as_fatal (_("internal: unknown argument type `%d'"),
+			*oparg);
+	      break;
+	    }
+	  break;
+	}
+      asarg = asargStart;
+    }
+
+ out:
+  /* Restore the character we might have clobbered above.  */
+  if (save_c)
+    *(asargStart  - 1) = save_c;
+
+  probing_insn_operands = false;
+
+  return error;
+}
+
+/* Install INSN at the location specified by its "frag" and "where" fields.  */
+
+static void
+install_insn (const struct xr17032_cl_insn *insn)
+{
+  char *f = insn->frag->fr_literal + insn->where;
+  number_to_chars_littleendian (f, insn->insn_opcode, 4);
+}
+
+/* Move INSN to offset WHERE in FRAG.  Adjust the fixups accordingly
+   and install the opcode in the new location.  */
+
+static void
+move_insn (struct xr17032_cl_insn *insn, fragS *frag, long where)
+{
+  insn->frag = frag;
+  insn->where = where;
+  if (insn->fixp != NULL)
+    {
+      insn->fixp->fx_frag = frag;
+      insn->fixp->fx_where = where;
+    }
+  install_insn (insn);
+}
+
+/* Add INSN to the end of the output.  */
+
+static void
+add_fixed_insn (struct xr17032_cl_insn *insn)
+{
+  char *f = frag_more (4);
+  move_insn (insn, frag_now, f - frag_now->fr_literal);
+}
+
+/* Output an instruction.  IP is the instruction information.
+   ADDRESS_EXPR is an operand of the instruction to be used with
+   RELOC_TYPE.  */
+
+static void
+append_insn (struct xr17032_cl_insn *ip, expressionS *address_expr,
+	     bfd_reloc_code_real_type reloc_type)
+{
+  dwarf2_emit_insn (0);
+
+  if (reloc_type != BFD_RELOC_UNUSED)
+    {
+      reloc_howto_type *howto;
+
+      gas_assert (address_expr);
+      howto = bfd_reloc_type_lookup (stdoutput, reloc_type);
+      if (howto == NULL)
+	as_bad (_("internal: unsupported XR/17032 relocation number %d"),
+		reloc_type);
+
+      ip->fixp = fix_new_exp (ip->frag, ip->where,
+			      bfd_get_reloc_size (howto),
+			      address_expr, false, reloc_type);
+    }
+
+  add_fixed_insn (ip);
+}
+
+void
+md_assemble (char *str)
+{
+  struct xr17032_cl_insn insn;
+  expressionS imm_expr;
+  bfd_reloc_code_real_type imm_reloc = BFD_RELOC_UNUSED;
+
+  const struct xr17032_ip_error error = xr17032_ip (str, &insn, &imm_expr,
+						    &imm_reloc, op_hash);
+
+  if (error.msg)
+    {
+      if (error.missing_ext)
+	as_bad ("%s `%s', extension `%s' required", error.msg,
+		error.statement, error.missing_ext);
+      else
+	as_bad ("%s `%s'", error.msg, error.statement);
+      return;
+    }
+
+  append_insn (&insn, &imm_expr, imm_reloc);
+}
diff -urN --no-dereference binutils-clean/gas/config/tc-xr17032.h binutils-workdir/gas/config/tc-xr17032.h
--- binutils-clean/gas/config/tc-xr17032.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/gas/config/tc-xr17032.h
@@ -0,0 +1,113 @@
+/* tc-xr17032.h -- Header file for tc-xr17032.c, the XR/17032 GAS port.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+
+   Contributed by monkuous
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the
+   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#ifndef TC_XR17032_H
+#define TC_XR17032_H
+
+#include "opcode/xr17032.h"
+
+struct frag;
+struct expressionS;
+
+#define TC_XR17032 1
+
+#define TARGET_BYTES_BIG_ENDIAN 0
+
+#define TARGET_ARCH bfd_arch_xr17032
+
+#define WORKING_DOT_WORD	1
+#define LOCAL_LABELS_FB		1
+
+/* Symbols named FAKE_LABEL_NAME are emitted when generating DWARF, so make
+   sure FAKE_LABEL_NAME is printable.  It still must be distinct from any
+   real label name.  So, append a space, which other labels can't contain.  */
+#define FAKE_LABEL_NAME	".L0 "
+/* Changing the special character in FAKE_LABEL_NAME requires changing
+   FAKE_LABEL_CHAR too.  */
+#define FAKE_LABEL_CHAR ' '
+
+#define md_section_align(seg,size)	(size)
+#define md_undefined_symbol(name)	(0)
+#define md_operand(x)
+
+#define MAX_MEM_FOR_RS_ALIGN_CODE (3 + 4)
+
+#define TARGET_FORMAT "elf32-xr17032"
+
+#define md_parse_long_option(arg) xr17032_parse_long_option (arg)
+extern int xr17032_parse_long_option (const char *);
+
+#define md_pre_output_hook xr17032_pre_output_hook ()
+extern void xr17032_pre_output_hook (void);
+#define GAS_SORT_RELOCS 1
+
+#define md_end xr17032_md_end
+extern void xr17032_md_end (void);
+
+/* Let the linker resolve all the relocs due to relaxation.  */
+#define tc_fix_adjustable(fixp) 0
+#define md_allow_local_subtract(l,r,s) 0
+
+/* Values passed to md_apply_fix don't include symbol values.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+/* Global syms must not be resolved, to support ELF shared libraries.  */
+#define EXTERN_FORCE_RELOC			\
+  (OUTPUT_FLAVOR == bfd_target_elf_flavour)
+
+#define DIFF_EXPR_OK 1
+
+struct xr17032_fix
+{
+  int source_macro;
+};
+
+#define TC_FIX_TYPE struct xr17032_fix
+#define TC_INIT_FIX_DATA(FIX) (FIX)->tc_fix_data.source_macro = -1
+
+extern void xr17032_pop_insert (void);
+#define md_pop_insert()		xr17032_pop_insert ()
+
+#define TARGET_USE_CFIPOP 1
+
+#define tc_cfi_frame_initial_instructions xr17032_cfi_frame_initial_instructions
+extern void xr17032_cfi_frame_initial_instructions (void);
+
+#define tc_regname_to_dw2regnum tc_xr17032_regname_to_dw2regnum
+extern int tc_xr17032_regname_to_dw2regnum (char *);
+
+#define DWARF2_DEFAULT_RETURN_COLUMN XR_REGISTER_LR
+
+#define DWARF2_CIE_DATA_ALIGNMENT -4
+
+/* Adjust debug_line after relaxation.  */
+#define DWARF2_USE_FIXED_ADVANCE_PC 1
+
+#define md_parse_name(name, exp, mode, c) \
+  xr17032_parse_name (name, exp, mode)
+bool xr17032_parse_name (const char *, struct expressionS *, enum expr_mode);
+
+extern int xr17032_convert_symbolic_attribute (const char *);
+
+#define DIFF_EXPR_OK 1
+
+#endif /* TC_XR17032_H */
diff -urN --no-dereference binutils-clean/gas/configure.tgt binutils-workdir/gas/configure.tgt
--- binutils-clean/gas/configure.tgt
+++ binutils-workdir/gas/configure.tgt
@@ -425,6 +425,8 @@
 
   wasm32-*-*)                           fmt=elf ;;
 
+  xr17032-*-linux*)			fmt=elf em=linux ;;
+
   xstormy16-*-*)			fmt=elf ;;
   
   xgate-*-*)    			fmt=elf ;;
diff -urN --no-dereference binutils-clean/gprofng/libcollector/configure.ac binutils-workdir/gprofng/libcollector/configure.ac
--- binutils-clean/gprofng/libcollector/configure.ac
+++ binutils-workdir/gprofng/libcollector/configure.ac
@@ -18,7 +18,7 @@
 
 m4_include([../../bfd/version.m4])
 AC_INIT([gprofng], [BFD_VERSION])
-AC_CONFIG_MACRO_DIRS([../../config ../..])
+#AC_CONFIG_MACRO_DIRS([../../config ../..])
 AC_CONFIG_AUX_DIR(../..)
 AC_CANONICAL_TARGET
 AM_INIT_AUTOMAKE
diff -urN --no-dereference binutils-clean/include/elf/common.h binutils-workdir/include/elf/common.h
--- binutils-clean/include/elf/common.h
+++ binutils-workdir/include/elf/common.h
@@ -459,6 +459,8 @@
    architecture was derived.  */
 #define EM_CSKY_OLD		EM_MCORE
 
+#define EM_XR17032  0xb5f0 /* XR/17032 */
+
 /* See the above comment before you add a new EM_* value here.  */
 
 /* Values for e_version.  */
diff -urN --no-dereference binutils-clean/include/elf/xr17032.h binutils-workdir/include/elf/xr17032.h
--- binutils-clean/include/elf/xr17032.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/include/elf/xr17032.h
@@ -0,0 +1,70 @@
+/* XR/17032 ELF support for BFD.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Contributed by monkuous.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_XR17032_H
+#define _ELF_XR17032_H
+
+#include "elf/reloc-macros.h"
+
+/* Creating indices for reloc_map_index array.  */
+START_RELOC_NUMBERS(elf_xr17032_reloc_type)
+  /* relocation types present in all objects */
+  RELOC_NUMBER (R_XR17032_NONE,           0)
+  RELOC_NUMBER (R_XR17032_32,             1)
+  /* relocation types present in dynamically linked objects */
+  RELOC_NUMBER (R_XR17032_RELATIVE,       2)
+  RELOC_NUMBER (R_XR17032_IRELATIVE,      3)
+  RELOC_NUMBER (R_XR17032_JUMP_SLOT,      4)
+  RELOC_NUMBER (R_XR17032_COPY,           5)
+  RELOC_NUMBER (R_XR17032_TLS_TPREL,      6)
+  RELOC_NUMBER (R_XR17032_TLS_DTPMOD,     7)
+  RELOC_NUMBER (R_XR17032_TLS_DTPREL,     8)
+  /* relocation types present in unlinked objects */
+  RELOC_NUMBER (R_XR17032_8,              9)
+  RELOC_NUMBER (R_XR17032_16,             10)
+  RELOC_NUMBER (R_XR17032_8_PCREL,        11)
+  RELOC_NUMBER (R_XR17032_16_PCREL,       12)
+  RELOC_NUMBER (R_XR17032_32_PCREL,       13)
+  RELOC_NUMBER (R_XR17032_JUMP,           14)
+  RELOC_NUMBER (R_XR17032_BRANCH,         15)
+  RELOC_NUMBER (R_XR17032_IMM16,          16)
+  RELOC_NUMBER (R_XR17032_IMM16_1,        17)
+  RELOC_NUMBER (R_XR17032_IMM16_2,        18)
+  RELOC_NUMBER (R_XR17032_IMM16_16,       19)
+  RELOC_NUMBER (R_XR17032_IMM16_SIGNED,   20)
+  RELOC_NUMBER (R_XR17032_LO16,           21)
+  RELOC_NUMBER (R_XR17032_LO16_1,         22)
+  RELOC_NUMBER (R_XR17032_LO16_2,         23)
+  RELOC_NUMBER (R_XR17032_HI16,           24)
+  RELOC_NUMBER (R_XR17032_LO16_PCREL,     25)
+  RELOC_NUMBER (R_XR17032_LO16_1_PCREL,   26)
+  RELOC_NUMBER (R_XR17032_LO16_2_PCREL,   27)
+  RELOC_NUMBER (R_XR17032_HI16_PCREL,     28)
+  RELOC_NUMBER (R_XR17032_HI16_GOT,       29)
+  RELOC_NUMBER (R_XR17032_HI16_PLT,       30)
+  RELOC_NUMBER (R_XR17032_HI16_TLS_GOT,   31)
+  RELOC_NUMBER (R_XR17032_HI16_TLS_GD,    32)
+  RELOC_NUMBER (R_XR17032_LO16_TPREL,     33)
+  RELOC_NUMBER (R_XR17032_LO16_1_TPREL,   34)
+  RELOC_NUMBER (R_XR17032_LO16_2_TPREL,   35)
+  RELOC_NUMBER (R_XR17032_HI16_TPREL,     36)
+END_RELOC_NUMBERS(R_XR17032_MAX)
+
+#endif /* _ELF_XR17032_H */
diff -urN --no-dereference binutils-clean/include/opcode/xr17032.h binutils-workdir/include/opcode/xr17032.h
--- binutils-clean/include/opcode/xr17032.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/include/opcode/xr17032.h
@@ -0,0 +1,284 @@
+/* xr17032.h -- Header file for XR/17032 opcode and register tables.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Contributed by monkuous
+
+   This file is part of GAS, GDB and the GNU binutils.
+
+   GAS, GDB, and GNU binutils is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GAS, GDB, and GNU binutils are distributed in the hope that they will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _XR17032_H_
+#define _XR17032_H_
+
+#include <stdint.h>
+
+typedef enum
+{
+  XR_OP_NONE,
+  XR_OP_JUMP,
+  XR_OP_BRANCH,
+  XR_OP_IMM,
+  XR_OP_IMM_1,
+  XR_OP_IMM_2,
+  XR_OP_IMM_16,
+  XR_OP_IMM_SIGN,
+  XR_OP_IMM_SMALL,
+  XR_OP_REG_A,
+  XR_OP_REG_B,
+  XR_OP_REG_C,
+  XR_OP_REG_C_SHIFT,
+  XR_OP_CREG,
+  XR_OP_MEM8_IMM,
+  XR_OP_MEM16_IMM,
+  XR_OP_MEM32_IMM,
+  XR_OP_MEM8_REG,
+  XR_OP_MEM16_REG,
+  XR_OP_MEM32_REG,
+}
+xr17032_operand;
+
+#define XR_MAX_OPERANDS	3
+
+typedef struct
+{
+  const char *mnemonic;
+  uint32_t match_mask;
+  uint32_t opcode_bits;
+  xr17032_operand operands[XR_MAX_OPERANDS];
+}
+xr17032_opcode;
+
+#define XR_X(x, s, n)  (((x) >> (s)) & ((1 << (n)) - 1))
+#define XR_IMM_SIGN(x) (-(((x) >> 31) & 1))
+
+#define XR_IMM_EXTRACT_J(x, pc) ((XR_X(x, 3, 29) << 2) | ((pc) & 0x80000000))
+#define XR_IMM_EXTRACT_B(x) ((XR_X(x, 11, 21) << 2) | (XR_IMM_SIGN(x) << 23))
+#define XR_IMM_EXTRACT_I(x) XR_X(x, 16, 16)
+#define XR_IMM_EXTRACT_I_1(x) (XR_X(x, 16, 16) << 1)
+#define XR_IMM_EXTRACT_I_2(x) (XR_X(x, 16, 16) << 2)
+#define XR_IMM_EXTRACT_I_16(x) (XR_X(x, 16, 16) << 16)
+#define XR_IMM_EXTRACT_I_S(x) (XR_X(x, 16, 16) | (XR_IMM_SIGN(x) << 16))
+#define XR_IMM_EXTRACT_S(x) XR_X(x, 11, 5)
+#define XR_IMM_EXTRACT_R(x) XR_X(x, 21, 5)
+
+#define XR_IMM_ENCODE_J(x) (XR_X(x, 2, 29) << 3)
+#define XR_IMM_ENCODE_B(x) (XR_X(x, 2, 21) << 11)
+#define XR_IMM_ENCODE_I(x) (XR_X(x, 0, 16) << 16)
+#define XR_IMM_ENCODE_I_1(x) (XR_X(x, 1, 16) << 16)
+#define XR_IMM_ENCODE_I_2(x) (XR_X(x, 2, 16) << 16)
+#define XR_IMM_ENCODE_I_16(x) (XR_X(x, 16, 16) << 16)
+#define XR_IMM_ENCODE_I_S XR_IMM_ENCODE_I
+#define XR_IMM_ENCODE_S(x) (XR_X(x, 0, 5) << 11)
+#define XR_IMM_ENCODE_R(x) (XR_X(x, 0, 5) << 21)
+
+#define XR_IMM_VALID_J(x, pc) (XR_IMM_EXTRACT_J(XR_IMM_ENCODE_J(x), pc) == (x))
+#define XR_IMM_VALID_B(x) (XR_IMM_EXTRACT_B(XR_IMM_ENCODE_B(x)) == (x))
+#define XR_IMM_VALID_I(x) (XR_IMM_EXTRACT_I(XR_IMM_ENCODE_I(x)) == (x))
+#define XR_IMM_VALID_I_1(x) (XR_IMM_EXTRACT_I_1(XR_IMM_ENCODE_I_1(x)) == (x))
+#define XR_IMM_VALID_I_2(x) (XR_IMM_EXTRACT_I_2(XR_IMM_ENCODE_I_2(x)) == (x))
+#define XR_IMM_VALID_I_16(x) (XR_IMM_EXTRACT_I_16(XR_IMM_ENCODE_I_16(x)) == (x))
+#define XR_IMM_VALID_I_S(x) (XR_IMM_EXTRACT_I_S(XR_IMM_ENCODE_I_S(x)) == (x))
+#define XR_IMM_VALID_R(x) (XR_IMM_EXTRACT_R(XR_IMM_ENCODE_R(x)) == (x))
+
+#define XR_IMM_HIGH_PART(x) ((x) & ~(__typeof__(x))0xffff)
+#define XR_IMM_LOW_PART(x) ((x) & 0xffff)
+
+#define XR_OPCODE_J_JAL	7
+#define XR_OPCODE_J_J	6
+
+#define XR_OPCODE_B_BEQ	0x3d
+#define XR_OPCODE_B_BNE	0x35
+#define XR_OPCODE_B_BLT	0x2d
+#define XR_OPCODE_B_BGT	0x25
+#define XR_OPCODE_B_BLE	0x1d
+#define XR_OPCODE_B_BGE	0x15
+#define XR_OPCODE_B_BPE	0x0d
+#define XR_OPCODE_B_BPO	0x05
+
+#define XR_OPCODE_I_ADDI		0x3c
+#define XR_OPCODE_I_SUBI		0x34
+#define XR_OPCODE_I_SLTI		0x2c
+#define XR_OPCODE_IS_SLTI_SIGNED	0x24
+#define XR_OPCODE_I_ANDI		0x1c
+#define XR_OPCODE_I_XORI		0x14
+#define XR_OPCODE_I_ORI			0x0c
+#define XR_OPCODE_I16_LUI		0x04
+#define XR_OPCODE_I_LB			0x3b
+#define XR_OPCODE_I1_LI			0x33
+#define XR_OPCODE_I2_LL			0x2b
+#define XR_OPCODE_I_SB			0x3a
+#define XR_OPCODE_I1_SI			0x32
+#define XR_OPCODE_I2_SL			0x2a
+#define XR_OPCODE_I2_JALR		0x38
+#define XR_OPCODE_I16P_ADR		0x30
+
+#define XR_OPCODE_S_SB	0x1a
+#define XR_OPCODE_S1_SI	0x12
+#define XR_OPCODE_S2_SL	0x0a
+
+#define XR_OPCODE_R_LB		0xf0000039
+#define XR_OPCODE_R_LI		0xe0000039
+#define XR_OPCODE_R_LL		0xd0000039
+#define XR_OPCODE_R_SB		0xb0000039
+#define XR_OPCODE_R_SI		0xa0000039
+#define XR_OPCODE_R_SL		0x90000039
+#define XR_OPCODE_RS_LSH	0x80000039
+#define XR_OPCODE_RS_RSH	0x84000039
+#define XR_OPCODE_RS_ASH	0x88000039
+#define XR_OPCODE_RS_ROR	0x8c000039
+#define XR_OPCODE_R_ADD		0x70000039
+#define XR_OPCODE_R_SUB		0x60000039
+#define XR_OPCODE_R_SLT		0x50000039
+#define XR_OPCODE_R_SLT_SIGNED	0x40000039
+#define XR_OPCODE_R_AND		0x30000039
+#define XR_OPCODE_R_XOR		0x20000039
+#define XR_OPCODE_R_OR		0x10000039
+#define XR_OPCODE_R_NOR		0x00000039
+#define XR_OPCODE_R_MUL		0xf0000031
+#define XR_OPCODE_R_DIV		0xd0000031
+#define XR_OPCODE_R_DIV_SIGNED	0xc0000031
+#define XR_OPCODE_R_MOD		0xb0000031
+#define XR_OPCODE_R2_LL		0x90000031
+#define XR_OPCODE_R3_SC		0x80000031
+#define XR_OPCODE_R0_PAUSE	0x60000031
+#define XR_OPCODE_R0_MB		0x30000031
+#define XR_OPCODE_R0_WMB	0x20000031
+#define XR_OPCODE_R0_BRK	0x10000031
+#define XR_OPCODE_R0_SYS	0x00000031
+#define XR_OPCODE_RC_MFCR	0xf0000029
+#define XR_OPCODE_CR_MTCR	0xe0000029
+#define XR_OPCODE_R0_HLT	0xc0000029
+#define XR_OPCODE_R0_RFE	0xb0000029
+
+#define XR_NUM_REGISTERS	32
+
+#define XR_REGISTER_ZERO	0
+#define XR_REGISTER_T0		1
+#define XR_REGISTER_T1		2
+#define XR_REGISTER_T2		3
+#define XR_REGISTER_T3		4
+#define XR_REGISTER_T4		5
+#define XR_REGISTER_T5		6
+#define XR_REGISTER_A0		7
+#define XR_REGISTER_A1		8
+#define XR_REGISTER_A2		9
+#define XR_REGISTER_A3		10
+#define XR_REGISTER_S0		11
+#define XR_REGISTER_S1		12
+#define XR_REGISTER_S2		13
+#define XR_REGISTER_S3		14
+#define XR_REGISTER_S4		15
+#define XR_REGISTER_S5		16
+#define XR_REGISTER_S6		17
+#define XR_REGISTER_S7		18
+#define XR_REGISTER_S8		19
+#define XR_REGISTER_S9		20
+#define XR_REGISTER_S10		21
+#define XR_REGISTER_S11		22
+#define XR_REGISTER_S12		23
+#define XR_REGISTER_S13		24
+#define XR_REGISTER_S14		25
+#define XR_REGISTER_S15		26
+#define XR_REGISTER_S16		27
+#define XR_REGISTER_S17		28
+#define XR_REGISTER_TP		29
+#define XR_REGISTER_SP		30
+#define XR_REGISTER_LR		31
+
+#define XR_REGISTER_C_RS		0
+#define XR_REGISTER_C_WHAMI		1
+#define XR_REGISTER_C_EB		5
+#define XR_REGISTER_C_EPC		6
+#define XR_REGISTER_C_EBADADDR		7
+#define XR_REGISTER_C_TBMISSADDR	9
+#define XR_REGISTER_C_TBPC		10
+#define XR_REGISTER_C_SCRATCH0		11
+#define XR_REGISTER_C_SCRATCH1		12
+#define XR_REGISTER_C_SCRATCH2		13
+#define XR_REGISTER_C_SCRATCH3		14
+#define XR_REGISTER_C_SCRATCH4		15
+#define XR_REGISTER_C_ITBPTE		16
+#define XR_REGISTER_C_ITBTAG		17
+#define XR_REGISTER_C_ITBINDEX		18
+#define XR_REGISTER_C_ITBCTRL		19
+#define XR_REGISTER_C_ICACHECTRL	20
+#define XR_REGISTER_C_ITBADDR		21
+#define XR_REGISTER_C_DTBPTE		24
+#define XR_REGISTER_C_DTBTAG		25
+#define XR_REGISTER_C_DTBINDEX		26
+#define XR_REGISTER_C_DTBCTRL		27
+#define XR_REGISTER_C_DCACHECTRL	28
+#define XR_REGISTER_C_DTBADDR		29
+
+#define XR_REG_A(REG)	(XR_X(XR_REGISTER_##REG, 0, 5) << 6)
+#define XR_REG_B(REG)	(XR_X(XR_REGISTER_##REG, 0, 5) << 11)
+#define XR_REG_C(REG)	(XR_X(XR_REGISTER_##REG, 0, 5) << 16)
+
+#define XR_SHIFT_LSH	0x0000000
+#define XR_SHIFT_RSH	0x4000000
+#define XR_SHIFT_ASH	0x8000000
+#define XR_SHIFT_ROR	0xc000000
+
+#define XR_INSN_J(OPCODE, TARGET) \
+  (XR_OPCODE_J_##OPCODE | XR_IMM_ENCODE_J(TARGET))
+#define XR_INSN_B(OPCODE, REG, TARGET) \
+  (XR_OPCODE_B_##OPCODE | XR_REG_A(REG) | XR_IMM_ENCODE_B(TARGET))
+#define XR_INSN_I(OPCODE, REGA, REGB, IMM) \
+  (XR_OPCODE_I_##OPCODE | XR_REG_A(REGA) | XR_REG_B(REGB) \
+   | XR_IMM_ENCODE_I(IMM))
+#define XR_INSN_I_1(OPCODE, REGA, REGB, IMM) \
+  (XR_OPCODE_I1_##OPCODE | XR_REG_A(REGA) | XR_REG_B(REGB) \
+   | XR_IMM_ENCODE_I_1(IMM))
+#define XR_INSN_I_2(OPCODE, REGA, REGB, IMM) \
+  (XR_OPCODE_I2_##OPCODE | XR_REG_A(REGA) | XR_REG_B(REGB) \
+  | XR_IMM_ENCODE_I_2(IMM))
+#define XR_INSN_I_16(OPCODE, REGA, REGB, IMM) \
+  (XR_OPCODE_I16_##OPCODE | XR_REG_A(REGA) | XR_REG_B(REGB) \
+  | XR_IMM_ENCODE_I_16(IMM))
+#define XR_INSN_I_16P(OPCODE, REG, IMM) \
+  (XR_OPCODE_I16P_##OPCODE | XR_REG_A(REG) | XR_IMM_ENCODE_I_16(IMM))
+#define XR_INSN_I_S(OPCODE, REGA, REGB, IMM) \
+  (XR_OPCODE_IS_##OPCODE | XR_REG_A(REGA) | XR_REG_B(REGB) \
+  | XR_IMM_ENCODE_I_S(IMM))
+#define XR_INSN_S(OPCODE, REG, OFFSET, IMM) \
+  (XR_OPCODE_S_##OPCODE | XR_REG_A(REGA) | XR_IMM_ENCODE_I(OFFSET) \
+   | XR_IMM_ENCODE_S(IMM))
+#define XR_INSN_S_1(OPCODE, REG, OFFSET, IMM) \
+  (XR_OPCODE_S1_##OPCODE | XR_REG_A(REGA) | XR_IMM_ENCODE_I(OFFSET) \
+   | XR_IMM_ENCODE_S(IMM))
+#define XR_INSN_S_2(OPCODE, REG, OFFSET, IMM) \
+  (XR_OPCODE_S2_##OPCODE | XR_REG_A(REGA) | XR_IMM_ENCODE_I(OFFSET) \
+   | XR_IMM_ENCODE_S(IMM))
+#define XR_INSN_R(OPCODE, REGA, REGB, REGC, SHIFT, SHAMT) \
+  (XR_OPCODE_R_##OPCODE | XR_REG_A(REGA) | XR_REG_B(REGB) | XR_REG_C(REGC) \
+   | XR_SHIFT_##SHIFT | XR_IMM_ENCODE_S(SHAMT))
+#define XR_INSN_RS(OPCODE, REGA, REGB, REGC) \
+  (XR_OPCODE_RS_##OPCODE | XR_REG_A(REGA) | XR_REG_B(REGB) | XR_REG_C(REGC))
+#define XR_INSN_R2(OPCODE, REGA, REGB) \
+  (XR_OPCODE_R2_##OPCODE | XR_REG_A(REGA) | XR_REG_B(REGB))
+#define XR_INSN_R3(OPCODE, REGA, REGB, REGC) \
+  (XR_OPCODE_R2_##OPCODE | XR_REG_A(REGA) | XR_REG_B(REGB) | XR_REG_C(REGC))
+#define XR_INSN_R0(OPCODE) XR_OPCODE_R0_##OPCODE
+#define XR_INSN_RC(OPCODE, REG, CREG) \
+  (XR_OPCODE_RC_##OPCODE | XR_REG_A(REG) | XR_REG_C(C_##CREG))
+#define XR_INSN_CR(OPCODE, CREG, REG) \
+  (XR_OPCODE_CR_##OPCODE | XR_REG_C(C_##CREG) | XR_REG_B(REG))
+
+#define XR_NOP XR_INSN_I(ADDI, ZERO, ZERO, 0)
+
+extern const xr17032_opcode xr17032_opcodes[];
+extern const char *const xr17032_reg_names[XR_NUM_REGISTERS];
+extern const char *const xr17032_control_reg_names[XR_NUM_REGISTERS];
+
+#endif /* _XR17032_H_ */
diff -urN --no-dereference binutils-clean/ld/Makefile.am binutils-workdir/ld/Makefile.am
--- binutils-clean/ld/Makefile.am
+++ binutils-workdir/ld/Makefile.am
@@ -285,6 +285,7 @@
 	eelf_i386_vxworks.c \
 	eelf_iamcu.c \
 	eelf_s390.c \
+	eelf_xr17032.c \
 	eh8300elf.c \
 	eh8300elf_linux.c \
 	eh8300helf.c \
diff -urN --no-dereference binutils-clean/ld/configure.tgt binutils-workdir/ld/configure.tgt
--- binutils-clean/ld/configure.tgt
+++ binutils-workdir/ld/configure.tgt
@@ -1073,6 +1073,10 @@
 xgate-*-*)		targ_emul=xgateelf
 			targ_extra_ofiles=ldelfgen.o
 			;;
+xr17032-*-elf*)		targ_emul=elf_xr17032
+			;;
+xr17032-*-linux-*)	targ_emul=elf_xr17032
+			;;
 xstormy16-*-*)		targ_emul=elf32xstormy16
 			;;
 xtensa*-*-*)		targ_emul=elf32xtensa
diff -urN --no-dereference binutils-clean/ld/emulparams/elf_xr17032.sh binutils-workdir/ld/emulparams/elf_xr17032.sh
--- binutils-clean/ld/emulparams/elf_xr17032.sh	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/ld/emulparams/elf_xr17032.sh
@@ -0,0 +1,41 @@
+# This is an ELF platform.
+SCRIPT_NAME=elf
+ARCH=xr17032
+NO_REL_RELOCS=yes
+
+TEMPLATE_NAME=elf
+EXTRA_EM_FILE=xr17032elf
+
+ELFSIZE=32
+
+if test `echo "$host" | sed -e s/64//` = `echo "$target" | sed -e s/64//`; then
+  case " $EMULATION_LIBPATH " in
+    *" ${EMULATION_NAME} "*)
+      NATIVE=yes
+      ;;
+  esac
+fi
+
+# Enable shared library support for everything except an embedded elf target.
+case "$target" in
+  xr17032*-elf)
+    ;;
+  *)
+    GENERATE_SHLIB_SCRIPT=yes
+    GENERATE_PIE_SCRIPT=yes
+    ;;
+esac
+
+IREL_IN_PLT=
+TEXT_START_ADDR=0x10000
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+COMMONPAGESIZE="CONSTANT (COMMONPAGESIZE)"
+
+INITIAL_READONLY_SECTIONS=".interp         : { *(.interp) } ${CREATE_PIE-${INITIAL_READONLY_SECTIONS}}"
+INITIAL_READONLY_SECTIONS="${RELOCATING+${CREATE_SHLIB-${INITIAL_READONLY_SECTIONS}}}"
+
+# Put .got before .data
+DATA_GOT=" "
+SEPARATE_GOTPLT="SIZEOF (.got.plt) >= 8 ? 8 : 0"
+
+OUTPUT_FORMAT="elf32-xr17032"
diff -urN --no-dereference binutils-clean/ld/emultempl/xr17032elf.em binutils-workdir/ld/emultempl/xr17032elf.em
--- binutils-clean/ld/emultempl/xr17032elf.em	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/ld/emultempl/xr17032elf.em
@@ -0,0 +1,37 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright (C) 2004-2025 Free Software Foundation, Inc.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+
+fragment <<EOF
+
+#include "ldmain.h"
+#include "ldctor.h"
+#include "elf/xr17032.h"
+
+static void
+xr17032_elf_before_allocation (void)
+{
+  gld${EMULATION_NAME}_before_allocation ();
+
+  if (link_info.discard == discard_sec_merge)
+    link_info.discard = discard_l;
+}
+EOF
+
+LDEMUL_BEFORE_ALLOCATION=xr17032_elf_before_allocation
diff -urN --no-dereference binutils-clean/opcodes/Makefile.am binutils-workdir/opcodes/Makefile.am
--- binutils-clean/opcodes/Makefile.am
+++ binutils-workdir/opcodes/Makefile.am
@@ -254,6 +254,8 @@
 	visium-dis.c \
 	visium-opc.c \
 	wasm32-dis.c \
+	xr17032-dis.c \
+	xr17032-opc.c \
 	xstormy16-asm.c \
 	xstormy16-desc.c \
 	xstormy16-dis.c \
diff -urN --no-dereference binutils-clean/opcodes/configure.ac binutils-workdir/opcodes/configure.ac
--- binutils-clean/opcodes/configure.ac
+++ binutils-workdir/opcodes/configure.ac
@@ -343,6 +343,7 @@
 	bfd_visium_arch)	ta="$ta visium-dis.lo visium-opc.lo" ;;
         bfd_wasm32_arch)        ta="$ta wasm32-dis.lo" ;;
 	bfd_xgate_arch)		ta="$ta xgate-dis.lo xgate-opc.lo" ;;
+	bfd_xr17032_arch)	ta="$ta xr17032-dis.lo xr17032-opc.lo" ;;
 	bfd_xstormy16_arch)	ta="$ta xstormy16-asm.lo xstormy16-desc.lo xstormy16-dis.lo xstormy16-ibld.lo xstormy16-opc.lo" using_cgen=yes ;;
 	bfd_xtensa_arch)	ta="$ta xtensa-dis.lo" ;;
 	bfd_z80_arch)		ta="$ta z80-dis.lo" ;;
diff -urN --no-dereference binutils-clean/opcodes/disassemble.c binutils-workdir/opcodes/disassemble.c
--- binutils-clean/opcodes/disassemble.c
+++ binutils-workdir/opcodes/disassemble.c
@@ -97,6 +97,7 @@
 #define ARCH_vax
 #define ARCH_visium
 #define ARCH_wasm32
+#define ARCH_xr17032
 #define ARCH_xstormy16
 #define ARCH_xgate
 #define ARCH_xtensa
@@ -532,6 +533,11 @@
       disassemble = print_insn_loongarch;
       break;
 #endif
+#ifdef ARCH_xr17032
+    case bfd_arch_xr17032:
+      disassemble = print_insn_xr17032;
+      break;
+#endif
     default:
       return 0;
     }
diff -urN --no-dereference binutils-clean/opcodes/disassemble.h binutils-workdir/opcodes/disassemble.h
--- binutils-clean/opcodes/disassemble.h
+++ binutils-workdir/opcodes/disassemble.h
@@ -93,6 +93,7 @@
 extern int print_insn_visium		(bfd_vma, disassemble_info *);
 extern int print_insn_wasm32		(bfd_vma, disassemble_info *);
 extern int print_insn_xgate             (bfd_vma, disassemble_info *);
+extern int print_insn_xr17032		(bfd_vma, disassemble_info *);
 extern int print_insn_xstormy16		(bfd_vma, disassemble_info *);
 extern int print_insn_xtensa		(bfd_vma, disassemble_info *);
 extern int print_insn_z80		(bfd_vma, disassemble_info *);
diff -urN --no-dereference binutils-clean/opcodes/xr17032-dis.c binutils-workdir/opcodes/xr17032-dis.c
--- binutils-clean/opcodes/xr17032-dis.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/opcodes/xr17032-dis.c
@@ -0,0 +1,291 @@
+/* Disassembler code for XR/17032.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Contributed by monkuous
+
+   This file is part of GAS, GDB and the GNU binutils.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "disassemble.h"
+#include "opcode/xr17032.h"
+#include "libiberty.h"
+
+/* Prints the instruction by calling print_arguments after proper matching.  */
+
+static bool
+xr17032_get_insn_data (unsigned int *out, bfd_vma memaddr, struct disassemble_info *info)
+{
+  bfd_byte buffer[4];
+
+  int status = info->read_memory_func (memaddr, buffer, 4, info);
+  if (status)
+    return false;
+
+  *out = bfd_getl32 (buffer);
+  return true;
+}
+
+static const xr17032_opcode *
+xr17032_find_opcode (unsigned int bits)
+{
+  for (const xr17032_opcode *candidate = xr17032_opcodes; candidate->mnemonic;
+       candidate++)
+    {
+      if ((bits & candidate->match_mask) == candidate->opcode_bits)
+	return candidate;
+    }
+
+  return NULL;
+}
+
+static void
+xr17032_print_signed (struct disassemble_info *info, unsigned int data,
+		      int bits, char prefix)
+{
+  unsigned int sign_bit = 1u << (bits - 1);
+
+  if (data & sign_bit)
+    info->fprintf_func (info->stream, "%c-0x%x", prefix,
+			sign_bit - (data & ~sign_bit));
+  else
+    info->fprintf_func (info->stream, "%c0x%x", prefix, data);
+}
+
+static const char *
+xr17032_register_name (unsigned int regr)
+{
+  return xr17032_reg_names[regr];
+}
+
+static const char *
+xr17032_reg_op_name (unsigned int op)
+{
+  static const char *const names[4] =
+  {
+    "LSH",
+    "RSH",
+    "ASH",
+    "ROR",
+  };
+
+  return names[op];
+}
+
+static const char *
+xr17032_control_reg_name (unsigned int cregr)
+{
+  const char *name = xr17032_control_reg_names[cregr];
+
+  if (!name)
+    name = "(unknown control register)";
+
+  return name;
+}
+
+static const char *const xr17032_mem_size_names[] =
+{
+  "byte",
+  "int",
+  "long",
+};
+
+static void
+xr17032_print_memimm (struct disassemble_info *info, unsigned int bits,
+		      int shift, char prefix, int index)
+{
+  unsigned int regr = (bits >> (6 + index * 5)) & 0x1f;
+  unsigned int offset = ((bits >> 16) & 0xffff) << shift;
+
+  const char *size_name = xr17032_mem_size_names[shift];
+  const char *reg_name = xr17032_register_name (regr);
+
+  info->fprintf_func (info->stream, "%c%s [%s + 0x%x]", prefix, size_name,
+		      reg_name, offset);
+}
+
+static void
+xr17032_print_memreg (struct disassemble_info *info, unsigned int bits,
+		      int shift, char prefix)
+{
+  unsigned int base_reg = (bits >> 11) & 0x1f;
+  unsigned int offs_reg = (bits >> 16) & 0x1f;
+  unsigned int op = (bits >> 26) & 3;
+  unsigned int op_val = (bits >> 21) & 0x1f;
+
+  const char *size_name = xr17032_mem_size_names[shift];
+  const char *base_name = xr17032_register_name (base_reg);
+  const char *offs_name = xr17032_register_name (offs_reg);
+  const char *op_name = xr17032_reg_op_name (op);
+
+  info->fprintf_func (info->stream, "%c%s [%s + %s %s %u]", prefix, size_name,
+		      base_name, offs_name, op_name, op_val);
+}
+
+static void
+xr17032_print_operand (struct disassemble_info *info, xr17032_operand type,
+		       unsigned int bits, bfd_vma addr, char prefix, int index)
+{
+  switch (type)
+    {
+    case XR_OP_NONE:
+      break;
+    case XR_OP_JUMP:
+    {
+      bfd_vma value = (addr & 0x80000000) | ((bits >> 1) & 0x7ffffffc);
+      info->fprintf_func (info->stream, "%c", prefix);
+      info->print_address_func (value, info);
+      break;
+    }
+    case XR_OP_BRANCH:
+    {
+      bfd_vma value = (bits >> 9) & 0x7ffffc;
+
+      if (value & 0x400000)
+	value = addr - (0x400000 - (value & 0x3fffff));
+      else
+	value += addr;
+
+      info->fprintf_func (info->stream, "%c", prefix);
+      info->print_address_func (value, info);
+      break;
+    }
+    case XR_OP_IMM:
+    {
+      uint32_t value = (bits >> 16) & 0xffff;
+      info->fprintf_func (info->stream, "%c0x%x", prefix, value);
+      break;
+    }
+    case XR_OP_IMM_1:
+    {
+      uint32_t value = (bits >> 15) & 0x0001fffe;
+      info->fprintf_func (info->stream, "%c0x%x", prefix, value);
+      break;
+    }
+    case XR_OP_IMM_2:
+    {
+      uint32_t value = (bits >> 14) & 0x0003fffc;
+      info->fprintf_func (info->stream, "%c0x%x", prefix, value);
+      break;
+    }
+    case XR_OP_IMM_16:
+    {
+      uint32_t value = bits & 0xffff0000;
+      info->fprintf_func (info->stream, "%c0x%x", prefix, value);
+      break;
+    }
+    case XR_OP_IMM_SIGN:
+      xr17032_print_signed (info, (bits >> 16) & 0xffff, 16, prefix);
+      break;
+    case XR_OP_IMM_SMALL:
+      xr17032_print_signed (info, (bits >> 11) & 0x1f, 5, prefix);
+      break;
+    case XR_OP_REG_A:
+    {
+      unsigned int regr = (bits >> 6) & 0x1f;
+      const char *name = xr17032_register_name (regr);
+      info->fprintf_func (info->stream, "%c%s", prefix, name);
+      break;
+    }
+    case XR_OP_REG_B:
+    {
+      unsigned int regr = (bits >> 11) & 0x1f;
+      const char *name = xr17032_register_name (regr);
+      info->fprintf_func (info->stream, "%c%s", prefix, name);
+      break;
+    }
+    case XR_OP_REG_C:
+    {
+      unsigned int regr = (bits >> 16) & 0x1f;
+      const char *name = xr17032_register_name (regr);
+      info->fprintf_func (info->stream, "%c%s", prefix, name);
+      break;
+    }
+    case XR_OP_REG_C_SHIFT:
+    {
+      unsigned int regr = (bits >> 16) & 0x1f;
+      unsigned int op = (bits >> 26) & 3;
+      unsigned int val = (bits >> 21) & 0x1f;
+      const char *reg_name = xr17032_register_name (regr);
+      const char *op_name = xr17032_reg_op_name (op);
+      info->fprintf_func (info->stream, "%c%s %s %u", prefix, reg_name,
+			  op_name, val);
+      break;
+    }
+    case XR_OP_CREG:
+    {
+      unsigned int cregr = (bits >> 16) & 0x1f;
+      const char *name = xr17032_control_reg_name (cregr);
+      info->fprintf_func (info->stream, "%c%s", prefix, name);
+      break;
+    }
+    case XR_OP_MEM8_IMM:
+      xr17032_print_memimm (info, bits, 0, prefix, index);
+      break;
+    case XR_OP_MEM16_IMM:
+      xr17032_print_memimm (info, bits, 1, prefix, index);
+      break;
+    case XR_OP_MEM32_IMM:
+      xr17032_print_memimm (info, bits, 2, prefix, index);
+      break;
+    case XR_OP_MEM8_REG:
+      xr17032_print_memreg (info, bits, 0, prefix);
+      break;
+    case XR_OP_MEM16_REG:
+      xr17032_print_memreg (info, bits, 1, prefix);
+      break;
+    case XR_OP_MEM32_REG:
+      xr17032_print_memreg (info, bits, 2, prefix);
+      break;
+    }
+}
+
+static void
+xr17032_print_operands(struct disassemble_info *info,
+		       const xr17032_opcode *opcode, unsigned int bits,
+		       bfd_vma addr)
+{
+  for (int i = 0; i < XR_MAX_OPERANDS; i++)
+    {
+      xr17032_operand type = opcode->operands[i];
+
+      if (type == XR_OP_NONE)
+	break;
+
+      xr17032_print_operand (info, type, bits, addr, i == 0 ? '\t' : ',', i);
+    }
+}
+
+int
+print_insn_xr17032 (bfd_vma memaddr, struct disassemble_info *info)
+{
+  unsigned int bits;
+  if (!xr17032_get_insn_data (&bits, memaddr, info))
+    return -1;
+
+  const xr17032_opcode *opcode = xr17032_find_opcode (bits);
+
+  if (!opcode)
+    {
+      info->fprintf_func (info->stream, "(bad)");
+      goto done;
+    }
+
+  info->fprintf_func (info->stream, "%s", opcode->mnemonic);
+  xr17032_print_operands (info, opcode, bits, memaddr);
+
+done:
+  return 4;
+}
diff -urN --no-dereference binutils-clean/opcodes/xr17032-opc.c binutils-workdir/opcodes/xr17032-opc.c
--- binutils-clean/opcodes/xr17032-opc.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-workdir/opcodes/xr17032-opc.c
@@ -0,0 +1,198 @@
+/* xr17032-opc.c -- Table of opcodes for the XR/17032 processor.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Contributed by monkuous
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include <stdio.h>
+#include "libiberty.h"
+#include "symcat.h"
+#include "opcode/xr17032.h"
+
+#define XR_MATCH_J	0x00000007
+#define XR_MATCH_BI	0x0000003f
+#define XR_MATCH_R	0xf000003f
+#define XR_MATCH_RS	0xfc00003f
+
+#define INSN_J(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_J, XR_OPCODE_J_##OPCODE, { __VA_ARGS__ } }
+#define INSN_B(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_BI, XR_OPCODE_B_##OPCODE, { __VA_ARGS__ } }
+#define INSN_I(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_BI, XR_OPCODE_I_##OPCODE, { __VA_ARGS__ } }
+#define INSN_I_1(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_BI, XR_OPCODE_I1_##OPCODE, { __VA_ARGS__ } }
+#define INSN_I_2(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_BI, XR_OPCODE_I2_##OPCODE, { __VA_ARGS__ } }
+#define INSN_I_16(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_BI, XR_OPCODE_I16_##OPCODE, { __VA_ARGS__ } }
+#define INSN_I_16P(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_BI, XR_OPCODE_I16P_##OPCODE, { __VA_ARGS__ } }
+#define INSN_I_S(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_BI, XR_OPCODE_IS_##OPCODE, { __VA_ARGS__ } }
+#define INSN_S(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_BI, XR_OPCODE_S_##OPCODE, { __VA_ARGS__ } }
+#define INSN_S_1(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_BI, XR_OPCODE_S1_##OPCODE, { __VA_ARGS__ } }
+#define INSN_S_2(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_BI, XR_OPCODE_S2_##OPCODE, { __VA_ARGS__ } }
+#define INSN_R(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_R, XR_OPCODE_R_##OPCODE, { __VA_ARGS__ } }
+#define INSN_RS(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_RS, XR_OPCODE_RS_##OPCODE, { __VA_ARGS__ } }
+#define INSN_R2(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_R, XR_OPCODE_R2_##OPCODE, { __VA_ARGS__ } }
+#define INSN_R3(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_R, XR_OPCODE_R3_##OPCODE, { __VA_ARGS__ } }
+#define INSN_R0(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_R, XR_OPCODE_R0_##OPCODE, { __VA_ARGS__ } }
+#define INSN_RC(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_R, XR_OPCODE_RC_##OPCODE, { __VA_ARGS__ } }
+#define INSN_CR(MNEMONIC, OPCODE, ...) \
+  { (MNEMONIC), XR_MATCH_R, XR_OPCODE_CR_##OPCODE, { __VA_ARGS__ } }
+
+const xr17032_opcode xr17032_opcodes[] =
+{
+  INSN_J("j", J, XR_OP_JUMP),
+  INSN_J("jal", JAL, XR_OP_JUMP),
+  INSN_B("beq", BEQ, XR_OP_REG_A, XR_OP_BRANCH),
+  INSN_B("bne", BNE, XR_OP_REG_A, XR_OP_BRANCH),
+  INSN_B("blt", BLT, XR_OP_REG_A, XR_OP_BRANCH),
+  INSN_B("bgt", BGT, XR_OP_REG_A, XR_OP_BRANCH),
+  INSN_B("bge", BGE, XR_OP_REG_A, XR_OP_BRANCH),
+  INSN_B("ble", BLE, XR_OP_REG_A, XR_OP_BRANCH),
+  INSN_B("bpe", BPE, XR_OP_REG_A, XR_OP_BRANCH),
+  INSN_B("bpo", BPO, XR_OP_REG_A, XR_OP_BRANCH),
+  INSN_I("addi", ADDI, XR_OP_REG_A, XR_OP_REG_B, XR_OP_IMM),
+  INSN_I("subi", SUBI, XR_OP_REG_A, XR_OP_REG_B, XR_OP_IMM),
+  INSN_I("slti", SLTI, XR_OP_REG_A, XR_OP_REG_B, XR_OP_IMM),
+  INSN_I_S("slti signed", SLTI_SIGNED, XR_OP_REG_A, XR_OP_REG_B, XR_OP_IMM_SIGN),
+  INSN_I("andi", ANDI, XR_OP_REG_A, XR_OP_REG_B, XR_OP_IMM),
+  INSN_I("xori", XORI, XR_OP_REG_A, XR_OP_REG_B, XR_OP_IMM),
+  INSN_I("ori", ORI, XR_OP_REG_A, XR_OP_REG_B, XR_OP_IMM),
+  INSN_I_16("lui", LUI, XR_OP_REG_A, XR_OP_REG_B, XR_OP_IMM_16),
+  /* assembler relies on all mov variants following one another
+     also, variants are tried in listed order, so reg offset must come first
+     (otherwise stuff like `[t0 + t1]` is interpreted as `t0 + Sym(t1)`) */
+  INSN_R("mov", LB, XR_OP_REG_A, XR_OP_MEM8_REG),
+  INSN_R("mov", LI, XR_OP_REG_A, XR_OP_MEM16_REG),
+  INSN_R("mov", LL, XR_OP_REG_A, XR_OP_MEM32_REG),
+  INSN_R("mov", SB, XR_OP_MEM8_REG, XR_OP_REG_A),
+  INSN_R("mov", SI, XR_OP_MEM16_REG, XR_OP_REG_A),
+  INSN_R("mov", SL, XR_OP_MEM32_REG, XR_OP_REG_A),
+  INSN_I("mov", LB, XR_OP_REG_A, XR_OP_MEM8_IMM),
+  INSN_I_1("mov", LI, XR_OP_REG_A, XR_OP_MEM16_IMM),
+  INSN_I_2("mov", LL, XR_OP_REG_A, XR_OP_MEM32_IMM),
+  INSN_I("mov", SB, XR_OP_MEM8_IMM, XR_OP_REG_B),
+  INSN_I_1("mov", SI, XR_OP_MEM16_IMM, XR_OP_REG_B),
+  INSN_I_2("mov", SL, XR_OP_MEM32_IMM, XR_OP_REG_B),
+  INSN_S("mov", SB, XR_OP_MEM8_IMM, XR_OP_IMM_SMALL),
+  INSN_S_1("mov", SI, XR_OP_MEM16_IMM, XR_OP_IMM_SMALL),
+  INSN_S_2("mov", SL, XR_OP_MEM32_IMM, XR_OP_IMM_SMALL),
+  INSN_I_2("jalr", JALR, XR_OP_REG_A, XR_OP_REG_B, XR_OP_IMM_2),
+  INSN_I_16P("adr", ADR, XR_OP_REG_A, XR_OP_IMM_16),
+  INSN_RS("lsh", LSH, XR_OP_REG_A, XR_OP_REG_C, XR_OP_REG_B),
+  INSN_RS("rsh", RSH, XR_OP_REG_A, XR_OP_REG_C, XR_OP_REG_B),
+  INSN_RS("ash", ASH, XR_OP_REG_A, XR_OP_REG_C, XR_OP_REG_B),
+  INSN_RS("ror", ROR, XR_OP_REG_A, XR_OP_REG_C, XR_OP_REG_B),
+  INSN_R("add", ADD, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("sub", SUB, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("slt", SLT, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("slt signed", SLT_SIGNED, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("and", AND, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("xor", XOR, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("or", OR, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("nor", NOR, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("mul", MUL, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("div", DIV, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("div signed", DIV_SIGNED, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R("mod", MOD, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C_SHIFT),
+  INSN_R2("ll", LL, XR_OP_REG_A, XR_OP_REG_B),
+  INSN_R3("sc", SC, XR_OP_REG_A, XR_OP_REG_B, XR_OP_REG_C),
+  INSN_R0("pause", PAUSE),
+  INSN_R0("mb", PAUSE),
+  INSN_R0("wmb", WMB),
+  INSN_R0("brk", BRK),
+  INSN_R0("sys", SYS),
+  INSN_RC("mfcr", MFCR, XR_OP_REG_A, XR_OP_CREG),
+  INSN_CR("mtcr", MTCR, XR_OP_CREG, XR_OP_REG_B),
+  INSN_R0("hlt", HLT),
+  INSN_R0("rfe", RFE),
+  { },
+};
+
+const char *const xr17032_reg_names[XR_NUM_REGISTERS] = {
+  "zero",
+  "t0",
+  "t1",
+  "t2",
+  "t3",
+  "t4",
+  "t5",
+  "a0",
+  "a1",
+  "a2",
+  "a3",
+  "s0",
+  "s1",
+  "s2",
+  "s3",
+  "s4",
+  "s5",
+  "s6",
+  "s7",
+  "s8",
+  "s9",
+  "s10",
+  "s11",
+  "s12",
+  "s13",
+  "s14",
+  "s15",
+  "s16",
+  "s17",
+  "tp",
+  "sp",
+  "lr",
+};
+
+const char *const xr17032_control_reg_names[XR_NUM_REGISTERS] = {
+  [XR_REGISTER_C_RS] = "rs",
+  [XR_REGISTER_C_WHAMI] = "whami",
+  [XR_REGISTER_C_EB] = "eb",
+  [XR_REGISTER_C_EPC] = "epc",
+  [XR_REGISTER_C_EBADADDR] = "ebadaddr",
+  [XR_REGISTER_C_TBMISSADDR] = "tbmissaddr",
+  [XR_REGISTER_C_TBPC] = "tbpc",
+  [XR_REGISTER_C_SCRATCH0] = "scratch0",
+  [XR_REGISTER_C_SCRATCH1] = "scratch1",
+  [XR_REGISTER_C_SCRATCH2] = "scratch2",
+  [XR_REGISTER_C_SCRATCH3] = "scratch3",
+  [XR_REGISTER_C_SCRATCH4] = "scratch4",
+  [XR_REGISTER_C_ITBPTE] = "itbpte",
+  [XR_REGISTER_C_ITBTAG] = "itbtag",
+  [XR_REGISTER_C_ITBINDEX] = "itbindex",
+  [XR_REGISTER_C_ITBCTRL] = "itbctrl",
+  [XR_REGISTER_C_ICACHECTRL] = "icachectrl",
+  [XR_REGISTER_C_ITBADDR] = "itbaddr",
+  [XR_REGISTER_C_DTBPTE] = "dtbpte",
+  [XR_REGISTER_C_DTBTAG] = "dtbtag",
+  [XR_REGISTER_C_DTBINDEX] = "dtbindex",
+  [XR_REGISTER_C_DTBCTRL] = "dtbctrl",
+  [XR_REGISTER_C_DCACHECTRL] = "dcachectrl",
+  [XR_REGISTER_C_DTBADDR] = "dtbaddr",
+};
