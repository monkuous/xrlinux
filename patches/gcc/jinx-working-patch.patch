diff -urN --no-dereference gcc-clean/gcc/config/xr17032/constraints.md gcc-workdir/gcc/config/xr17032/constraints.md
--- gcc-clean/gcc/config/xr17032/constraints.md	1970-01-01 01:00:00.000000000 +0100
+++ gcc-workdir/gcc/config/xr17032/constraints.md
@@ -0,0 +1,61 @@
+;; Constraint definitions for XR/17032
+;; Copyright (C) 2025-2025 Free Software Foundation, Inc.
+;; Contributed by monkuous
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_constraint "O" "Constant zero"
+  (and (match_code "const_int")
+       (match_test "ival == 0")))
+
+(define_constraint "I" "Unsigned 16-bit immediate"
+  (and (match_code "const_int")
+       (match_test "SMALL_OPERAND (ival)")))
+
+(define_constraint "J" "Signed 16-bit immediate"
+  (and (match_code "const_int")
+       (match_test "SMALL_OPERAND_SIGNED (ival)")))
+
+(define_constraint "K" "Signed 5-bit immediate"
+  (and (match_code "const_int")
+       (match_test "(unsigned HOST_WIDE_INT) (ival) + 16 < 32")))
+
+(define_constraint "L" "Unsigned 5-bit immediate"
+  (and (match_code "const_int")
+       (match_test "(unsigned HOST_WIDE_INT) (ival) < 32")))
+
+(define_constraint "M" "All ones"
+  (and (match_code "const_int")
+       (match_test "((unsigned HOST_WIDE_INT) (ival) & 0xffffffff) == 0xffffffff")))
+
+(define_constraint "P" "Negative unsigned 16-bit immediate"
+  (and (match_code "const_int")
+       (match_test "(unsigned HOST_WIDE_INT) (ival) + (IMM_REACH - 1)
+                    < IMM_REACH")))
+
+(define_constraint "S"
+  "A constraint that matches an absolute symbolic address."
+  (match_operand 0 "xr17032_absolute_symbolic_operand"))
+
+(define_constraint "R"
+  "A constraint that matches a PC-relative symbolic address."
+  (match_operand 0 "xr17032_pcrel_symbolic_operand"))
+
+(define_constraint "A"
+  "Memory operand whose address is a single register"
+  (and (match_code "mem")
+       (match_test "GET_CODE (XEXP (op, 0)) == REG")))
diff -urN --no-dereference gcc-clean/gcc/config/xr17032/predicates.md gcc-workdir/gcc/config/xr17032/predicates.md
--- gcc-clean/gcc/config/xr17032/predicates.md	1970-01-01 01:00:00.000000000 +0100
+++ gcc-workdir/gcc/config/xr17032/predicates.md
@@ -0,0 +1,119 @@
+;; Predicate description for XR/17032
+;; Copyright (C) 2025-2025 Free Software Foundation, Inc.
+;; Contributed by monkuous
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_predicate "xr17032_reg_shift_operand"
+  (ior (match_operand 0 "register_operand")
+       (and (match_code "mult")
+	    (match_test "register_operand (XEXP (op, 0), Pmode)")
+	    (match_test "CONST_INT_P (XEXP (op, 1))")
+	    (match_test "pow2p_hwi (INTVAL (XEXP (op, 1)))")
+	    (match_test "IN_RANGE (exact_log2 (INTVAL (XEXP(op, 1))), 0, 31)"))
+       (and (match_code "div")
+	    (match_test "register_operand (XEXP (op, 0), Pmode)")
+	    (match_test "CONST_INT_P (XEXP (op, 1))")
+	    (match_test "pow2p_hwi (INTVAL (XEXP (op, 1)))")
+	    (match_test "IN_RANGE (exact_log2 (INTVAL (XEXP(op, 1))), 0, 31)"))
+       (and (match_code "ashift")
+	    (match_test "register_operand (XEXP (op, 0), Pmode)")
+	    (match_test "CONST_INT_P (XEXP (op, 1))")
+	    (match_test "IN_RANGE (INTVAL (XEXP (op, 1)), 0, 31)"))
+       (and (match_code "rotate")
+	    (match_test "register_operand (XEXP (op, 0), Pmode)")
+	    (match_test "CONST_INT_P (XEXP (op, 1))")
+	    (match_test "IN_RANGE (INTVAL (XEXP (op, 1)), 0, 31)"))
+       (and (match_code "ashiftrt")
+	    (match_test "register_operand (XEXP (op, 0), Pmode)")
+	    (match_test "CONST_INT_P (XEXP (op, 1))")
+	    (match_test "IN_RANGE (INTVAL (XEXP (op, 1)), 0, 31)"))
+       (and (match_code "lshiftrt")
+	    (match_test "register_operand (XEXP (op, 0), Pmode)")
+	    (match_test "CONST_INT_P (XEXP (op, 1))")
+	    (match_test "IN_RANGE (INTVAL (XEXP (op, 1)), 0, 31)"))
+       (and (match_code "rotatert")
+	    (match_test "register_operand (XEXP (op, 0), Pmode)")
+	    (match_test "CONST_INT_P (XEXP (op, 1))")
+	    (match_test "IN_RANGE (INTVAL (XEXP (op, 1)), 0, 31)"))))
+
+(define_predicate "xr17032_reg_or_0_operand"
+  (ior (match_operand 0 "register_operand")
+       (and (match_code "const_int")
+	    (match_test "INTVAL (op) == 0"))))
+
+(define_predicate "xr17032_tinyimm_operand"
+  (and (match_code "const_int")
+       (match_test "(unsigned HOST_WIDE_INT) INTVAL (op) + 16 < 32")))
+
+(define_predicate "xr17032_smallimm_operand"
+  (and (match_code "const_int")
+       (match_test "SMALL_OPERAND (INTVAL (op))")))
+
+(define_predicate "xr17032_smallimm_operand_signed"
+  (and (match_code "const_int")
+       (match_test "SMALL_OPERAND_SIGNED (INTVAL (op))")))
+
+(define_predicate "xr17032_move_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "memory_operand")
+       (match_operand 0 "xr17032_smallimm_operand")
+       (and (match_code "const_int")
+            (match_test "(unsigned HOST_WIDE_INT) INTVAL (op) + (IMM_REACH - 1)
+                         < IMM_REACH"))))
+
+(define_predicate "xr17032_arith_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "xr17032_smallimm_operand")))
+
+(define_predicate "xr17032_arith_operand_signed"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "xr17032_smallimm_operand_signed")))
+
+(define_predicate "xr17032_absolute_symbolic_operand"
+  (match_code "const,symbol_ref,label_ref")
+{
+  enum xr17032_symbol_type type;
+  return (xr17032_symbolic_constant_p (op, &type)
+	  && (type == XR17032_SYMBOL_ABSOLUTE));
+})
+
+(define_predicate "xr17032_pcrel_symbolic_operand"
+  (match_code "const,symbol_ref,label_ref")
+{
+  enum xr17032_symbol_type type;
+  return (xr17032_symbolic_constant_p (op, &type)
+	  && (type == XR17032_SYMBOL_PCREL));
+})
+
+(define_predicate "xr17032_slt_operator"
+  (match_code "lt,ltu"))
+
+(define_predicate "xr17032_xor_arith_operand"
+  (ior (match_operand 0 "xr17032_arith_operand")
+       (and (match_code "const_int")
+	    (match_test "(INTVAL(op) & 0xffffffff) == 0xffffffff"))))
+
+(define_predicate "xr17032_shift_operand"
+  (ior (match_operand 0 "register_operand")
+       (and (match_code "const_int")
+	    (match_test "(unsigned HOST_WIDE_INT) INTVAL (op) < 32"))))
+
+(define_predicate "xr17032_call_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "xr17032_absolute_symbolic_operand")
+       (match_operand 0 "xr17032_pcrel_symbolic_operand")))
diff -urN --no-dereference gcc-clean/gcc/config/xr17032/xr17032-protos.h gcc-workdir/gcc/config/xr17032/xr17032-protos.h
--- gcc-clean/gcc/config/xr17032/xr17032-protos.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-workdir/gcc/config/xr17032/xr17032-protos.h
@@ -0,0 +1,39 @@
+/* Prototypes for xr17032.cc functions used in the md file & elsewhere.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_XR17032_PROTOS_H
+#define GCC_XR17032_PROTOS_H
+
+enum xr17032_symbol_type
+{
+  XR17032_SYMBOL_ABSOLUTE,
+  XR17032_SYMBOL_PCREL,
+};
+
+extern int xr17032_regno_ok_for_base_p (int, bool);
+extern poly_int64 xr17032_initial_elimination_offset (int, int);
+extern void xr17032_expand_prologue (void);
+extern void xr17032_expand_epilogue (void);
+extern rtx xr17032_return_addr (int);
+extern void xr17032_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree,
+					  int);
+extern bool xr17032_symbolic_constant_p (rtx, enum xr17032_symbol_type *);
+extern enum memmodel xr17032_union_memmodel (enum memmodel a, enum memmodel b);
+
+#endif /* GCC_XR17032_PROTOS_H */
diff -urN --no-dereference gcc-clean/gcc/config/xr17032/xr17032.cc gcc-workdir/gcc/config/xr17032/xr17032.cc
--- gcc-clean/gcc/config/xr17032/xr17032.cc	1970-01-01 01:00:00.000000000 +0100
+++ gcc-workdir/gcc/config/xr17032/xr17032.cc
@@ -0,0 +1,1286 @@
+/* Target Code for XR/17032
+   Copyright (C) 2025-2025 Free Softwa*re Foundation, Inc.
+   Contributed by monkuous.
+   Based on the RISC-V target.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#define IN_TARGET_CODE 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "target.h"
+#include "backend.h"
+#include "tm.h"
+#include "rtl.h"
+#include "regs.h"
+#include "insn-config.h"
+#include "insn-attr.h"
+#include "recog.h"
+#include "output.h"
+#include "alias.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "attribs.h"
+#include "varasm.h"
+#include "stor-layout.h"
+#include "calls.h"
+#include "function.h"
+#include "explow.h"
+#include "ifcvt.h"
+#include "memmodel.h"
+#include "emit-rtl.h"
+#include "reload.h"
+#include "tm_p.h"
+#include "basic-block.h"
+#include "expr.h"
+#include "optabs.h"
+#include "bitmap.h"
+#include "df.h"
+#include "function-abi.h"
+#include "diagnostic.h"
+#include "builtins.h"
+#include "predict.h"
+#include "tree-pass.h"
+#include "opts.h"
+#include "tm-constrs.h"
+#include "rtl-iter.h"
+#include "gimple.h"
+#include "cfghooks.h"
+#include "cfgloop.h"
+#include "cfgrtl.h"
+#include "shrink-wrap.h"
+#include "sel-sched.h"
+#include "sched-int.h"
+#include "fold-const.h"
+#include "gimple-iterator.h"
+#include "gimple-expr.h"
+#include "tree-vectorizer.h"
+#include "gcse.h"
+#include "tree-dfa.h"
+#include "target-globals.h"
+#include "cgraph.h"
+#include "langhooks.h"
+#include "gimplify.h"
+
+/* This file should be included last.  */
+#include "target-def.h"
+
+/* Information about a function's frame layout.  */
+struct GTY(())  xr17032_frame_info {
+  /* The size of the frame in bytes.  */
+  poly_int64 total_size;
+
+  /* Bit X is set if the function saves or restores GPR X.  */
+  unsigned int mask;
+
+  /* Offsets of fixed-point save area from frame bottom */
+  poly_int64 gp_sp_offset;
+
+  /* Offset of virtual frame pointer from stack pointer/frame bottom */
+  poly_int64 frame_pointer_offset;
+
+  /* Offset of hard frame pointer from stack pointer/frame bottom */
+  poly_int64 hard_frame_pointer_offset;
+
+  /* The offset of arg_pointer_rtx from the bottom of the frame.  */
+  poly_int64 arg_pointer_offset;
+
+  /* Reset this struct, clean all field to zero.  */
+  void reset(void);
+};
+
+struct GTY(()) machine_function {
+  /* The number of extra stack bytes taken up by register varargs.
+     This area is allocated by the callee at the very top of the frame.  */
+  int varargs_size;
+
+  /* True if current function is a naked function.  */
+  bool naked_p;
+
+  /* True if attributes on current function have been checked.  */
+  bool attributes_checked_p;
+
+  /* True if RA must be saved because of a far jump.  */
+  bool far_jump_used;
+
+  /* The current frame information, calculated by xr17032_compute_frame_info.  */
+  struct xr17032_frame_info frame;
+
+  /* The components already handled by separate shrink-wrapping, which should
+     not be considered by the prologue and epilogue.  */
+  bool reg_is_wrapped_separately[FIRST_PSEUDO_REGISTER];
+};
+
+/* If non-zero, this is an offset to be added to SP to redefine the CFA
+   when restoring the FP register from the stack.  Only valid when generating
+   the epilogue.  */
+static poly_int64 epilogue_cfa_sp_offset;
+
+void xr17032_frame_info::reset(void)
+{
+  total_size = 0;
+  mask = 0;
+
+  gp_sp_offset = 0;
+
+  frame_pointer_offset = 0;
+
+  hard_frame_pointer_offset = 0;
+
+  arg_pointer_offset = 0;
+}
+
+static struct machine_function *
+xr17032_init_machine_status (void)
+{
+  return ggc_cleared_alloc<machine_function> ();
+}
+
+void
+xr17032_option_override (void)
+{
+  init_machine_status = &xr17032_init_machine_status;
+}
+
+/* Handle stack align for poly_int.  */
+static poly_int64
+xr17032_stack_align (poly_int64 value)
+{
+  return aligned_upper_bound (value, STACK_BOUNDARY / 8);
+}
+
+static HOST_WIDE_INT
+xr17032_stack_align (HOST_WIDE_INT value)
+{
+  return (value + ((STACK_BOUNDARY / 8) - 1)) & ~((STACK_BOUNDARY / 8) - 1);
+}
+
+int
+xr17032_regno_ok_for_base_p (int regno, bool strict_p)
+{
+  if (regno >= FIRST_PSEUDO_REGISTER)
+    {
+      if (!strict_p)
+	return true;
+      regno = reg_renumber[regno];
+    }
+
+  if (regno == ARG_POINTER_REGNUM || regno == FRAME_POINTER_REGNUM)
+    return true;
+
+  return REGNO_REG_CLASS (regno) == GENERAL_REGS;
+}
+
+static bool
+xr17032_far_jump_used_p ()
+{
+  size_t func_size = 0;
+
+  if (cfun->machine->far_jump_used)
+    return true;
+
+  /* We can't change far_jump_used during or after reload, as there is
+     no chance to change stack frame layout.  So we must rely on the
+     conservative heuristic below having done the right thing.  */
+  if (reload_in_progress || reload_completed)
+    return false;
+
+  /* Estimate the function length.  */
+  for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))
+    func_size += get_attr_length (insn);
+
+  /* Conservatively determine whether some jump might exceed 4 MiB
+     displacement.  */
+  if (func_size * 4 >= 0x400000)
+    cfun->machine->far_jump_used = true;
+
+  return cfun->machine->far_jump_used;
+}
+
+static bool
+xr17032_save_return_addr_reg_p (void)
+{
+  /* The lr register is call-clobbered: if this is not a leaf function,
+     save it.  */
+  if (!crtl->is_leaf)
+    return true;
+
+  /* We need to save the incoming return address if __builtin_eh_return
+     is being used to set a different return address.  */
+  if (crtl->calls_eh_return)
+    return true;
+
+  /* Far jumps/branches use lr as a temporary to set up the target jump
+     location (clobbering the incoming return address).  */
+  if (xr17032_far_jump_used_p ())
+    return true;
+
+  /* We need to save it if anyone has used that.  */
+  if (df_regs_ever_live_p (XR17032_LR))
+    return true;
+
+  if (frame_pointer_needed && crtl->is_leaf)
+    return true;
+
+  return false;
+}
+
+static bool
+xr17032_save_reg_p (unsigned int regno)
+{
+  bool call_saved = !global_regs[regno] && !call_used_or_fixed_reg_p (regno);
+  bool might_clobber = crtl->saves_all_registers
+		       || df_regs_ever_live_p (regno);
+
+  if (call_saved && might_clobber)
+    return true;
+
+  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)
+    return true;
+
+  if (regno == XR17032_LR && xr17032_save_return_addr_reg_p ())
+    return true;
+
+  return false;
+}
+
+static void
+xr17032_compute_frame_info (void)
+{
+  struct xr17032_frame_info *frame;
+  poly_int64 offset;
+  unsigned int regno, i, num_x_saved = 0, x_save_size = 0;
+
+  frame = &cfun->machine->frame;
+
+  /* Adjust the outgoing arguments size if required.  Keep it in sync with what
+     the mid-end is doing.  */
+  crtl->outgoing_args_size = STACK_DYNAMIC_OFFSET (cfun);
+
+  frame->reset();
+
+  if (!cfun->machine->naked_p)
+    {
+      /* Find out which GPRs we need to save.  */
+      for (regno = 0; regno <= 31; regno++)
+	if (xr17032_save_reg_p (regno))
+	  frame->mask |= 1 << regno, num_x_saved++;
+
+      /* If this function calls eh_return, we must also save and restore the
+	 EH data registers.  */
+      if (crtl->calls_eh_return)
+	for (i = 0; (regno = EH_RETURN_DATA_REGNO (i)) != INVALID_REGNUM; i++)
+	  frame->mask |= 1 << regno, num_x_saved++;
+    }
+
+  if (frame->mask)
+    {
+      x_save_size = xr17032_stack_align (num_x_saved * UNITS_PER_WORD);
+    }
+
+  /* At the bottom of the frame are any outgoing stack arguments. */
+  offset = xr17032_stack_align (crtl->outgoing_args_size);
+  /* The frame pointer points to the local variables. */
+  frame->hard_frame_pointer_offset = offset;
+  frame->frame_pointer_offset = offset;
+  /* Next are local stack variables. */
+  offset += xr17032_stack_align (get_frame_size ());
+  /* Next are the callee-saved GPRs. */
+  if (frame->mask)
+    {
+      offset += x_save_size;
+    }
+  frame->gp_sp_offset = offset - UNITS_PER_WORD;
+  /* Above the saved GPRs is the callee-allocated varags save area. */
+  offset += xr17032_stack_align (cfun->machine->varargs_size);
+  /* Next is the callee-allocated area for pretend stack arguments.  */
+  offset += xr17032_stack_align (crtl->args.pretend_args_size);
+  /* Arg pointer must be below pretend args, but must be above alignment
+     padding.  */
+  frame->arg_pointer_offset = offset - crtl->args.pretend_args_size;
+  frame->total_size = offset;
+
+  /* Next points the incoming stack pointer and any incoming arguments. */
+}
+
+poly_int64
+xr17032_initial_elimination_offset (int from, int to)
+{
+  poly_int64 src, dest;
+
+  xr17032_compute_frame_info ();
+
+  if (to == HARD_FRAME_POINTER_REGNUM)
+    dest = cfun->machine->frame.hard_frame_pointer_offset;
+  else if (to == STACK_POINTER_REGNUM)
+    dest = 0; /* The stack pointer is the base of all offsets, hence 0.  */
+  else
+    gcc_unreachable ();
+
+  if (from == FRAME_POINTER_REGNUM)
+    src = cfun->machine->frame.frame_pointer_offset;
+  else if (from == ARG_POINTER_REGNUM)
+    src = cfun->machine->frame.arg_pointer_offset;
+  else
+    gcc_unreachable ();
+
+  return src - dest;
+}
+
+static bool
+xr17032_valid_base_register_p (rtx x, bool strict_p)
+{
+  if (!strict_p && SUBREG_P (x))
+    x = SUBREG_REG (x);
+
+  return (REG_P (x) && xr17032_regno_ok_for_base_p (REGNO (x), strict_p));
+}
+
+static bool
+xr17032_valid_const_offset_p (HOST_WIDE_INT offset, machine_mode mode)
+{
+  unsigned size = GET_MODE_SIZE (mode);
+  unsigned single_size = size <= UNITS_PER_WORD ? size : UNITS_PER_WORD;
+  unsigned single_mask = single_size - 1;
+
+  if (offset < 0)
+    return false;
+
+  if (offset & single_mask)
+    return false;
+
+  if (offset / single_size >= IMM_REACH)
+    return false;
+
+  if (size > UNITS_PER_WORD && SMALL_OPERAND((offset + size - UNITS_PER_WORD)
+				/ UNITS_PER_WORD))
+    return false;
+
+  return true;
+}
+
+static bool
+xr17032_valid_offset_p (rtx x, machine_mode mode)
+{
+  if (xr17032_reg_shift_operand (x, mode))
+    return true;
+
+  if (CONST_INT_P (x) && xr17032_valid_const_offset_p (INTVAL (x), mode))
+    return true;
+
+  return false;
+}
+
+static bool
+xr17032_legitimate_address_p (machine_mode mode, rtx x, bool strict_p,
+			      code_helper = ERROR_MARK)
+{
+  switch (GET_CODE (x))
+    {
+    case REG:
+    case SUBREG:
+      return xr17032_valid_base_register_p (x, strict_p);
+    case PLUS:
+      return xr17032_valid_base_register_p (XEXP (x, 0), strict_p)
+	     && xr17032_valid_offset_p (XEXP (x, 1), mode);
+    case CONST_INT:
+      return xr17032_valid_const_offset_p (INTVAL (x), mode);
+    default:
+      return false;
+    }
+}
+
+/* For stack frames that can't be allocated with a single ADDI instruction,
+   compute the best value to initially allocate.  It must at a minimum
+   allocate enough space to spill the callee-saved registers.  */
+
+static HOST_WIDE_INT
+xr17032_first_stack_step (struct xr17032_frame_info *frame,
+			  poly_int64 remaining_size)
+{
+  HOST_WIDE_INT remaining_const_size;
+  if (!remaining_size.is_constant ())
+    remaining_const_size
+      = xr17032_stack_align (remaining_size.coeffs[0])
+	- xr17032_stack_align (remaining_size.coeffs[1]);
+  else
+    remaining_const_size = remaining_size.to_constant ();
+
+  if (SMALL_OPERAND (remaining_const_size))
+    return remaining_const_size;
+
+  poly_int64 callee_saved_first_step =
+    remaining_size - frame->frame_pointer_offset;
+  gcc_assert(callee_saved_first_step.is_constant ());
+  HOST_WIDE_INT min_first_step =
+    xr17032_stack_align (callee_saved_first_step.to_constant ());
+  HOST_WIDE_INT max_first_step = IMM_REACH - STACK_BOUNDARY / 8;
+  HOST_WIDE_INT min_second_step = remaining_const_size - max_first_step;
+  gcc_assert (min_first_step <= max_first_step);
+
+  /* As an optimization, use the least-significant bits of the total frame
+     size, so that the second adjustment step is just LUI + ADD.  */
+  if (!SMALL_OPERAND (min_second_step)
+      && remaining_const_size % IMM_REACH <= max_first_step
+      && remaining_const_size % IMM_REACH >= min_first_step)
+    return remaining_const_size % IMM_REACH;
+
+  return max_first_step;
+}
+
+/* A function to save or store a register.  The first argument is the
+   register and the second is the stack slot.  */
+typedef void (*xr17032_save_restore_fn) (rtx, rtx);
+
+/* Use FN to save or restore register REGNO.  MODE is the register's
+   mode and OFFSET is the offset of its save slot from the current
+   stack pointer.  */
+
+static void
+xr17032_save_restore_reg (machine_mode mode, int regno,
+			  HOST_WIDE_INT offset, xr17032_save_restore_fn fn)
+{
+  rtx mem;
+
+  mem = gen_frame_mem (mode, plus_constant (Pmode, stack_pointer_rtx, offset));
+  fn (gen_rtx_REG (mode, regno), mem);
+}
+
+/* Return the next register up from REGNO up to LIMIT for the callee
+ *  to save or restore.  OFFSET will be adjusted accordingly.
+ *  If INC is set, then REGNO will be incremented first.
+ *  Returns INVALID_REGNUM if there is no such next register.  */
+
+static unsigned int
+xr17032_next_saved_reg (unsigned int regno, unsigned int limit,
+			HOST_WIDE_INT *offset, bool inc = true)
+{
+  if (inc)
+    regno++;
+
+  while (regno <= limit)
+  {
+    if (cfun->machine->frame.mask & (1U << regno))
+    {
+      *offset = *offset - UNITS_PER_WORD;
+      return regno;
+    }
+
+    regno++;
+  }
+  return INVALID_REGNUM;
+}
+
+/* Call FN for each register that is saved by the current function.
+   SP_OFFSET is the offset of the current stack pointer from the start
+   of the frame.  */
+
+static void
+xr17032_for_each_saved_reg (poly_int64 sp_offset, xr17032_save_restore_fn fn)
+{
+  HOST_WIDE_INT offset;
+  unsigned int regno;
+  unsigned int start = 0;
+  unsigned int limit = 31;
+
+  /* Save the link register and s-registers. */
+  offset = (cfun->machine->frame.gp_sp_offset - sp_offset).to_constant ()
+	   + UNITS_PER_WORD;
+  for (regno = xr17032_next_saved_reg (start, limit, &offset, false);
+       regno != INVALID_REGNUM;
+       regno = xr17032_next_saved_reg (regno, limit, &offset))
+    {
+      if (cfun->machine->reg_is_wrapped_separately[regno])
+	continue;
+
+      xr17032_save_restore_reg (word_mode, regno, offset, fn);
+    }
+}
+
+static void
+xr17032_emit_stack_tie (rtx reg)
+{
+  emit_insn (gen_xr17032_stack_tiesi (stack_pointer_rtx, reg));
+}
+
+/* Constant VAL is known to be sum of two U16 constants.  Break it into
+   comprising BASE and OFF.
+   Numerically U16 is 0 to 65535, however it uses the more conservative
+   range 0 to 65528 as offsets pertain to stack related registers.  */
+
+void
+xr17032_split_sum_of_two_u16 (HOST_WIDE_INT val, HOST_WIDE_INT *base,
+			      HOST_WIDE_INT *off)
+{
+  if (SUM_OF_TWO_U16_ALGN (val))
+    {
+      *base = IMM_REACH & ~3;
+      *off = val - *base;
+    }
+  else
+    {
+      gcc_unreachable ();
+    }
+}
+
+/* Emit a move from SRC to DEST.  Assume that the move expanders can
+   handle all moves if !can_create_pseudo_p ().  The distinction is
+   important because, unlike emit_move_insn, the move expanders know
+   how to force Pmode objects into the constant pool even when the
+   constant pool address is not itself legitimate.  */
+
+rtx
+xr17032_emit_move (rtx dest, rtx src)
+{
+  return (can_create_pseudo_p ()
+	  ? emit_move_insn (dest, src)
+	  : emit_move_insn_1 (dest, src));
+}
+
+/* Make the last instruction frame-related and note that it performs
+   the operation described by FRAME_PATTERN.  */
+
+static void
+xr17032_set_frame_expr (rtx frame_pattern)
+{
+  rtx insn;
+
+  insn = get_last_insn ();
+  RTX_FRAME_RELATED_P (insn) = 1;
+  REG_NOTES (insn) = alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,
+				      frame_pattern,
+				      REG_NOTES (insn));
+}
+
+/* Return a frame-related rtx that stores REG at MEM.
+   REG must be a single register.  */
+
+static rtx
+xr17032_frame_set (rtx mem, rtx reg)
+{
+  rtx set = gen_rtx_SET (mem, reg);
+  RTX_FRAME_RELATED_P (set) = 1;
+  return set;
+}
+
+/* Save register REG to MEM.  Make the instruction frame-related.  */
+
+static void
+xr17032_save_reg (rtx reg, rtx mem)
+{
+  xr17032_emit_move (mem, reg);
+  xr17032_set_frame_expr (xr17032_frame_set (mem, reg));
+}
+
+/* Copy VALUE to a register and return that register.  If new pseudos
+   are allowed, copy it into a new register, otherwise use DEST.  */
+
+static rtx
+xr17032_force_temporary (rtx dest, rtx value)
+{
+  if (can_create_pseudo_p ())
+    return force_reg (Pmode, value);
+  else
+    {
+      xr17032_emit_move (dest, value);
+      return dest;
+    }
+}
+
+/* Allocate SIZE bytes of stack space using TEMP1 as a scratch register.  */
+
+static void
+xr17032_allocate_and_probe_stack_space (rtx temp1, HOST_WIDE_INT size)
+{
+  rtx insn;
+
+  if (SMALL_OPERAND (size))
+    {
+      insn = gen_sub3_insn (stack_pointer_rtx, stack_pointer_rtx,
+			    GEN_INT (size));
+      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
+    }
+  else if (SUM_OF_TWO_U16_ALGN (size))
+    {
+      HOST_WIDE_INT one, two;
+      xr17032_split_sum_of_two_u16 (size, &one, &two);
+      insn = gen_sub3_insn (stack_pointer_rtx, stack_pointer_rtx,
+			    GEN_INT (one));
+      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
+      insn = gen_sub3_insn (stack_pointer_rtx, stack_pointer_rtx,
+			    GEN_INT (two));
+      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
+    }
+  else
+    {
+      temp1 = xr17032_force_temporary (temp1, GEN_INT (size));
+      emit_insn (gen_sub3_insn (stack_pointer_rtx, stack_pointer_rtx, temp1));
+      insn = plus_constant (Pmode, stack_pointer_rtx, size);
+      insn = gen_rtx_SET (stack_pointer_rtx, insn);
+      xr17032_set_frame_expr (insn);
+    }
+
+  /* We must have allocated the remainder of the stack frame.
+     Emit a stack tie if we have a frame pointer so that the
+     allocation is ordered WRT fp setup and subsequent writes
+     into the frame.  */
+  if (frame_pointer_needed)
+    xr17032_emit_stack_tie (hard_frame_pointer_rtx);
+}
+
+void
+xr17032_expand_prologue (void)
+{
+  struct xr17032_frame_info *frame = &cfun->machine->frame;
+  poly_int64 remaining_size = frame->total_size;
+  rtx insn;
+
+  if (cfun->machine->naked_p)
+    return;
+
+  /* Save the GP registers */
+  if (frame->mask != 0)
+    {
+      if (known_gt (remaining_size, frame->frame_pointer_offset))
+	{
+	  HOST_WIDE_INT step1 = xr17032_first_stack_step (frame,
+							  remaining_size);
+	  remaining_size -= step1;
+	  insn = gen_sub3_insn (stack_pointer_rtx, stack_pointer_rtx,
+				GEN_INT (step1));
+	  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
+	}
+      xr17032_for_each_saved_reg (remaining_size, xr17032_save_reg);
+    }
+
+  /* Set up the frame pointer, if we're using one.  */
+  if (frame_pointer_needed)
+    {
+      insn = gen_add3_insn (hard_frame_pointer_rtx, stack_pointer_rtx,
+			    GEN_INT ((frame->hard_frame_pointer_offset - remaining_size).to_constant ()));
+      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
+
+      xr17032_emit_stack_tie (hard_frame_pointer_rtx);
+    }
+
+  /* Allocate the rest of the frame.  */
+  if (known_gt (remaining_size, 0))
+    {
+      gcc_assert (remaining_size.is_constant ());
+      xr17032_allocate_and_probe_stack_space (XR17032_PROLOGUE_TEMP (Pmode),
+					      remaining_size.to_constant ());
+    }
+}
+
+bool
+xr17032_can_use_return_insn (void)
+{
+  return reload_completed && known_eq (cfun->machine->frame.total_size, 0);
+}
+
+static void
+xr17032_restore_reg (rtx reg, rtx mem)
+{
+  rtx insn = xr17032_emit_move (reg, mem);
+  xr17032_set_frame_expr (xr17032_frame_set (reg, mem));
+  rtx dwarf = NULL_RTX;
+  dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);
+
+  if (known_gt (epilogue_cfa_sp_offset, 0)
+      && REGNO (reg) == HARD_FRAME_POINTER_REGNUM)
+    {
+      rtx cfa_adjust_rtx
+	= gen_rtx_PLUS (Pmode, stack_pointer_rtx,
+			gen_int_mode (epilogue_cfa_sp_offset, Pmode));
+      dwarf = alloc_reg_note (REG_CFA_DEF_CFA, cfa_adjust_rtx, dwarf);
+    }
+
+  REG_NOTES (insn) = dwarf;
+  RTX_FRAME_RELATED_P (insn) = 1;
+}
+
+void
+xr17032_expand_epilogue (void)
+{
+  /* Split the frame into 2 steps. STEP1 is the amount of stack we should
+     deallocate before restoring the registers. STEP2 is the amount we
+     should deallocate afterwards including the callee saved regs.
+
+     Start off by assuming that no registers need to be restored.  */
+  struct xr17032_frame_info *frame = &cfun->machine->frame;
+  poly_int64 step2 = 0;
+
+  rtx insn;
+
+  /* We need to add memory barrier to prevent read from deallocated stack.  */
+  bool need_barrier_p = known_ne (get_frame_size ()
+				  + cfun->machine->frame.arg_pointer_offset, 0);
+
+  if (cfun->machine->naked_p)
+    return;
+
+  if (xr17032_can_use_return_insn ())
+    {
+      emit_jump_insn (gen_xr17032_return ());
+      return;
+    }
+
+  /* Reset the epilogue cfa info before starting to emit the epilogue.  */
+  epilogue_cfa_sp_offset = 0;
+
+  /* Move past any dynamic stack allocations.  */
+  if (cfun->calls_alloca)
+    {
+      /* Emit a barrier to prevent loads from a deallocated stack.  */
+      xr17032_emit_stack_tie (hard_frame_pointer_rtx);
+      need_barrier_p = false;
+
+      poly_int64 adjust_offset = -frame->hard_frame_pointer_offset;
+      rtx dwarf_adj = gen_int_mode (adjust_offset, Pmode);
+      rtx adjust = NULL_RTX;
+      bool sum_of_two_u16 = false;
+      HOST_WIDE_INT one, two;
+
+      gcc_assert (adjust_offset.is_constant ());
+
+      HOST_WIDE_INT adj_off_value = adjust_offset.to_constant ();
+      if (SMALL_OPERAND (adj_off_value))
+	{
+	  adjust = GEN_INT (adj_off_value);
+	}
+      else if (SUM_OF_TWO_U16_ALGN (adj_off_value))
+	{
+	  xr17032_split_sum_of_two_u16 (adj_off_value, &one, &two);
+	  dwarf_adj = adjust = GEN_INT (one);
+	  sum_of_two_u16 = true;
+	}
+      else
+	{
+	  xr17032_emit_move (XR17032_PROLOGUE_TEMP (Pmode),
+			     GEN_INT (adj_off_value));
+	  adjust = XR17032_PROLOGUE_TEMP (Pmode);
+	}
+
+      insn = emit_insn (
+	       gen_add3_insn (stack_pointer_rtx, hard_frame_pointer_rtx,
+			      adjust));
+
+      rtx dwarf = NULL_RTX;
+      rtx cfa_adjust_value = gen_rtx_PLUS (Pmode, hard_frame_pointer_rtx,
+					   dwarf_adj);
+      rtx cfa_adjust_rtx = gen_rtx_SET (stack_pointer_rtx, cfa_adjust_value);
+      dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA, cfa_adjust_rtx, dwarf);
+
+      RTX_FRAME_RELATED_P (insn) = 1;
+
+      REG_NOTES (insn) = dwarf;
+
+      if (sum_of_two_u16)
+	{
+	  insn = emit_insn (gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,
+			    GEN_INT (two)));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	}
+    }
+
+  if (frame->mask != 0)
+    step2 = xr17032_first_stack_step (frame, frame->total_size);
+
+  poly_int64 step1 = frame->total_size - step2;
+
+  /* Set TARGET to BASE + STEP1.  */
+  if (known_gt (step1, 0))
+    {
+      /* Emit a barrier to prevent loads from a deallocated stack.  */
+      xr17032_emit_stack_tie (hard_frame_pointer_rtx);
+      need_barrier_p = false;
+
+      gcc_assert (step1.is_constant ());
+
+      /* Get an rtx for STEP1 that we can add to BASE.
+	 Skip if adjust equal to zero.  */
+      HOST_WIDE_INT step1_value = step1.to_constant ();
+      if (step1_value != 0)
+	{
+	  rtx adjust = GEN_INT (step1_value);
+	  if (SUM_OF_TWO_U16_ALGN (step1_value))
+	    {
+	      HOST_WIDE_INT one, two;
+	      xr17032_split_sum_of_two_u16 (step1_value, &one, &two);
+	      insn = emit_insn (gen_add3_insn (stack_pointer_rtx,
+						stack_pointer_rtx,
+						GEN_INT (one)));
+	      RTX_FRAME_RELATED_P (insn) = 1;
+	      adjust = GEN_INT (two);
+	    }
+	  else if (!SMALL_OPERAND (step1_value))
+	    {
+	      xr17032_emit_move (XR17032_PROLOGUE_TEMP (Pmode), adjust);
+	      adjust = XR17032_PROLOGUE_TEMP (Pmode);
+	    }
+
+	  insn = emit_insn (gen_add3_insn (stack_pointer_rtx,
+					   stack_pointer_rtx,
+					   adjust));
+	  rtx dwarf = NULL_RTX;
+	  rtx cfa_adjust_rtx
+	    = gen_rtx_PLUS (Pmode, stack_pointer_rtx,
+			    gen_int_mode (step2, Pmode));
+
+	  dwarf = alloc_reg_note (REG_CFA_DEF_CFA, cfa_adjust_rtx, dwarf);
+	  RTX_FRAME_RELATED_P (insn) = 1;
+
+	  REG_NOTES (insn) = dwarf;
+	}
+    }
+  else if (frame_pointer_needed)
+    {
+      /* Tell xr17032_restore_reg to emit dwarf to redefine CFA when restoring
+	 old value of FP.  */
+      epilogue_cfa_sp_offset = step2;
+    }
+
+  /* Restore the registers.  */
+  xr17032_for_each_saved_reg (frame->total_size - step2, xr17032_restore_reg);
+
+  if (need_barrier_p)
+    xr17032_emit_stack_tie (hard_frame_pointer_rtx);
+
+  /* Deallocate the final bit of the frame.  */
+  if (step2.to_constant () > 0)
+    {
+      insn = emit_insn (gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,
+				       GEN_INT (step2.to_constant ())));
+
+      rtx dwarf = NULL_RTX;
+      rtx cfa_adjust_rtx
+	= gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (0));
+      dwarf = alloc_reg_note (REG_CFA_DEF_CFA, cfa_adjust_rtx, dwarf);
+      RTX_FRAME_RELATED_P (insn) = 1;
+
+      REG_NOTES (insn) = dwarf;
+    }
+
+  emit_jump_insn (gen_xr17032_return ());
+}
+
+static void
+xr17032_operand_error (const char *message, rtx x)
+{
+  debug_rtx (x);
+  output_operand_lossage ("xr17032: %s", message);
+}
+
+static void
+xr17032_print_operand (FILE *file, rtx x, int code)
+{
+  switch (code)
+    {
+    case 0:
+    case 'a':
+    case 'z':
+      break;
+    default:
+      xr17032_operand_error ("invalid operand modifier", x);
+      return;
+    }
+
+  switch (GET_CODE (x))
+    {
+    case REG:
+      fprintf (file, "%s", reg_names[REGNO (x)]);
+      return;
+    case MEM:
+      if (code == 'a')
+	{
+	  xr17032_print_operand (file, XEXP (x, 0), 0);
+	  return;
+	}
+      output_address (GET_MODE (x), XEXP (x, 0));
+      return;
+    case PLUS:
+      xr17032_print_operand (file, XEXP (x, 0), code);
+      fputc ('+', file);
+      xr17032_print_operand (file, XEXP (x, 1), code);
+      return;
+    case ASHIFT:
+      xr17032_print_operand (file, XEXP (x, 0), code);
+      fputs (" LSH ", file);
+      xr17032_print_operand (file, XEXP (x, 1), code);
+      return;
+    case LSHIFTRT:
+      xr17032_print_operand (file, XEXP (x, 0), code);
+      fputs (" RSH ", file);
+      xr17032_print_operand (file, XEXP (x, 1), code);
+      return;
+    case ASHIFTRT:
+      xr17032_print_operand (file, XEXP (x, 0), code);
+      fputs (" ASH ", file);
+      xr17032_print_operand (file, XEXP (x, 1), code);
+      return;
+    case ROTATERT:
+      xr17032_print_operand (file, XEXP (x, 0), code);
+      fputs (" ROR ", file);
+      xr17032_print_operand (file, XEXP (x, 1), code);
+      return;
+    default:
+      if (code == 'z' && CONST_INT_P (x) && INTVAL (x) == 0)
+	{
+	  fputs (reg_names[XR17032_ZERO], file);
+	  return;
+	}
+
+      output_addr_const (file, x);
+      return;
+    }
+}
+
+static const char *
+xr17032_mode_id (machine_mode mode)
+{
+  switch (mode)
+    {
+    case QImode:
+      return "byte";
+    case HImode:
+      return "int";
+    case SImode:
+      return "long";
+    default:
+      internal_error ("internal error: bad memory mode: %d", mode);
+      return "(invalid)";
+    }
+}
+
+static void
+xr17032_print_operand_address (FILE *file, machine_mode mode, rtx x)
+{
+  if (mode == VOIDmode)
+    {
+      xr17032_print_operand (file, x, 'a');
+      return;
+    }
+
+  fprintf (file, "%s [", xr17032_mode_id (mode));
+  xr17032_print_operand (file, x, 0);
+  fprintf (file, "]");
+}
+
+static bool
+xr17032_frame_pointer_required (void)
+{
+  return frame_pointer_needed;
+}
+
+rtx
+xr17032_return_addr (int count)
+{
+  return count ? const0_rtx : get_hard_reg_initial_val (Pmode, XR17032_LR);
+}
+
+struct xr17032_arg_info
+{
+  /* True if the argument is at least partially passed on the stack.  */
+  bool stack_p;
+
+  /* The number of integer registers allocated to this argument.  */
+  unsigned int num_gprs;
+
+  /* The offset of the first register used, provided num_gprs is nonzero.
+     If passed entirely on the stack, the value is MAX_ARGS_IN_REGISTERS.  */
+  unsigned int gpr_offset;
+};
+
+/* Implement TARGET_FUNCTION_ARG_BOUNDARY.  Every parameter gets at
+   least PARM_BOUNDARY bits of alignment, but will be given anything up
+   to PREFERRED_STACK_BOUNDARY bits if the type requires it.  */
+
+static unsigned int
+xr17032_function_arg_boundary (machine_mode mode, const_tree type)
+{
+  unsigned int alignment;
+
+  /* Use natural alignment if the type is not aggregate data.  */
+  if (type && !AGGREGATE_TYPE_P (type))
+    alignment = TYPE_ALIGN (TYPE_MAIN_VARIANT (type));
+  else
+    alignment = type ? TYPE_ALIGN (type) : GET_MODE_ALIGNMENT (mode);
+
+  return MIN (STACK_BOUNDARY, MAX (PARM_BOUNDARY, alignment));
+}
+
+typedef struct {
+  const_tree type;
+  HOST_WIDE_INT offset;
+} xr17032_aggregate_field;
+
+/* Fill INFO with information about a single argument, and return an RTL
+   pattern to pass or return the argument. Return NULL_RTX if argument cannot
+   pass or return in registers, then the argument may be passed by reference or
+   through the stack or  .  CUM is the cumulative state for earlier arguments.
+   MODE is the mode of this argument and TYPE is its type (if known). NAMED is
+   true if this is a named (fixed) argument rather than a variable one. RETURN_P
+   is true if returning the argument, or false if passing the argument.  */
+
+static rtx
+xr17032_get_arg_info (struct xr17032_arg_info *info, const CUMULATIVE_ARGS *cum,
+		      machine_mode mode, const_tree type, bool named,
+		      bool return_p)
+{
+  unsigned num_bytes, num_words;
+  unsigned gpr_base = return_p ? XR17032_A3 : XR17032_A0;
+
+  memset (info, 0, sizeof (*info));
+  info->gpr_offset = cum->num_gprs;
+
+  /* Work out the size of the argument.  */
+  num_bytes = type ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);
+  num_words = (num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
+
+  if (!named || (!return_p && num_words > 2))
+    info->stack_p = true;
+  else
+    info->stack_p = num_words > MAX_ARGS_IN_REGISTERS - info->gpr_offset;
+
+  if (info->stack_p)
+    {
+      info->num_gprs = 0;
+      return NULL_RTX;
+    }
+
+  info->num_gprs = num_words;
+
+  if (return_p)
+    {
+      if (num_words <= 1)
+	return gen_rtx_REG (mode, gpr_base - info->gpr_offset);
+
+      rtvec vec = rtvec_alloc (num_words);
+
+      for (unsigned i = 0; i < num_words; i++)
+	{
+	  rtx reg = gen_rtx_REG (SImode, gpr_base - info->gpr_offset - i);
+	  rtx off = gen_rtx_CONST_INT (SImode, i * UNITS_PER_WORD);
+	  RTVEC_ELT (vec, i) = gen_rtx_EXPR_LIST (SImode, reg, off);
+	}
+
+      return gen_rtx_PARALLEL (mode, vec);
+    }
+
+  return gen_rtx_REG (mode, gpr_base + info->gpr_offset);
+}
+
+static rtx
+xr17032_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  struct xr17032_arg_info info;
+
+  if (arg.end_marker_p ())
+    /* Return the calling convention that used by the current function. */
+    return gen_int_mode (cum->variant_cc, SImode);
+
+  return xr17032_get_arg_info (&info, cum, arg.mode, arg.type, arg.named,
+			       false);
+}
+
+static void
+xr17032_function_arg_advance (cumulative_args_t cum_v,
+			      const function_arg_info &arg)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  struct xr17032_arg_info info;
+
+  xr17032_get_arg_info (&info, cum, arg.mode, arg.type, arg.named, false);
+
+  cum->num_gprs = info.gpr_offset + info.num_gprs;
+}
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+
+void
+xr17032_init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, rtx, tree, int)
+{
+  memset (cum, 0, sizeof (*cum));
+
+  if (fntype)
+    cum->variant_cc = (xr17032_cc) fntype_abi (fntype).id ();
+  else
+    cum->variant_cc = XR17032_CC_BASE;
+}
+
+static rtx
+xr17032_function_value (const_tree type, const_tree func, bool)
+{
+  CUMULATIVE_ARGS cum;
+  struct xr17032_arg_info info;
+  machine_mode mode = TYPE_MODE (type);
+
+  memset (&cum, 0, sizeof (cum));
+
+  int unsigned_p = TYPE_UNSIGNED (type);
+  mode = promote_function_mode (type, mode, &unsigned_p, func, 1);
+
+  return xr17032_get_arg_info (&info, &cum, mode, type, true, true);
+}
+
+static rtx
+xr17032_libcall_value (machine_mode mode, const_rtx)
+{
+  CUMULATIVE_ARGS cum;
+  struct xr17032_arg_info info;
+
+  memset (&cum, 0, sizeof (cum));
+
+  return xr17032_get_arg_info (&info, &cum, mode, nullptr, true, true);
+}
+
+static bool
+xr17032_function_value_regno_p (const unsigned int regno)
+{
+  return regno >= XR17032_A0 && regno <= XR17032_A3;
+}
+
+static bool
+xr17032_return_in_memory (const_tree type, const_tree func)
+{
+  CUMULATIVE_ARGS cum;
+  struct xr17032_arg_info info;
+  machine_mode mode = TYPE_MODE (type);
+
+  memset (&cum, 0, sizeof (cum));
+
+  int unsigned_p = TYPE_UNSIGNED (type);
+  mode = promote_function_mode (type, mode, &unsigned_p, func, 1);
+
+  xr17032_get_arg_info (&info, &cum, mode, type, true, true);
+
+  return info.stack_p;
+}
+
+/* Return the method that should be used to access SYMBOL_REF or
+   LABEL_REF X.  */
+
+static enum xr17032_symbol_type
+xr17032_classify_symbol (const_rtx x ATTRIBUTE_UNUSED)
+{
+  return flag_pic ? XR17032_SYMBOL_PCREL : XR17032_SYMBOL_ABSOLUTE;
+}
+
+/* Return true if X is a symbolic constant.  If it is, store the type of
+   the symbol in *SYMBOL_TYPE.  */
+
+bool
+xr17032_symbolic_constant_p (rtx x, enum xr17032_symbol_type *symbol_type)
+{
+  rtx offset;
+
+  split_const (x, &x, &offset);
+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)
+    *symbol_type = xr17032_classify_symbol (x);
+  else
+    return false;
+
+  if (offset == const0_rtx)
+    return true;
+
+  /* Nonzero offsets are only valid for references that don't use the GOT.  */
+  switch (*symbol_type)
+    {
+    case XR17032_SYMBOL_ABSOLUTE:
+    case XR17032_SYMBOL_PCREL:
+      /* GAS rejects offsets outside the range [-2^31, 2^31-1].  */
+      return sext_hwi (INTVAL (offset), 32) == INTVAL (offset);
+
+    default:
+      return false;
+    }
+}
+
+static void
+xr17032_expand_builtin_va_start (tree valist, rtx nextarg)
+{
+  nextarg = gen_rtx_MINUS (Pmode, nextarg, GEN_INT (cfun->machine->varargs_size));
+  std_expand_builtin_va_start (valist, nextarg);
+}
+
+enum memmodel
+xr17032_union_memmodel (enum memmodel a, enum memmodel b)
+{
+  enum memmodel weaker = a <= b ? a : b;
+  enum memmodel stronger = a > b ? a : b;
+
+  switch (stronger)
+    {
+      case MEMMODEL_SEQ_CST:
+      case MEMMODEL_ACQ_REL:
+	return stronger;
+      case MEMMODEL_RELEASE:
+	if (weaker == MEMMODEL_ACQUIRE || weaker == MEMMODEL_CONSUME)
+	  return MEMMODEL_ACQ_REL;
+	else
+	  return stronger;
+      case MEMMODEL_ACQUIRE:
+      case MEMMODEL_CONSUME:
+      case MEMMODEL_RELAXED:
+	return stronger;
+      default:
+	gcc_unreachable ();
+    }
+}
+
+#undef TARGET_OPTION_OVERRIDE
+#define TARGET_OPTION_OVERRIDE xr17032_option_override
+
+#undef TARGET_LEGITIMATE_ADDRESS_P
+#define TARGET_LEGITIMATE_ADDRESS_P xr17032_legitimate_address_p
+
+#undef TARGET_PRINT_OPERAND
+#define TARGET_PRINT_OPERAND xr17032_print_operand
+#undef TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS xr17032_print_operand_address
+
+#undef TARGET_FRAME_POINTER_REQUIRED
+#define TARGET_FRAME_POINTER_REQUIRED xr17032_frame_pointer_required
+
+#undef TARGET_EXPAND_BUILTIN_VA_START
+#define TARGET_EXPAND_BUILTIN_VA_START xr17032_expand_builtin_va_start
+#undef TARGET_MUST_PASS_IN_STACK
+#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG xr17032_function_arg
+#undef TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE xr17032_function_arg_advance
+#undef TARGET_FUNCTION_ARG_BOUNDARY
+#define TARGET_FUNCTION_ARG_BOUNDARY xr17032_function_arg_boundary
+
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE xr17032_function_value
+#undef TARGET_LIBCALL_VALUE
+#define TARGET_LIBCALL_VALUE xr17032_libcall_value
+#undef TARGET_FUNCTION_VALUE_REGNO_P
+#define TARGET_FUNCTION_VALUE_REGNO_P xr17032_function_value_regno_p
+#undef TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY xr17032_return_in_memory
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-xr17032.h"
diff -urN --no-dereference gcc-clean/gcc/config/xr17032/xr17032.h gcc-workdir/gcc/config/xr17032/xr17032.h
--- gcc-clean/gcc/config/xr17032/xr17032.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-workdir/gcc/config/xr17032/xr17032.h
@@ -0,0 +1,261 @@
+/* Target Definitions for XR/17032.
+   Copyright (C) 2025-2025 Free Software Foundation, Inc.
+   Contributed by monkuous.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_XR17032_H
+#define GCC_XR17032_H
+
+#define TARGET_CPU_CPP_BUILTINS() 	\
+  { 					\
+    builtin_define_std ("xr17032");	\
+  }
+
+#define REGISTER_NAMES {				\
+  "zero", "t0", "t1", "t2", "t3", "t4", "t5", "a0",	\
+  "a1", "a2", "a3", "s0", "s1", "s2", "s3", "s4",	\
+  "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12",	\
+  "s13", "s14", "s15", "s16", "s17", "tp", "sp", "lr",	\
+  "frame", "arg" }
+
+#define XR17032_ZERO 0
+#define XR17032_T0 1
+#define XR17032_T1 2
+#define XR17032_T2 3
+#define XR17032_T3 4
+#define XR17032_T4 5
+#define XR17032_T5 6
+#define XR17032_A0 7
+#define XR17032_A1 8
+#define XR17032_A2 9
+#define XR17032_A3 10
+#define XR17032_S0 11
+#define XR17032_S1 12
+#define XR17032_S2 13
+#define XR17032_S3 14
+#define XR17032_S4 15
+#define XR17032_S5 16
+#define XR17032_S6 17
+#define XR17032_S7 18
+#define XR17032_S8 19
+#define XR17032_S9 20
+#define XR17032_S10 21
+#define XR17032_S11 22
+#define XR17032_S12 23
+#define XR17032_S13 24
+#define XR17032_S14 25
+#define XR17032_S15 26
+#define XR17032_S16 27
+#define XR17032_S17 28
+#define XR17032_TP 29
+#define XR17032_SP 30
+#define XR17032_LR 31
+#define XR17032_FRAME 32
+#define XR17032_ARG 33
+
+#define FIRST_PSEUDO_REGISTER 34
+
+#define STACK_POINTER_REGNUM		XR17032_SP
+#define FRAME_POINTER_REGNUM		XR17032_FRAME
+#define ARG_POINTER_REGNUM		XR17032_ARG
+#define HARD_FRAME_POINTER_REGNUM 	XR17032_S0
+
+#define XR17032_PROLOGUE_TEMP_REGNUM (XR17032_T0)
+#define XR17032_PROLOGUE_TEMP(MODE) gen_rtx_REG (MODE, XR17032_PROLOGUE_TEMP_REGNUM)
+
+#define FUNCTION_ARG_REGNO_P(r) ((r) >= XR17032_A0 && (r) <= XR17032_A3)
+
+#define ELIMINABLE_REGS	{				\
+  { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },		\
+  { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },	\
+  { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },	\
+  { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM } }
+
+enum reg_class
+{
+  NO_REGS,
+  GENERAL_REGS,
+  ALL_REGS,
+  LIM_REG_CLASSES
+};
+
+#define REGNO_REG_CLASS(R) (((R) < XR17032_FRAME) ? GENERAL_REGS : ALL_REGS)
+
+#define REG_CLASS_CONTENTS {					\
+  { 0x00000000, 0x00000000 },  /* Empty */			\
+  { 0xFFFFFFFF, 0x00000000 },  /* General registers */		\
+  { 0xFFFFFFFF, 0x00000003 } } /* All registers */
+
+#define N_REG_CLASSES LIM_REG_CLASSES
+
+#define REG_CLASS_NAMES {	\
+  "NO_REGS",			\
+  "GENERAL_REGS",		\
+  "ALL_REGS" }
+
+/* unwritable: zero, tp, sp, lr, frame, arg */
+#define FIXED_REGISTERS {	\
+  1, 0, 0, 0, 0, 0, 0, 0,	\
+  0, 0, 0, 0, 0, 0, 0, 0,	\
+  0, 0, 0, 0, 0, 0, 0, 0,	\
+  0, 0, 0, 0, 0, 1, 1, 1,	\
+  1, 1 }
+
+/* call-clobbered: t0-t5, a0-a3, lr */
+#define CALL_REALLY_USED_REGISTERS {	\
+  0, 1, 1, 1, 1, 1, 1, 1,		\
+  1, 1, 1, 0, 0, 0, 0, 0,		\
+  0, 0, 0, 0, 0, 0, 0, 0,		\
+  0, 0, 0, 0, 0, 0, 0, 1,		\
+  0, 0 }
+
+#define BASE_REG_CLASS GENERAL_REGS
+#define INDEX_REG_CLASS GENERAL_REGS
+
+#ifndef REG_OK_STRICT
+#define REGNO_OK_FOR_BASE_P(X) \
+  xr17032_regno_ok_for_base_p ((X), 0)
+#else
+#define REGNO_OK_FOR_BASE_P(X) \
+  xr17032_regno_ok_for_base_p ((X), 1)
+#endif
+
+#define REGNO_OK_FOR_INDEX_P REGNO_OK_FOR_BASE_P
+
+#define UNITS_PER_WORD 4
+
+#define MOVE_MAX 4
+
+#define Pmode SImode
+#define FUNCTION_MODE SImode
+#define CASE_VECTOR_MODE SImode
+
+#define TRAMPOLINE_SIZE 12
+#define TRAMPOLINE_ALIGNMENT 32
+
+#define STRICT_ALIGNMENT 1
+
+#define FUNCTION_BOUNDARY 32
+
+#define BITS_BIG_ENDIAN 0
+#define BYTES_BIG_ENDIAN 0
+#define WORDS_BIG_ENDIAN 0
+
+#define BIGGEST_ALIGNMENT 32
+
+#define MAX_REGS_PER_ADDRESS 1
+
+#define STACK_BOUNDARY 32
+#define PARM_BOUNDARY 32
+
+#define SLOW_BYTE_ACCESS 1
+
+#define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
+
+#define ASM_OUTPUT_ALIGN(STREAM,POWER) \
+  fprintf (STREAM, "\t.p2align\t%d\n", POWER);
+
+#define FIRST_PARM_OFFSET(F) 0
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+  (OFFSET) = xr17032_initial_elimination_offset (FROM, TO)
+
+#define STACK_DYNAMIC_OFFSET(FUNDECL) \
+  (crtl->outgoing_args_size + STACK_POINTER_OFFSET)
+
+/* Define the standard XR/17032 calling convention and variants.  */
+
+enum xr17032_cc
+{
+  XR17032_CC_BASE = 0, /* Base standard XR/17032 ABI.  */
+  XR17032_CC_UNKNOWN
+};
+
+typedef struct {
+  /* The calling convention that current function used.  */
+  enum xr17032_cc variant_cc;
+
+  /* Number of integer registers used so far, up to MAX_ARGS_IN_REGISTERS. */
+  unsigned int num_gprs;
+} CUMULATIVE_ARGS;
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \
+  xr17032_init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME), (INDIRECT),   \
+			(N_NAMED_ARGS) != -1)
+
+#define ACCUMULATE_OUTGOING_ARGS 1
+#define RETURN_ADDR_RTX(COUNT, FRAMEADDR) xr17032_return_addr (COUNT)
+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (VOIDmode, XR17032_LR)
+#define MAX_ARGS_IN_REGISTERS 4
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+#define DEFAULT_SIGNED_CHAR 0
+
+#define GLOBAL_ASM_OP 			"\t.globl\t"
+#define TEXT_SECTION_ASM_OP		"\t.text"
+#define DATA_SECTION_ASM_OP		"\t.data"
+#define READONLY_DATA_SECTION_ASM_OP	"\t.section\t.rodata"
+#define BSS_SECTION_ASM_OP		"\t.bss"
+
+#ifndef ASM_APP_ON
+#define ASM_APP_ON " #APP\n"
+#endif
+
+#ifndef ASM_APP_OFF
+#define ASM_APP_OFF " #NO_APP\n"
+#endif
+
+#define IMM_BITS 16
+#define IMM_REACH (1LL << IMM_BITS)
+
+#define SMALL_OPERAND(VALUE) \
+  ((unsigned HOST_WIDE_INT) (VALUE) < IMM_REACH)
+
+#define SMALL_OPERAND_SIGNED(VALUE) \
+  ((unsigned HOST_WIDE_INT) (VALUE) + IMM_REACH/2 < IMM_REACH)
+
+/* True if a VALUE (constant) can be expressed as sum of two U16 constants
+   (in range 0 to 65535).
+   Range check logic:
+     from: min U16 + 1
+       to: two times the min U16 value (to max out U16 bits).  */
+
+#define SUM_OF_TWO_U16(VALUE) \
+  (((VALUE) >= (IMM_REACH + 1)) && ((VALUE) <= (IMM_REACH * 2)))
+
+/* Variant with first value 4 byte aligned if involving stack regs.  */
+#define SUM_OF_TWO_U16_ALGN(VALUE) \
+  (((VALUE) >= ((IMM_REACH & ~3) + 1)) && ((VALUE) <= ((IMM_REACH & ~3) * 2)))
+
+#define SHIFT_COUNT_TRUNCATED 1
+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)     \
+  if (GET_MODE_CLASS (MODE) == MODE_INT         \
+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \
+    {                                           \
+      if ((MODE) == SImode)                     \
+        (UNSIGNEDP) = 1;                        \
+      (MODE) = word_mode;                       \
+    }
+
+#endif /* GCC_XR17032_H */
diff -urN --no-dereference gcc-clean/gcc/config/xr17032/xr17032.md gcc-workdir/gcc/config/xr17032/xr17032.md
--- gcc-clean/gcc/config/xr17032/xr17032.md	1970-01-01 01:00:00.000000000 +0100
+++ gcc-workdir/gcc/config/xr17032/xr17032.md
@@ -0,0 +1,744 @@
+;; Machine description for XR/17032
+;; Copyright (C) 2025-2025 Free Software Foundation, Inc.
+;; Contributed by monkuous
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(include "predicates.md")
+(include "constraints.md")
+
+; Instructions are four bytes long.
+(define_attr "length" "" (const_int 4))
+
+(define_mode_iterator MEMORY [QI HI SI])
+
+(define_c_enum "unspec" [
+  UNSPEC_TIE
+  UNSPEC_COMPARE_AND_SWAP
+  UNSPEC_COMPARE_AND_SWAP_SHORT
+])
+
+;; -------------------------------------------------------------------------
+;; Prologue & Epilogue
+;; -------------------------------------------------------------------------
+
+(define_expand "prologue"
+  [(const_int 1)]
+  ""
+{
+  xr17032_expand_prologue ();
+  DONE;
+})
+
+(define_expand "epilogue"
+  [(const_int 2)]
+  ""
+{
+  xr17032_expand_epilogue ();
+  DONE;
+})
+
+(define_insn "xr17032_return"
+  [(return)
+   (use (reg:SI 31))]
+  "reload_completed"
+  "jalr\tzero,lr,0")
+
+(define_insn "xr17032_stack_tiesi"
+  [(set (mem:BLK (scratch))
+	(unspec:BLK [(match_operand:SI 0 "register_operand" "r")
+		     (match_operand:SI 1 "register_operand" "r")]
+		    UNSPEC_TIE))]
+  "!rtx_equal_p (operands[0], operands[1])"
+  ""
+  [(set_attr "length" "0")]
+)
+
+;; -------------------------------------------------------------------------
+;; nop instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "addi\tzero,zero,0")
+
+;; -------------------------------------------------------------------------
+;; mov instruction
+;; -------------------------------------------------------------------------
+
+(define_expand "mov<mode>"
+  [(set (match_operand:MEMORY 0 "nonimmediate_operand")
+	(match_operand:MEMORY 1 ""))]
+  ""
+{
+  if (GET_MODE_CLASS (<MODE>mode) == MODE_INT
+      && GET_MODE_SIZE (<MODE>mode) < UNITS_PER_WORD
+      && !(reload_in_progress || reload_completed)
+      && MEM_P (operands[1]))
+    {
+      rtx temp_reg = gen_reg_rtx (SImode);
+      emit_insn (gen_extend_insn (temp_reg, operands[1], SImode, <MODE>mode,
+				  1));
+      operands[1] = gen_lowpart (<MODE>mode, temp_reg);
+    }
+
+  if (!xr17032_move_operand (operands[1], <MODE>mode))
+    {
+      rtx reg;
+      if (register_operand (operands[0], <MODE>mode))
+	reg = operands[0];
+      else
+	{
+	  gcc_assert (!(reload_in_progress || reload_completed));
+	  reg = gen_reg_rtx (<MODE>mode);
+	}
+      emit_insn (gen_xr17032_const32 (reg, operands[1]));
+      if (register_operand (operands[0], <MODE>mode))
+	DONE;
+      else
+	operands[1] = reg;
+    }
+  else if (MEM_P (operands[0])
+      && !register_operand (operands[1], <MODE>mode))
+    {
+      gcc_assert (!(reload_in_progress || reload_completed));
+      rtx reg = gen_reg_rtx (<MODE>mode);
+      emit_move_insn (reg, operands[1]);
+      operands[1] = reg;
+    }
+})
+
+(define_insn "*mov<mode>"
+  [(set (match_operand:MEMORY 0 "nonimmediate_operand" "=r,r,r,r,m")
+        (match_operand:MEMORY 1 "xr17032_move_operand" " r,I,P,m,r"))]
+  "register_operand (operands[0], <MODE>mode)
+    || register_operand (operands[1], <MODE>mode)"
+  "@
+   add\t%0,%1,zero
+   addi\t%0,zero,%1
+   subi\t%0,zero,-(%1)
+   mov\t%0,%1
+   mov\t%0,%1")
+
+(define_insn "xr17032_const32"
+  [(set (match_operand:SI 0 "register_operand"  "=r,r")
+	(match_operand:SI 1 "immediate_operand" "nS,R"))]
+  ""
+  "@
+   lui\t%0,zero,%%hi(%1)\;ori\t%0,%0,%%lo(%1)
+   1:\;adr\t%0,%%pcrel_hi(%1)\;addi\t%0,%0,%%pcrel_lo(1b)"
+  [(set (attr "length")
+	(const_int 8))])
+
+;; -------------------------------------------------------------------------
+;; add instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "addsi3"
+  [(set (match_operand:SI          0 "register_operand"         "=r,r,r,r")
+	(plus:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O,O")
+		 (match_operand:SI 2 "xr17032_arith_operand"    " r,I,r,I")))]
+  ""
+  "@
+   add\t%0,%1,%2
+   addi\t%0,%1,%2
+   add\t%0,zero,%2
+   addi\t%0,zero,%2")
+
+;; -------------------------------------------------------------------------
+;; sub instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "subsi3"
+  [(set (match_operand:SI           0 "register_operand"         "=r,r,r,r")
+	(minus:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O,O")
+		  (match_operand:SI 2 "xr17032_arith_operand"    " r,I,r,I")))]
+  ""
+  "@
+   sub\t%0,%1,%2
+   subi\t%0,%1,%2
+   sub\t%0,zero,%2
+   subi\t%0,zero,%2")
+
+;; -------------------------------------------------------------------------
+;; and instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "andsi3"
+  [(set (match_operand:SI         0 "register_operand"         "=r,r,r,r")
+	(and:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O,O")
+		(match_operand:SI 2 "xr17032_arith_operand"    " r,I,r,I")))]
+  ""
+  "@
+   and\t%0,%1,%2
+   andi\t%0,%1,%2
+   and\t%0,zero,%2
+   andi\t%0,zero,%2")
+
+;; -------------------------------------------------------------------------
+;; xor instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "xorsi3"
+  [(set (match_operand:SI         0 "register_operand"          "=r,r,r,r,r,r")
+	(xor:SI (match_operand:SI 1 "xr17032_reg_or_0_operand"  " r,r,O,O,r,O")
+		(match_operand:SI 2 "xr17032_xor_arith_operand" " r,I,r,I,P,P")))]
+  ""
+  "@
+   xor\t%0,%1,%2
+   xori\t%0,%1,%2
+   xor\t%0,zero,%2
+   xori\t%0,zero,%2
+   nor\t%0,%1,zero
+   nor\t%0,zero,zero")
+
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI         0 "register_operand"         "=r")
+	(not:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" "rO")))]
+  ""
+  "@
+   nor\t%0,%z1,zero")
+
+;; -------------------------------------------------------------------------
+;; or instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "iorsi3"
+  [(set (match_operand:SI         0 "register_operand"         "=r,r,r,r")
+	(ior:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O,O")
+		(match_operand:SI 2 "xr17032_arith_operand"    " r,I,r,I")))]
+  ""
+  "@
+   or\t%0,%1,%2
+   ori\t%0,%1,%2
+   or\t%0,zero,%2
+   ori\t%0,zero,%2")
+
+;; -------------------------------------------------------------------------
+;; lsh instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "ashlsi3"
+  [(set (match_operand:SI            0 "register_operand"         "=r,r,r")
+	(ashift:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O")
+		   (match_operand:SI 2 "xr17032_shift_operand"    " r,L,rL")))]
+  ""
+  "@
+   lsh\t%0,%1,%2
+   add\t%0,zero,%1 LSH %2
+   add\t%0,zero,zero")
+
+;; -------------------------------------------------------------------------
+;; rsh instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "lshrsi3"
+  [(set (match_operand:SI              0 "register_operand"         "=r,r,r")
+	(lshiftrt:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O")
+		     (match_operand:SI 2 "xr17032_shift_operand"    " r,L,rL")))]
+  ""
+  "@
+   rsh\t%0,%1,%2
+   add\t%0,zero,%1 RSH %2
+   add\t%0,zero,zero")
+
+;; -------------------------------------------------------------------------
+;; ash instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "ashrsi3"
+  [(set (match_operand:SI              0 "register_operand"         "=r,r,r")
+	(ashiftrt:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O")
+		     (match_operand:SI 2 "xr17032_shift_operand"    " r,L,rL")))]
+  ""
+  "@
+   ash\t%0,%1,%2
+   add\t%0,zero,%1 ASH %2
+   add\t%0,zero,zero")
+
+;; -------------------------------------------------------------------------
+;; ror instruction
+;; -------------------------------------------------------------------------
+
+(define_expand "rotlsi3"
+  [(set (match_operand:SI              0 "register_operand"         "=r,r,r")
+	(rotatert:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O")
+		     (match_operand:SI 2 "xr17032_shift_operand"    " r,L,rL")))]
+  ""
+{
+  if (CONST_INT_P (operands[2]))
+    operands[2] = GEN_INT (32 - (INTVAL (operands[2]) % 32));
+  else
+    {
+      rtx reg = gen_reg_rtx (SImode);
+      emit_move_insn (reg, GEN_INT (32));
+      emit_insn (gen_subsi3 (reg, reg, operands[2]));
+      operands[2] = reg;
+    }
+})
+
+(define_insn "rotrsi3"
+  [(set (match_operand:SI              0 "register_operand"         "=r,r,r")
+	(rotatert:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O")
+		     (match_operand:SI 2 "xr17032_shift_operand"    " r,L,rL")))]
+  ""
+  "@
+   ror\t%0,%1,%2
+   add\t%0,zero,%1 ROR %2
+   add\t%0,zero,zero")
+
+;; -------------------------------------------------------------------------
+;; mul instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "mulsi3"
+  [(set (match_operand:SI       0 "register_operand"         "=r,r,r,r")
+        (mult:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O,O")
+	         (match_operand:SI 2 "xr17032_reg_or_0_operand" " r,O,r,O")))]
+  ""
+  "@
+   mul\t%0,%1,%2
+   mul\t%0,%1,zero
+   mul\t%0,zero,%2
+   mul\t%0,zero,zero")
+
+;; -------------------------------------------------------------------------
+;; div instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "udivsi3"
+  [(set (match_operand:SI       0 "register_operand"         "=r,r,r,r")
+        (udiv:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O,O")
+	         (match_operand:SI 2 "xr17032_reg_or_0_operand" " r,O,r,O")))]
+  ""
+  "@
+   div\t%0,%1,%2
+   div\t%0,%1,zero
+   div\t%0,zero,%2
+   div\t%0,zero,zero")
+
+(define_insn "divsi3"
+  [(set (match_operand:SI      0 "register_operand"         "=r,r,r,r")
+        (div:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O,O")
+	        (match_operand:SI 2 "xr17032_reg_or_0_operand" " r,O,r,O")))]
+  ""
+  "@
+   div signed\t%0,%1,%2
+   div signed\t%0,%1,zero
+   div signed\t%0,zero,%2
+   div signed\t%0,zero,zero")
+
+;; -------------------------------------------------------------------------
+;; mod instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "umodsi3"
+  [(set (match_operand:SI       0 "register_operand"         "=r,r,r,r")
+        (umod:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O,O")
+	         (match_operand:SI 2 "xr17032_reg_or_0_operand" " r,O,r,O")))]
+  ""
+  "@
+   mod\t%0,%1,%2
+   mod\t%0,%1,zero
+   mod\t%0,zero,%2
+   mod\t%0,zero,zero")
+
+;; -------------------------------------------------------------------------
+;; jumps
+;; -------------------------------------------------------------------------
+
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "beq zero,%0")
+
+(define_insn "indirect_jump"
+  [(set (pc)
+	(match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "jalr\tzero,%0,0")
+
+;; -------------------------------------------------------------------------
+;; jal instruction
+;; -------------------------------------------------------------------------
+
+(define_expand "call"
+  [(call (match_operand 0 "")
+	 (match_operand 1 ""))]
+  ""
+{
+  rtx target = XEXP (operands[0], 0);
+  if (!xr17032_call_operand (target, VOIDmode))
+    target = force_reg (SImode, target);
+  emit_call_insn (gen_xr17032_call (target, operands[1]));
+  DONE;
+})
+
+(define_insn "xr17032_call"
+  [(call (mem:SI (match_operand 0 "xr17032_call_operand" "r,S,R"))
+	 (match_operand 1 "" ""))
+   (clobber (reg:SI 31))]
+  ""
+  "@
+   jalr\tlr,%0,0
+   jal\t%0
+   adr\tlr,%0\;jalr\tlr,lr,%%pcrel(%0+4)"
+  [(set (attr "length")
+	(symbol_ref "xr17032_pcrel_symbolic_operand (operands[1], VOIDmode) ? 8
+		     : 4"))])
+
+(define_expand "call_value"
+  [(set (match_operand 0 "")
+        (call (match_operand 1 "")
+	      (match_operand 2 "")))]
+  ""
+{
+  rtx target = XEXP (operands[1], 0);
+  if (!xr17032_call_operand (target, VOIDmode))
+    target = force_reg (SImode, target);
+  emit_call_insn (gen_xr17032_call_value (operands[0], target, operands[2]));
+  DONE;
+})
+
+(define_insn "xr17032_call_value"
+  [(set (match_operand 0 "" "")
+        (call (mem:SI (match_operand 1 "xr17032_call_operand" "r,S,R"))
+	      (match_operand 2 "" "")))
+   (clobber (reg:SI 31))]
+  ""
+  "@
+   jalr\tlr,%1,0
+   jal\t%1
+   adr\tlr,%1\;jalr\tlr,lr,%%pcrel(%1+4)"
+  [(set (attr "length")
+	(symbol_ref "xr17032_pcrel_symbolic_operand (operands[1], VOIDmode) ? 8
+		     : 4"))])
+
+;; -------------------------------------------------------------------------
+;; conditionals
+;; -------------------------------------------------------------------------
+
+(define_code_iterator cond [eq ne lt gt ge le])
+
+(define_expand "cstoresi4"
+  [(set (match_operand:SI    0 "register_operand")
+	(match_operator:SI   1 "xr17032_slt_operator"
+			[(match_operand:SI 2 "xr17032_reg_or_0_operand")
+			 (match_operand:SI 3 "")]))]
+  ""
+{
+  if (GET_CODE (operands[1]) == LTU
+      && !xr17032_arith_operand (operands[3], SImode))
+    FAIL;
+  else if (GET_CODE (operands[1]) == LT
+	   && !xr17032_arith_operand_signed (operands[3], SImode))
+    FAIL;
+})
+
+(define_insn "xr17032_sltu"
+  [(set (match_operand:SI         0 "register_operand"         "=r,r,r,r")
+        (ltu:SI (match_operand:SI 1 "xr17032_reg_or_0_operand" " r,r,O,O")
+		(match_operand:SI 2 "xr17032_arith_operand"    " r,I,r,I")))]
+  ""
+  "@
+   slt\t%0,%1,%2
+   slti\t%0,%1,%2
+   slt\t%0,zero,%2
+   slti\t%0,zero,%2")
+
+(define_insn "xr17032_slt"
+  [(set (match_operand:SI        0 "register_operand"             "=r,r,r,r")
+	(lt:SI (match_operand:SI 1 "xr17032_reg_or_0_operand"     " r,r,O,O")
+	       (match_operand:SI 2 "xr17032_arith_operand_signed" " r,J,r,J")))]
+  ""
+  "@
+   slt signed\t%0,%1,%2
+   slti signed\t%0,%1,%2
+   slt signed\t%0,zero,%2
+   slti signed\t%0,zero,%2")
+
+(define_expand "cbranchsi4"
+  [(set (pc)
+	(if_then_else (match_operator      0 "ordered_comparison_operator"
+			[(match_operand:SI 1 "xr17032_reg_or_0_operand")
+			 (match_operand:SI 2 "xr17032_arith_operand")])
+		      (label_ref (match_operand 3 ""))
+		      (pc)))]
+  ""
+{
+  int code = GET_CODE (operands[0]);
+
+  if (code == LTU || code == GTU || code == LEU || code == GEU)
+    {
+      rtx reg = gen_reg_rtx (SImode);
+      if (code == LTU || code == GEU)
+	emit_insn (gen_xr17032_sltu (reg, operands[1], operands[2]));
+      else
+	{
+	  if (!xr17032_reg_shift_operand (operands[2], SImode))
+	    operands[2] = force_reg (SImode, operands[2]);
+	  emit_insn (gen_xr17032_sltu (reg, operands[2], operands[1]));
+	}
+      PUT_CODE (operands[0], code == LTU || code == GTU ? NE : EQ);
+      operands[1] = reg;
+      operands[2] = CONST0_RTX (SImode);
+    }
+  else if (!CONST_INT_P (operands[2]) || INTVAL (operands[2]) != 0)
+    {
+      rtx reg = gen_reg_rtx (SImode);
+      emit_insn (gen_subsi3 (reg, operands[1], operands[2]));
+      operands[1] = reg;
+      operands[2] = CONST0_RTX (SImode);
+    }
+})
+
+(define_insn "*b<code>"
+  [(set (pc)
+        (if_then_else (cond (match_operand:SI 0 "xr17032_reg_or_0_operand" "O,r")
+			    (const_int 0))
+		      (label_ref (match_operand 1 ""))
+		      (pc)))]
+  ""
+  "@
+   b<code>\tzero,%1
+   b<code>\t%0,%1")
+
+;; -------------------------------------------------------------------------
+;; trap
+;; -------------------------------------------------------------------------
+
+(define_insn "trap"
+  [(trap_if (const_int 1) (const_int 0))]
+  ""
+  "brk")
+
+;; -------------------------------------------------------------------------
+;; extension
+;; -------------------------------------------------------------------------
+
+(define_mode_iterator HISI [HI SI])
+
+(define_insn "extendqi<mode>2"
+  [(set (match_operand:HISI                 0 "register_operand" "=r")
+	(sign_extend:HISI (match_operand:QI 1 "register_operand" " r")))]
+  ""
+  "add\t%0,zero,%1 LSH 24\;add\t%0,zero,%0 ASH 24"
+  [(set (attr "length") (const_int 8))])
+
+(define_insn "extendhisi2"
+  [(set (match_operand:SI                 0 "register_operand" "=r")
+	(sign_extend:SI (match_operand:HI 1 "register_operand" " r")))]
+  ""
+  "add\t%0,zero,%1 LSH 16\;add\t%0,zero,%0 ASH 16"
+  [(set (attr "length") (const_int 8))])
+
+(define_expand "zero_extendqi<mode>2"
+  [(set (match_operand:HISI                 0 "register_operand"     "=r")
+	(zero_extend:HISI (match_operand:QI 1 "nonimmediate_operand" " rm")))]
+  ""
+  "")
+
+(define_insn "*reg_zero_extendqi<mode>2"
+  [(set (match_operand:HISI                 0 "register_operand" "=r")
+	(zero_extend:HISI (match_operand:QI 1 "register_operand" " r")))]
+  ""
+  "add\t%0,zero,%1 LSH 24\;add\t%0,zero,%0 RSH 24"
+  [(set (attr "length") (const_int 8))])
+
+(define_insn "*mem_zero_extendqi<mode>2"
+  [(set (match_operand:HISI                 0 "register_operand" "=r")
+	(zero_extend:HISI (match_operand:QI 1 "memory_operand"   " m")))]
+  ""
+  "mov\t%0,%1")
+
+(define_expand "zero_extendhisi2"
+  [(set (match_operand:SI                 0 "register_operand"     "=r")
+	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" " rm")))]
+  ""
+  "")
+
+(define_insn "*reg_zero_extendhisi2"
+  [(set (match_operand:SI                 0 "register_operand" "=r")
+	(zero_extend:SI (match_operand:HI 1 "register_operand" " r")))]
+  ""
+  "add\t%0,zero,%1 LSH 16\;add\t%0,zero,%0 RSH 16"
+  [(set (attr "length") (const_int 8))])
+
+(define_insn "*mem_zero_extendhisi2"
+  [(set (match_operand:SI                 0 "register_operand" "=r")
+	(zero_extend:SI (match_operand:HI 1 "memory_operand"   " m")))]
+  ""
+  "mov\t%0,%1")
+
+;; -------------------------------------------------------------------------
+;; atomics
+;; -------------------------------------------------------------------------
+
+(define_expand "mem_thread_fence"
+  [(match_operand:SI 0 "const_int_operand" "")] ;; model
+  ""
+{
+  enum memmodel model = memmodel_base (INTVAL (operands[0]));
+  if (model != MEMMODEL_RELAXED)
+    {
+      rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+      MEM_VOLATILE_P (mem) = 1;
+      emit_insn (gen_xr17032_mem_thread_fence (mem, operands[0]));
+    }
+  DONE;
+})
+
+(define_insn "xr17032_mem_thread_fence"
+  [(set (match_operand:BLK 0 "")
+        (match_dup 0))
+   (match_operand:SI 1 "const_int_operand" "")] ;; model
+  ""
+{
+  enum memmodel model = (enum memmodel) INTVAL (operands[1]);
+  model = memmodel_base (model);
+  if (model == MEMMODEL_SEQ_CST)
+    return "mb";
+  else if (model == MEMMODEL_ACQ_REL)
+    return "mb";
+  else if (model == MEMMODEL_ACQUIRE)
+    return "mb";
+  else if (model == MEMMODEL_RELEASE)
+    return "wmb";
+  else
+    gcc_unreachable ();
+})
+
+(define_mode_iterator MSHORT [QI HI])
+
+(define_expand "atomic_compare_and_swap<mode>"
+  [(match_operand:SI 0 "register_operand"             "")  ;; bool output
+   (match_operand:MEMORY 1 "register_operand"         "")  ;; val output
+   (match_operand:MEMORY 2 "memory_operand"           "")  ;; memory
+   (match_operand:MEMORY 3 "xr17032_reg_or_0_operand" "")  ;; expected value
+   (match_operand:MEMORY 4 "xr17032_reg_or_0_operand" "")  ;; desired value
+   (match_operand:SI 5 "const_int_operand"            "")  ;; is_weak
+   (match_operand:SI 6 "const_int_operand"            "")  ;; mod_s
+   (match_operand:SI 7 "const_int_operand"            "")] ;; mod_f
+  ""
+{
+  enum memmodel smod = memmodel_base (INTVAL (operands[6]));
+  enum memmodel fmod = memmodel_base (INTVAL (operands[7]));
+  enum memmodel model = xr17032_union_memmodel (smod, fmod);
+
+  enum memmodel m1 = model == MEMMODEL_ACQ_REL ? MEMMODEL_RELEASE : model;
+  enum memmodel m2 = model == MEMMODEL_ACQ_REL ? MEMMODEL_ACQUIRE : model;
+
+  if (m1 == MEMMODEL_SEQ_CST || m1 == MEMMODEL_RELEASE)
+      emit_insn (gen_mem_thread_fence (GEN_INT (m1)));
+
+  emit_insn (gen_xr17032_cas<mode> (operands[1], operands[2], operands[3],
+				    operands[4]));
+
+  if (m2 == MEMMODEL_SEQ_CST || m2 == MEMMODEL_ACQUIRE)
+      emit_insn (gen_mem_thread_fence (GEN_INT (m2)));
+
+  rtx val = operands[1];
+  rtx exp = operands[3];
+
+  if (<MODE>mode != SImode)
+    {
+      val = gen_reg_rtx (SImode);
+      exp = gen_reg_rtx (SImode);
+      emit_move_insn (val, gen_rtx_ZERO_EXTEND (SImode, operands[1]));
+      emit_move_insn (exp, gen_rtx_ZERO_EXTEND (SImode, operands[3]));
+    }
+
+  rtx compare = val;
+  if (exp != const0_rtx)
+    {
+      rtx difference = gen_rtx_MINUS(SImode, val, exp);
+      compare = gen_reg_rtx (SImode);
+      emit_insn (gen_rtx_SET (compare, difference));
+    }
+
+  emit_insn (gen_rtx_SET (operands[0],
+			  gen_rtx_IF_THEN_ELSE (SImode,
+						gen_rtx_LTU (SImode, compare,
+							     const1_rtx),
+						const1_rtx, const0_rtx)));
+  DONE;
+})
+
+(define_insn "xr17032_cassi"
+  [(set (match_operand:SI 0 "register_operand" "=&r,&r")
+        (match_operand:SI 1 "memory_operand"   "+ A, A"))
+   (set (match_dup 1)
+        (unspec_volatile:SI [(match_operand:SI 2 "xr17032_reg_or_0_operand" " r, O")
+			     (match_operand:SI 3 "xr17032_reg_or_0_operand" "rO,rO")]
+			    UNSPEC_COMPARE_AND_SWAP))
+   (clobber (match_scratch:SI 4 "=&r,&r"))]
+  ""
+  "@
+   1:\;ll\t%0,%a1\;sub\t%4,%0,%z2\;bne\t%4,1f\;sc\t%4,%a1,%z3\;beq\t%4,1b\;1:
+   1:\;ll\t%0,%a1\;bne\t%0,1f\;sc\t%4,%a1,%z3\;beq\t%4,1b\;1:"
+  [(set_attr_alternative "length" [(const_int 20) (const_int 16)])])
+
+(define_expand "xr17032_cas<mode>"
+  [(match_operand:MSHORT 0 "register_operand")
+   (match_operand:MSHORT 1 "memory_operand")
+   (match_operand:MSHORT 2 "xr17032_reg_or_0_operand")
+   (match_operand:MSHORT 3 "xr17032_reg_or_0_operand")]
+  ""
+{
+  rtx addr = force_reg (Pmode, XEXP (operands[1], 0));
+  rtx offs = gen_reg_rtx (SImode);
+  rtx raddr = gen_reg_rtx (SImode);
+  rtx shift = gen_reg_rtx (SImode);
+  rtx pmask = gen_reg_rtx (SImode);
+  rtx nmask = gen_reg_rtx (SImode);
+  rtx shexp = gen_reg_rtx (SImode);
+  rtx shnew = gen_reg_rtx (SImode);
+  rtx value = gen_reg_rtx (SImode);
+  rtx shval = gen_reg_rtx (SImode);
+  emit_move_insn (offs, gen_rtx_AND (SImode, addr, GEN_INT (3)));
+  emit_move_insn (raddr, gen_rtx_MINUS (SImode, addr, offs));
+  emit_move_insn (shift, gen_rtx_ASHIFT (SImode, offs, GEN_INT (3)));
+  emit_move_insn (pmask, GEN_INT (GET_MODE_MASK (<MODE>mode)));
+  emit_move_insn (pmask, gen_rtx_ASHIFT (SImode, pmask, shift));
+  emit_move_insn (nmask, gen_rtx_XOR (SImode, pmask, GEN_INT (-1)));
+  emit_move_insn (shexp, gen_lowpart (SImode, operands[2]));
+  emit_move_insn (shexp, gen_rtx_ASHIFT (SImode, shexp, shift));
+  emit_move_insn (shnew, gen_lowpart (SImode, operands[3]));
+  emit_move_insn (shnew, gen_rtx_ASHIFT (SImode, shnew, shift));
+  emit_insn (gen_xr17032_cas_short (value, gen_rtx_MEM (SImode, addr), shexp,
+				    shnew, pmask, nmask));
+  emit_move_insn (shval, gen_rtx_LSHIFTRT (SImode, value, shift));
+  emit_move_insn (operands[0], gen_lowpart (<MODE>mode, shval));
+  DONE;
+})
+
+(define_insn "xr17032_cas_short"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+        (match_operand:SI 1 "memory_operand"   "+ A"))
+   (set (match_dup 1)
+        (unspec_volatile:SI [(match_operand:SI 2 "register_operand" "r")
+			     (match_operand:SI 3 "register_operand" "r")
+			     (match_operand:SI 4 "register_operand" "r")
+			     (match_operand:SI 5 "register_operand" "r")]
+			    UNSPEC_COMPARE_AND_SWAP_SHORT))
+   (clobber (match_scratch:SI 6 "=&r"))
+   (clobber (match_scratch:SI 7 "=&r"))]
+  ""
+  "1:\;ll\t%6,%a1\;and\t%0,%6,%4\;sub\t%7,%0,%2\;bne\t%7,1f\;and\t%6,%6,%5\;or\t%6,%6,%3\;sc\t%6,%a1,%6\;beq\t%6,1b\;1:"
+  [(set_attr_alternative "length" [(const_int 32)])])
diff -urN --no-dereference gcc-clean/gcc/config.gcc gcc-workdir/gcc/config.gcc
--- gcc-clean/gcc/config.gcc
+++ gcc-workdir/gcc/config.gcc
@@ -593,6 +593,10 @@
 	extra_headers="c6x_intrinsics.h"
 	extra_options="${extra_options} c6x/c6x-tables.opt"
 	;;
+xr17032-*-*)
+	cpu_type=xr17032
+	target_has_targetm_common=no
+	;;
 xtensa*-*-*)
 	extra_options="${extra_options} fused-madd.opt"
 	extra_objs="xtensa-dynconfig.o"
@@ -3606,6 +3610,12 @@
 	tm_file="elfos.h ${tm_file} visium/elf.h newlib-stdint.h"
 	tmake_file="visium/t-visium visium/t-crtstuff"
 	;;
+xr17032-*-elf*)
+	tm_file="${tm_file} elfos.h newlib-stdint.h"
+	;;
+xr17032-*-linux*)
+	tm_file="${tm_file} elfos.h gnu-user.h linux.h glibc-stdint.h"
+	;;
 xstormy16-*-elf)
 	# For historical reasons, the target files omit the 'x'.
 	tm_file="elfos.h newlib-stdint.h stormy16/stormy16.h"
diff -urN --no-dereference gcc-clean/libgcc/config/xr17032/crti.S gcc-workdir/libgcc/config/xr17032/crti.S
--- gcc-clean/libgcc/config/xr17032/crti.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-workdir/libgcc/config/xr17032/crti.S
@@ -0,0 +1,51 @@
+# Start .init and .fini sections.
+# Copyright (C) 2025-2025 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the GCC Runtime Library Exception, version
+# 3.1, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License and
+# a copy of the GCC Runtime Library Exception along with this program;
+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+# This file just makes a stack frame for the contents of the .fini and
+# .init sections.  Users may put any desired instructions in those
+# sections.
+
+/* An executable stack is *not* required for these functions.  */
+#if defined(__ELF__) && defined(__linux__)
+.section .note.GNU-stack,"",%progbits
+.previous
+#endif
+
+	.section .init
+	.globl _init
+	.type _init,@function
+	.align	4
+_init:
+	subi	sp,sp,8
+	mov	long [sp],s0
+	mov	long [sp+4],lr
+	addi	s0,sp,0
+
+	.section .fini
+	.globl _fini
+	.type _fini,@function
+	.align	4
+_fini:
+	subi	sp,sp,8
+	mov	long [sp],s0
+	mov	long [sp+4],lr
+	addi	s0,sp,0
diff -urN --no-dereference gcc-clean/libgcc/config/xr17032/crtn.S gcc-workdir/libgcc/config/xr17032/crtn.S
--- gcc-clean/libgcc/config/xr17032/crtn.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-workdir/libgcc/config/xr17032/crtn.S
@@ -0,0 +1,44 @@
+# End of .init and .fini sections.
+# Copyright (C) 2025-2025 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the GCC Runtime Library Exception, version
+# 3.1, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License and
+# a copy of the GCC Runtime Library Exception along with this program;
+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+
+# This file just makes sure that the .fini and .init sections do in
+# fact return.  Users may put any desired instructions in those sections.
+# This file is the last thing linked into any executable.
+
+/* An executable stack is *not* required for these functions.  */
+#if defined(__ELF__) && defined(__linux__)
+.section .note.GNU-stack,"",%progbits
+.previous
+#endif
+
+	.section .init
+	mov	s0,long [sp]
+	mov	lr,long [sp+4]
+	addi	sp,sp,8
+	jalr	zero,lr,0
+
+	.section .fini
+	mov	s0,long [sp]
+	mov	lr,long [sp+4]
+	addi	sp,sp,8
+	jalr	zero,lr,0
diff -urN --no-dereference gcc-clean/libgcc/config.host gcc-workdir/libgcc/config.host
--- gcc-clean/libgcc/config.host
+++ gcc-workdir/libgcc/config.host
@@ -218,6 +218,9 @@
 tic6x-*-*)
 	cpu_type=c6x
 	;;
+xr17032-*-*)
+	cpu_type=xr17032
+	;;
 esac
 
 # Common parts for widely ported systems.
@@ -1543,6 +1546,12 @@
         extra_parts="$extra_parts crtbegin.o crtend.o crti.o crtn.o"
         tmake_file="visium/t-visium t-fdpbit"
         ;;
+xr17032-*-elf)
+	extra_parts="$extra_parts crtbegin.o crti.o crtn.o crtend.o"
+	;;
+xr17032-*-linux*)
+	tmake_file="$tmake_file t-slibgcc-libgcc"
+	;;
 xstormy16-*-elf)
 	tmake_file="stormy16/t-stormy16 t-fdpbit"
 	;;
