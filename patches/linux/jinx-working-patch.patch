diff -urN --no-dereference linux-clean/arch/xr17032/Kbuild linux-workdir/arch/xr17032/Kbuild
--- linux-clean/arch/xr17032/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kbuild
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+obj-y += kernel/ mm/
+
+subdir- += boot/
diff -urN --no-dereference linux-clean/arch/xr17032/Kconfig linux-workdir/arch/xr17032/Kconfig
--- linux-clean/arch/xr17032/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kconfig
@@ -0,0 +1,47 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config XR17032
+	def_bool y
+	select GENERIC_ATOMIC64
+	select THREAD_INFO_IN_TASK
+	select HAVE_PAGE_SIZE_4KB
+	select ARCH_SPARSEMEM_ENABLE
+	select GENERIC_IOREMAP
+	select FUNCTION_ALIGNMENT_4B
+	select GENERIC_IRQ_SHOW
+	select GENERIC_LIB_ASHLDI3
+	select GENERIC_LIB_LSHRDI3
+	select GENERIC_LIB_MULDI3
+	select OF
+	select OF_EARLY_FLATTREE
+	select GENERIC_EARLY_IOREMAP
+	select GENERIC_IRQ_MULTI_HANDLER
+	select XR17032_INTC
+	select XRARCH_LSIC
+	select XRARCH_RTC
+	select GENERIC_ENTRY
+	select HAVE_SYSCALL_TRACEPOINTS
+	select GENERIC_CPU_DEVICES
+	select GENERIC_LIB_ASHRDI3
+	select LOCK_MM_AND_FIND_VMA
+	select ARCH_HAS_SYSCALL_WRAPPER
+	select ARCH_HAS_SETUP_DMA_OPS
+	select ARCH_HAS_SYNC_DMA_FOR_CPU
+
+config MMU
+	def_bool y
+
+config GENERIC_CALIBRATE_DELAY
+	def_bool y
+
+config GENERIC_HWEIGHT
+	def_bool y
+
+config FIX_EARLYCON_MEM
+	def_bool MMU
+
+menu "Kernel features"
+
+source "kernel/Kconfig.hz"
+
+endmenu
diff -urN --no-dereference linux-clean/arch/xr17032/Kconfig.debug linux-workdir/arch/xr17032/Kconfig.debug
--- linux-clean/arch/xr17032/Kconfig.debug	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kconfig.debug
@@ -0,0 +1 @@
+# SPDX-License-Identifier: GPL-2.0-only
diff -urN --no-dereference linux-clean/arch/xr17032/Makefile linux-workdir/arch/xr17032/Makefile
--- linux-clean/arch/xr17032/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Makefile
@@ -0,0 +1,36 @@
+# This file is included by the global makefile so that you can add your own
+# architecture-specific flags and dependencies.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+
+KBUILD_DEFCONFIG	:= xr17032_defconfig
+
+UTS_MACHINE	:= xr17032
+
+KBUILD_CFLAGS	+= -fno-pic
+
+libs-y		+= arch/xr17032/lib/
+
+boot		:= arch/xr17032/boot
+KBUILD_IMAGE	:= $(boot)/Image
+
+BOOT_TARGETS	:= Image
+
+$(BOOT_TARGETS): vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
+	@$(kecho) '  Kernel: $(boot)/$@ is ready'
+
+all: $(notdir $(KBUILD_IMAGE))
+
+install:
+	$(call cmd,install)
+
+define archhelp
+  echo  '  Image	- Uncompressed kernel image (arch/xr17032/boot/Image)'
+  echo  '  install	- Install kernel using (your) ~/bin/$(INSTALLKERNEL) or'
+  echo  '		  (distribution) /sbin/$(INSTALLKERNEL) or install to '
+  echo  '		  $$(INSTALL_PATH)'
+endef
diff -urN --no-dereference linux-clean/arch/xr17032/boot/Makefile linux-workdir/arch/xr17032/boot/Makefile
--- linux-clean/arch/xr17032/boot/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/boot/Makefile
@@ -0,0 +1,24 @@
+#
+# arch/riscv/boot/Makefile
+#
+# This file is included by the global makefile so that you can add your own
+# architecture-specific flags and dependencies.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 2025, monkuous.
+# Author: monkuous
+#
+
+OBJCOPYFLAGS_Image := -O binary -R .note -R .note.gnu.build-id -R .comment -S
+
+targets := Image
+
+ifdef CONFIG_RELOCATABLE
+$(obj)/Image: vmlinux.unstripped FORCE
+else
+$(obj)/Image: vmlinux FORCE
+endif
+	$(call if_changed,objcopy)
diff -urN --no-dereference linux-clean/arch/xr17032/configs/xr17032_defconfig linux-workdir/arch/xr17032/configs/xr17032_defconfig
--- linux-clean/arch/xr17032/configs/xr17032_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/configs/xr17032_defconfig
@@ -0,0 +1,14 @@
+CONFIG_SERIAL_XRARCH_UART=y
+CONFIG_PRINTK_TIME=y
+CONFIG_BLK_DEV_XRARCH=y
+CONFIG_EXT4_FS=y
+CONFIG_FB=y
+CONFIG_FB_KINNOW=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=128
+CONFIG_DUMMY_CONSOLE_ROWS=48
+CONFIG_LOGO=y
+CONFIG_AMTSU=y
+CONFIG_KEYBOARD_AISA=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_INITRD=y
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/Kbuild linux-workdir/arch/xr17032/include/asm/Kbuild
--- linux-clean/arch/xr17032/include/asm/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/Kbuild
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+syscall-y += syscall_table_32.h
+
+generic-y += user.h
+generic-y += kvm_para.h
+generic-y += vmlinux.lds.h
+generic-y += early_ioremap.h
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/asm-extable.h linux-workdir/arch/xr17032/include/asm/asm-extable.h
--- linux-clean/arch/xr17032/include/asm/asm-extable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/asm-extable.h
@@ -0,0 +1,73 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ASM_EXTABLE_H
+#define _ASM_XR17032_ASM_EXTABLE_H
+
+#define EX_TYPE_NONE			0
+#define EX_TYPE_FIXUP			1
+#define EX_TYPE_UACCESS_ERR_ZERO	2
+
+#ifdef __ASSEMBLY__
+
+#define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
+	.pushsection	__ex_table, "a";		\
+	.balign		4;				\
+	.long		(insn);				\
+	.long		(fixup);			\
+	.short		(type);				\
+	.short		(data);				\
+	.popsection;
+
+.macro	_asm_extable, insn, fixup
+	__ASM_EXTABLE_RAW(\insn, \fixup, EX_TYPE_FIXUP, 0)
+.endm
+
+#else /* __ASSEMBLY__ */
+
+#include <linux/bits.h>
+#include <linux/stringify.h>
+#include <asm/gpr-num.h>
+
+#define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
+	".pushsection	__ex_table, \"a\"\n"		\
+	".balign	4\n"				\
+	".long		(" insn ")\n"			\
+	".long		(" fixup ")\n"			\
+	".short		(" type ")\n"			\
+	".short		(" data ")\n"			\
+	".popsection\n"
+
+#define _ASM_EXTABLE(insn, fixup)	\
+	__ASM_EXTABLE_RAW(#insn, #fixup, __stringify(EX_TYPE_FIXUP), "0")
+
+#define EX_DATA_REG_ERR_SHIFT	0
+#define EX_DATA_REG_ERR		GENMASK(4, 0)
+#define EX_DATA_REG_ZERO_SHIFT	5
+#define EX_DATA_REG_ZERO	GENMASK(9, 5)
+
+#define EX_DATA_REG_DATA_SHIFT	0
+#define EX_DATA_REG_DATA	GENMASK(4, 0)
+#define EX_DATA_REG_ADDR_SHIFT	5
+#define EX_DATA_REG_ADDR	GENMASK(9, 5)
+
+#define EX_DATA_REG(reg, gpr)						\
+	"((.L__gpr_num_" #gpr ") << " __stringify(EX_DATA_REG_##reg##_SHIFT) ")"
+
+#define _ASM_EXTABLE_UACCESS_ERR_ZERO(insn, fixup, err, zero)		\
+	__DEFINE_ASM_GPR_NUMS						\
+	__ASM_EXTABLE_RAW(#insn, #fixup, 				\
+			  __stringify(EX_TYPE_UACCESS_ERR_ZERO),	\
+			  "("						\
+			    EX_DATA_REG(ERR, err) " | "			\
+			    EX_DATA_REG(ZERO, zero)			\
+			  ")")
+
+#define _ASM_EXTABLE_UACCESS_ERR(insn, fixup, err)			\
+	_ASM_EXTABLE_UACCESS_ERR_ZERO(insn, fixup, err, zero)
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_XR17032_ASM_EXTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/atomic.h linux-workdir/arch/xr17032/include/asm/atomic.h
--- linux-clean/arch/xr17032/include/asm/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/atomic.h
@@ -0,0 +1,111 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ATOMIC_H
+#define _ASM_XR17032_ATOMIC_H
+
+#ifndef CONFIG_GENERIC_ATOMIC64
+#error "xr17032 does not support 64-bit atomics"
+#endif
+
+#include <asm/cmpxchg.h>
+#include <asm-generic/atomic64.h>
+
+static inline int arch_atomic_read(const atomic_t *v)
+{
+	return READ_ONCE(v->counter);
+}
+
+static inline void arch_atomic_set(atomic_t *v, int i)
+{
+	WRITE_ONCE(v->counter, i);
+}
+
+#define __ATOMIC_OP(op, asm_op)						\
+static inline void arch_atomic_##op(int i, atomic_t *v)			\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %0, %0, %z3\n"			\
+		"	sc  %1, %2, %0\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+}
+
+#define __ATOMIC_OP_RETURN(op, asm_op)					\
+static inline int arch_atomic_##op##_return_relaxed(int i, atomic_t *v)	\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %0, %0, %z3\n"			\
+		"	sc  %1, %2, %0\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+									\
+	return ret;							\
+}
+
+#define __ATOMIC_FETCH_OP(op, asm_op)					\
+static inline int arch_atomic_fetch_##op##_relaxed(int i, atomic_t *v)	\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %1, %0, %z3\n"			\
+		"	sc  %1, %2, %1\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+									\
+	return ret;							\
+}
+
+__ATOMIC_OP_RETURN(add, "add")
+__ATOMIC_OP_RETURN(sub, "sub")
+
+__ATOMIC_FETCH_OP(add, "add")
+__ATOMIC_FETCH_OP(sub, "sub")
+__ATOMIC_FETCH_OP(and, "and")
+__ATOMIC_FETCH_OP(or, "or")
+__ATOMIC_FETCH_OP(xor, "xor")
+
+__ATOMIC_OP(add, "add")
+__ATOMIC_OP(sub, "sub")
+__ATOMIC_OP(and, "and")
+__ATOMIC_OP(or, "or")
+__ATOMIC_OP(xor, "xor")
+
+#define arch_atomic_add_return_relaxed arch_atomic_add_return_relaxed
+#define arch_atomic_sub_return_relaxed arch_atomic_sub_return_relaxed
+
+#define arch_atomic_fetch_add_relaxed arch_atomic_fetch_add_relaxed
+#define arch_atomic_fetch_sub_relaxed arch_atomic_fetch_sub_relaxed
+#define arch_atomic_fetch_and_relaxed arch_atomic_fetch_and_relaxed
+#define arch_atomic_fetch_or_relaxed  arch_atomic_fetch_or_relaxed
+#define arch_atomic_fetch_xor_relaxed arch_atomic_fetch_xor_relaxed
+
+#define arch_atomic_add arch_atomic_add
+#define arch_atomic_sub arch_atomic_sub
+#define arch_atomic_and arch_atomic_and
+#define arch_atomic_or  arch_atomic_or
+#define arch_atomic_xor arch_atomic_xor
+
+#endif /* _ASM_XR17032_ATOMIC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/barrier.h linux-workdir/arch/xr17032/include/asm/barrier.h
--- linux-clean/arch/xr17032/include/asm/barrier.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/barrier.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_BARRIER_H
+#define _ASM_XR17032_BARRIER_H
+
+#define nop()	({asm volatile("addi zero, zero, 0");})
+
+#define __mb()	({asm volatile("mb");})
+#define __wmb()	({asm volatile("wmb");})
+#define __rmb()	({asm volatile("mb");})
+
+#include <asm-generic/barrier.h>
+
+#endif /* _ASM_XR17032_BARRIER_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/bug.h linux-workdir/arch/xr17032/include/asm/bug.h
--- linux-clean/arch/xr17032/include/asm/bug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/bug.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_BUG_H
+#define _ASM_XR17032_BUG_H
+
+#include <asm-generic/bug.h>
+
+void __show_regs(struct pt_regs *regs);
+void die(struct pt_regs *regs, const char *str);
+
+#endif /* _ASM_XR17032_BUG_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cache.h linux-workdir/arch/xr17032/include/asm/cache.h
--- linux-clean/arch/xr17032/include/asm/cache.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cache.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CACHE_H
+#define _ASM_XR17032_CACHE_H
+
+#define L1_CACHE_SHIFT 4
+#define L1_CACHE_BYTES (1 << L1_CACHE_SHIFT)
+
+#endif /* _ASM_XR17032_CACHE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cacheflush.h linux-workdir/arch/xr17032/include/asm/cacheflush.h
--- linux-clean/arch/xr17032/include/asm/cacheflush.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cacheflush.h
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CACHEFLUSH_H
+#define _ASM_XR17032_CACHEFLUSH_H
+
+#include <asm/cr.h>
+#include <linux/mm.h>
+
+static inline void local_flush_icache_all(void)
+{
+	cr_write(icachectrl, 3);
+}
+
+static inline void local_flush_icache_page(unsigned long page)
+{
+	page &= PAGE_MASK;
+	cr_write(icachectrl, page | 2);
+}
+
+void local_flush_icache_range(unsigned long start, unsigned long end);
+
+#define PG_dcache_clean PG_arch_1
+
+static inline void flush_dcache_folio(struct folio *folio)
+{
+	if (test_bit(PG_dcache_clean, &folio->flags))
+		clear_bit(PG_dcache_clean, &folio->flags);
+}
+#define flush_dcache_folio flush_dcache_folio
+#define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 1
+
+static inline void flush_dcache_page(struct page *page)
+{
+	flush_dcache_folio(page_folio(page));
+}
+
+#define flush_icache_user_page(vma, pg, addr, len)	\
+do {							\
+	if (vma->vm_flags & VM_EXEC)			\
+		flush_icache_mm(vma->vm_mm, 0);		\
+} while (0)
+
+#ifndef CONFIG_SMP
+
+#define flush_icache_all		local_flush_icache_all
+#define flush_icache_mm(mm, local)	flush_icache_all()
+#define flush_icache_range		local_flush_icache_range
+
+#else /* CONFIG_SMP */
+
+void flush_icache_all(void);
+void flush_icache_mm(struct mm_struct *mm, bool local);
+void flush_icache_range(unsigned long start, unsigned long end);
+#define flush_icache_range flush_icache_range
+
+#endif /* CONFIG_SMP */
+
+#include <asm-generic/cacheflush.h>
+
+#endif /* _ASM_XR17032_CACHEFLUSH_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cmpxchg.h linux-workdir/arch/xr17032/include/asm/cmpxchg.h
--- linux-clean/arch/xr17032/include/asm/cmpxchg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cmpxchg.h
@@ -0,0 +1,137 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CMPXCHG_H
+#define _ASM_XR17032_CMPXCHG_H
+
+#include <linux/bug.h>
+
+#define __arch_xchg_masked(mask, ret, scratch, ptr, new)		\
+({									\
+	unsigned long __address = (unsigned long)ptr;			\
+	unsigned long __offset = __address & 3;				\
+	unsigned long __shift = __offset * 8;				\
+	unsigned long __mask = mask << __shift;				\
+	unsigned long __new_shift = (unsigned long)new << __shift;	\
+	unsigned long __ret_shift;					\
+	__address -= __offset;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	and %1, %0, %z3\n"				\
+		"	or  %1, %1, %z4\n"				\
+		"	sc  %1, %2, %1\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (__ret_shift), "=&r" (scratch)			\
+		: "r" (__address), "rO" (~__mask), "rO" (__new_shift)	\
+		: "memory"						\
+	);								\
+									\
+	ret = (typeof(ret))((__ret_shift & __mask) >> __shift);		\
+})
+
+#define arch_xchg_relaxed(ptr, new)					\
+({									\
+	typeof(ptr) __ptr = (ptr);					\
+	typeof(*__ptr) __new = (new);					\
+	typeof(*__ptr) __ret;						\
+	unsigned long __scratch;					\
+									\
+	switch (sizeof(*__ptr)) {					\
+	case 1:								\
+		__arch_xchg_masked(0xff, __ret, __scratch, __ptr,	\
+				   __new); 				\
+		break;							\
+	case 2:								\
+		__arch_xchg_masked(0xffff, __ret, __scratch, __ptr,	\
+				   __new); 				\
+		break;							\
+	case 4:								\
+		asm volatile(						\
+			"1:	ll  %0, %2\n"				\
+			"	sc  %1, %2, %z3\n"			\
+			"	beq %1, 1b"				\
+			: "=&r" (__ret), "=&r" (__scratch)		\
+			: "r" (__ptr), "rO" (__new)			\
+			: "memory"					\
+		);							\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+									\
+	__ret;								\
+})
+
+#define __arch_cmpxchg_masked(mask, ret, scratch, ptr, old, new)	\
+({									\
+	unsigned long __address = (unsigned long)ptr;			\
+	unsigned long __offset = __address & 3;				\
+	unsigned long __shift = __offset * 8;				\
+	unsigned long __mask = mask << __shift;				\
+	unsigned long __old_shift = (unsigned long)old << __shift;	\
+	unsigned long __new_shift = (unsigned long)new << __shift;	\
+	unsigned long __ret_shift;					\
+	unsigned long __scratch2;					\
+	__address -= __offset;						\
+									\
+	asm volatile(							\
+		"1:	ll  %1, %3\n"					\
+		"	and %0, %1, %z4\n"				\
+		"	sub %2, %0, %z5\n"				\
+		"	bne %2, 1f\n"					\
+		"	and %1, %1, %z6\n"				\
+		"	or  %1, %1, %z7\n"				\
+		"	sc  %1, %3, %1\n"				\
+		"	beq %1, 1b\n"					\
+		"1:"							\
+		: "=&r" (__ret_shift), "=&r" (scratch),			\
+		  "=&r" (__scratch2)					\
+		: "r" (__address), "rO" (__mask), "rO" (__old_shift),	\
+		  "rO" (~__mask), "rO" (__new_shift)			\
+		: "memory"						\
+	);								\
+									\
+	ret = (typeof(ret))(__ret_shift >> __shift);			\
+})
+
+#define arch_cmpxchg_relaxed(ptr, old, new)				\
+({									\
+	typeof(ptr) __ptr = (ptr);					\
+	typeof(*__ptr) __old = (old);					\
+	typeof(*__ptr) __new = (new);					\
+	typeof(*__ptr) __ret;						\
+	unsigned long __scratch;					\
+									\
+	switch (sizeof(*__ptr)) {					\
+	case 1:								\
+		__arch_cmpxchg_masked(0xff, __ret, __scratch, __ptr,	\
+				      __old, __new);			\
+		break;							\
+	case 2:								\
+		__arch_cmpxchg_masked(0xffff, __ret, __scratch, __ptr,	\
+				      __old, __new);			\
+		break;							\
+	case 4:								\
+		asm volatile(						\
+			"1:	ll  %0, %2\n"				\
+			"	sub %1, %0, %z3\n"			\
+			"	bne %1, 1f\n"				\
+			"	sc  %1, %2, %z4\n"			\
+			"	beq %1, 1b\n"				\
+			"1:"						\
+			: "=&r" (__ret), "=&r" (__scratch)		\
+			: "r" (__ptr), "rO" (__old), "rO" (__new)	\
+			: "memory"					\
+		);							\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+									\
+	__ret;								\
+})
+
+#endif /* _ASM_XR17032_CMPXCHG_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cr.h linux-workdir/arch/xr17032/include/asm/cr.h
--- linux-clean/arch/xr17032/include/asm/cr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cr.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CR_H
+#define _ASM_XR17032_CR_H
+
+#define RS_U		0x00000001UL
+#define RS_I		0x00000002UL
+#define RS_M		0x00000004UL
+#define RS_T		0x00000008UL
+#define RS_OLD_U	0x00000100UL
+#define RS_OLD_I	0x00000200UL
+#define RS_OLD_M	0x00000400UL
+#define RS_OLD_T	0x00000800UL
+
+#define RS_ECAUSE	0xf0000000UL
+#define RS_ECAUSE_SYS	0x20000000UL
+#define RS_ECAUSE_PF_R	0xc0000000UL
+#define RS_ECAUSE_PF_W	0xd0000000UL
+
+#ifndef __ASSEMBLER__
+
+#define cr_read(cr) 			\
+({ 					\
+	unsigned long __v; 		\
+	asm volatile("mfcr %0, " #cr	\
+		     : "=r" (__v) :	\
+		     : "memory"); 	\
+	__v;				\
+})
+
+#define cr_write(cr, val)				\
+({							\
+	unsigned long __v = (unsigned long)(val);	\
+	asm volatile("mtcr " #cr ", %z0"		\
+		     : : "rO" (__v)			\
+		     : "memory");			\
+})
+
+#endif
+
+#endif /* _ASM_XR17032_CR_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/current.h linux-workdir/arch/xr17032/include/asm/current.h
--- linux-clean/arch/xr17032/include/asm/current.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/current.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CURRENT_H
+#define _ASM_XR17032_CURRENT_H
+
+struct task_struct;
+
+register struct task_struct *current asm("tp");
+register unsigned long current_stack_pointer asm("sp");
+
+#endif /* _ASM_XR17032_CURRENT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/elf.h linux-workdir/arch/xr17032/include/asm/elf.h
--- linux-clean/arch/xr17032/include/asm/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/elf.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ELF_H
+#define _ASM_XR17032_ELF_H
+
+#include <uapi/asm/elf.h>
+
+#define ELF_ARCH	EM_XR17032
+
+#ifndef ELF_CLASS
+#define ELF_CLASS	ELFCLASS32
+#endif
+
+#define ELF_DATA	ELFDATA2LSB
+
+#define ELF_EXEC_PAGESIZE	PAGE_SIZE
+#define ELF_PLATFORM		NULL
+#define ELF_HWCAP		0
+
+#define elf_check_arch(x) (((x)->e_machine == ELF_ARCH) &&		\
+			   ((x)->e_ident[EI_CLASS] == ELF_CLASS))
+
+#define ELF_ET_DYN_BASE		((DEFAULT_MAP_WINDOW / 3) * 2)
+
+#endif /* _ASM_XR17032_ELF_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/entry-common.h linux-workdir/arch/xr17032/include/asm/entry-common.h
--- linux-clean/arch/xr17032/include/asm/entry-common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/entry-common.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ENTRY_COMMON_H
+#define _ASM_XR17032_ENTRY_COMMON_H
+
+#include <asm/stacktrace.h>
+
+void do_trap(struct pt_regs *regs, int signo, int code, unsigned long addr);
+
+void handle_page_fault(struct pt_regs *regs);
+void handle_break(struct pt_regs *regs);
+
+#endif /* _ASM_XR17032_ENTRY_COMMON_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/extable.h linux-workdir/arch/xr17032/include/asm/extable.h
--- linux-clean/arch/xr17032/include/asm/extable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/extable.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_EXTABLE_H
+#define _ASM_XR17032_EXTABLE_H
+
+#include <asm/ptrace.h>
+
+struct exception_table_entry {
+	unsigned long insn, fixup;
+	short type, data;
+};
+
+bool fixup_exception(struct pt_regs *regs);
+
+#endif /* _ASM_XR17032_EXTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/fixmap.h linux-workdir/arch/xr17032/include/asm/fixmap.h
--- linux-clean/arch/xr17032/include/asm/fixmap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/fixmap.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_FIXMAP_H
+#define _ASM_XR17032_FIXMAP_H
+
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <linux/sizes.h>
+
+enum fixed_addresses {
+	FIX_HOLE,
+
+	FIX_EARLYCON_MEM_BASE,
+	FIX_TEMP,
+
+	__end_of_permanent_fixed_addresses,
+	/*
+	 * Temporary boot-time mappings, used by early_ioremap(),
+	 * before ioremap() is functional.
+	 */
+	#define NR_FIX_BTMAPS		(SZ_256K / PAGE_SIZE)
+	#define FIX_BTMAPS_SLOTS	7
+	#define TOTAL_FIX_BTMAPS	(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)
+
+	FIX_BTMAP_END = __end_of_permanent_fixed_addresses,
+	FIX_BTMAP_BEGIN = FIX_BTMAP_END + TOTAL_FIX_BTMAPS - 1,
+
+	__end_of_fixed_addresses
+};
+
+#define __early_set_fixmap	__set_fixmap
+
+extern void __set_fixmap(enum fixed_addresses idx,
+			 phys_addr_t phys, pgprot_t prot);
+
+#include <asm-generic/fixmap.h>
+
+#endif /* _ASM_XR17032_FIXMAP_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/gpr-num.h linux-workdir/arch/xr17032/include/asm/gpr-num.h
--- linux-clean/arch/xr17032/include/asm/gpr-num.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/gpr-num.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_GPR_NUM_H
+#define _ASM_XR17032_GPR_NUM_H
+
+#define __DEFINE_ASM_GPR_NUMS					\
+"	.equ	.L__gpr_num_zero,	0\n"			\
+"	.equ	.L__gpr_num_t0,		1\n"			\
+"	.equ	.L__gpr_num_t1,		2\n"			\
+"	.equ	.L__gpr_num_t2,		3\n"			\
+"	.equ	.L__gpr_num_t3,		4\n"			\
+"	.equ	.L__gpr_num_t4,		5\n"			\
+"	.equ	.L__gpr_num_t5,		6\n"			\
+"	.equ	.L__gpr_num_a0,		7\n"			\
+"	.equ	.L__gpr_num_a1,		8\n"			\
+"	.equ	.L__gpr_num_a2,		9\n"			\
+"	.equ	.L__gpr_num_a3,		10\n"			\
+"	.equ	.L__gpr_num_s0,		11\n"			\
+"	.equ	.L__gpr_num_s1,		12\n"			\
+"	.equ	.L__gpr_num_s2,		13\n"			\
+"	.equ	.L__gpr_num_s3,		14\n"			\
+"	.equ	.L__gpr_num_s4,		15\n"			\
+"	.equ	.L__gpr_num_s5,		16\n"			\
+"	.equ	.L__gpr_num_s6,		17\n"			\
+"	.equ	.L__gpr_num_s7,		18\n"			\
+"	.equ	.L__gpr_num_s8,		19\n"			\
+"	.equ	.L__gpr_num_s9,		20\n"			\
+"	.equ	.L__gpr_num_s10,	21\n"			\
+"	.equ	.L__gpr_num_s11,	22\n"			\
+"	.equ	.L__gpr_num_s12,	23\n"			\
+"	.equ	.L__gpr_num_s13,	24\n"			\
+"	.equ	.L__gpr_num_s14,	25\n"			\
+"	.equ	.L__gpr_num_s15,	26\n"			\
+"	.equ	.L__gpr_num_s16,	27\n"			\
+"	.equ	.L__gpr_num_t17,	28\n"			\
+"	.equ	.L__gpr_num_tp,		29\n"			\
+"	.equ	.L__gpr_num_sp,		30\n"			\
+"	.equ	.L__gpr_num_lr,		31\n"
+
+#endif /* _ASM_XR17032_GPR_NUM_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/irq.h linux-workdir/arch/xr17032/include/asm/irq.h
--- linux-clean/arch/xr17032/include/asm/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/irq.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_IRQ_H
+#define _ASM_XR17032_IRQ_H
+
+#include <asm-generic/irq.h>
+#include <linux/irqdomain.h>
+
+extern struct irq_domain *xr17032_intc_domain;
+
+#endif /* _ASM_XR17032_IRQ_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/irqflags.h linux-workdir/arch/xr17032/include/asm/irqflags.h
--- linux-clean/arch/xr17032/include/asm/irqflags.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/irqflags.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_IRQFLAGS_H
+#define _ASM_XR17032_IRQFLAGS_H
+
+#include <asm/cr.h>
+
+static inline unsigned long arch_local_save_flags(void)
+{
+	return cr_read(rs);
+}
+
+static inline void arch_local_irq_restore(unsigned long flags)
+{
+	cr_write(rs, cr_read(rs) | (flags & RS_I));
+}
+
+static inline void arch_local_irq_enable(void)
+{
+	arch_local_irq_restore(RS_I);
+}
+
+static inline void arch_local_irq_disable(void)
+{
+	arch_local_irq_restore(0);
+}
+
+static inline unsigned long arch_local_irq_save(void)
+{
+	unsigned long flags = cr_read(rs);
+	cr_write(rs, flags & ~RS_I);
+	return flags;
+}
+
+static inline int arch_irqs_disabled_flags(unsigned long flags)
+{
+	return !(flags & RS_I);
+}
+
+static inline int arch_irqs_disabled(void)
+{
+	return arch_irqs_disabled_flags(arch_local_save_flags());
+}
+
+#endif /* _ASM_XR17032_IRQFLAGS_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/mmu_context.h linux-workdir/arch/xr17032/include/asm/mmu_context.h
--- linux-clean/arch/xr17032/include/asm/mmu_context.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/mmu_context.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_MMU_CONTEXT_H
+#define _ASM_XR17032_MMU_CONTEXT_H
+
+#include <linux/mm_types.h>
+#include <asm-generic/mm_hooks.h>
+
+#include <linux/mm.h>
+#include <linux/sched.h>
+
+void switch_mm(struct mm_struct *prev, struct mm_struct *next,
+	       struct task_struct *task);
+
+#include <asm-generic/mmu_context.h>
+
+#endif /* _ASM_XR17032_MMU_CONTEXT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/page.h linux-workdir/arch/xr17032/include/asm/page.h
--- linux-clean/arch/xr17032/include/asm/page.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/page.h
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PAGE_H
+#define _ASM_XR17032_PAGE_H
+
+#include <linux/pfn.h>
+#include <vdso/page.h>
+
+#define PAGE_OFFSET		_AC(0xc0000000, UL)
+#define TASK_SIZE		_AC(0x80000000, UL)
+#define _PGTABLE_ADDR		TASK_SIZE
+
+#ifndef __ASSEMBLER__
+
+#define clear_page(pgaddr)			memset((pgaddr), 0, PAGE_SIZE)
+#define clear_user_page(pgaddr, vaddr, page)	clear_page(pgaddr)
+
+#define copy_page(to, from)			memcpy((to), (from), PAGE_SIZE)
+#define copy_user_page(vto, vfrom, vaddr, topg)	\
+			memcpy((vto), (vfrom), PAGE_SIZE)
+
+typedef struct {
+	unsigned long pgd;
+} pgd_t;
+
+typedef struct {
+	unsigned long pte;
+} pte_t;
+
+typedef struct {
+	unsigned long pgprot;
+} pgprot_t;
+
+typedef struct page *pgtable_t;
+
+#define pte_val(x)	((x).pte)
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x)	((pte_t) { (x) })
+#define __pgd(x)	((pgd_t) { (x) })
+#define __pgprot(x)	((pgprot_t) { (x) })
+
+#define is_linear_mapping(x)	((x) >= PAGE_OFFSET)
+
+#define linear_mapping_va_to_pa(x)	((unsigned long)(x) - PAGE_OFFSET)
+#define kernel_mapping_va_to_pa(x)					\
+({									\
+	unsigned long _y = ((unsigned long)(x) >> 10) & ~3UL;		\
+	_y |= _PGTABLE_ADDR;						\
+	_y = *(unsigned long *)_y;					\
+	(_y & ~0x1fUL) << 7;						\
+})
+
+#define __pa(x)								\
+({									\
+	unsigned long _x = (unsigned long)(x);				\
+	is_linear_mapping(_x) ? linear_mapping_va_to_pa(_x) 		\
+			      : kernel_mapping_va_to_pa(_x);		\
+})
+#define __va(x)	((void *)((unsigned long)(x) + PAGE_OFFSET))
+
+#define phys_to_pfn(phys)	(PFN_DOWN(phys))
+#define pfn_to_phys(pfn)	(PFN_PHYS(pfn))
+
+#define virt_to_pfn(vaddr)	(phys_to_pfn(__pa(vaddr)))
+#define pfn_to_virt(pfn)	(__va(pfn_to_phys(pfn)))
+
+#define virt_to_page(vaddr)	(pfn_to_page(virt_to_pfn(vaddr)))
+
+#define virt_addr_valid(vaddr)	({						\
+	unsigned long _addr = (unsigned long)vaddr;				\
+	(unsigned long)(_addr) >= PAGE_OFFSET && pfn_valid(virt_to_pfn(_addr));	\
+})
+
+#define PTE_FMT	"%08lx"
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#include <asm-generic/memory_model.h>
+#include <asm-generic/getorder.h>
+
+#endif /* _ASM_XR17032_PAGE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/pgalloc.h linux-workdir/arch/xr17032/include/asm/pgalloc.h
--- linux-clean/arch/xr17032/include/asm/pgalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/pgalloc.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PGALLOC_H
+#define _ASM_XR17032_PGALLOC_H
+
+#include <linux/mm.h>
+#include <asm/tlb.h>
+#include <asm-generic/pgalloc.h>
+
+static inline void sync_kernel_mappings(pgd_t *pgd)
+{
+	memcpy(pgd + USER_PTRS_PER_PGD,
+	       init_mm.pgd + USER_PTRS_PER_PGD,
+	       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
+}
+
+static inline pgd_t *pgd_alloc(struct mm_struct *mm)
+{
+	pgd_t *pgd;
+
+	pgd = __pgd_alloc(mm, 0);
+	if (likely(pgd != NULL)) {
+		/* Copy kernel mappings */
+		sync_kernel_mappings(pgd);
+	}
+	return pgd;
+}
+
+static inline void __pte_free_tlb(struct mmu_gather *tlb, pgtable_t pte,
+				  unsigned long addr)
+{
+	tlb_remove_ptdesc(tlb, page_ptdesc(pte));
+}
+
+static inline void pmd_populate_kernel(struct mm_struct *mm,
+				       pmd_t *pmd, pte_t *pte)
+{
+	unsigned long pfn = virt_to_pfn(pte);
+
+	set_pmd(pmd, __pmd((pfn << PFN_PTE_SHIFT) | _PAGE_TABLE));
+}
+
+static inline void pmd_populate(struct mm_struct *mm,
+				pmd_t *pmd, pgtable_t pte)
+{
+	unsigned long pfn = virt_to_pfn(page_address(pte));
+
+	set_pmd(pmd, __pmd((pfn << PFN_PTE_SHIFT) | _PAGE_TABLE));
+}
+
+#endif /* _ASM_XR17032_PGALLOC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/pgtable.h linux-workdir/arch/xr17032/include/asm/pgtable.h
--- linux-clean/arch/xr17032/include/asm/pgtable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/pgtable.h
@@ -0,0 +1,313 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PGTABLE_H
+#define _ASM_XR17032_PGTABLE_H
+
+#include <asm/page.h>
+#include <linux/const.h>
+
+#define PGDIR_SHIFT	22
+#define PGDIR_SIZE	(_AC(1, UL) << PGDIR_SHIFT)
+#define PGDIR_MASK	(~(PGDIR_SIZE - 1))
+
+#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
+#define _PGD_ADDR		(_PGTABLE_ADDR | (_PGTABLE_ADDR >> 10))
+#define _SWAPPER_PGD_ADDR	(_PGTABLE_ADDR + PGDIR_SIZE)
+#define KERNEL_LINK_ADDR	(_SWAPPER_PGD_ADDR + PAGE_SIZE)
+
+#define PTRS_PER_PGD	(PAGE_SIZE / 4)
+#define PTRS_PER_PTE	(PAGE_SIZE / 4)
+
+#define KERN_VIRT_SIZE	((PTRS_PER_PGD / 2 * PGDIR_SIZE) / 2)
+
+#define VMALLOC_SIZE	(KERN_VIRT_SIZE >> 1)
+#define VMALLOC_END	PAGE_OFFSET
+#define VMALLOC_START	(PAGE_OFFSET - VMALLOC_SIZE)
+
+#define FIXADDR_TOP	VMALLOC_START
+#define FIXADDR_SIZE	PGDIR_SIZE
+#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
+
+#ifndef __ASSEMBLER__
+
+#include <asm/tlbflush.h>
+#include <asm-generic/pgtable-nopmd.h>
+#include <linux/mmzone.h>
+
+#define PFN_PTE_SHIFT	5
+
+#define _PAGE_PRESENT	(1 << 0)
+#define _PAGE_WRITE	(1 << 1)
+#define _PAGE_KERNEL	(1 << 2)
+#define _PAGE_NO_CACHE	(1 << 3)
+#define _PAGE_GLOBAL	(1 << 4)
+#define _PAGE_ACCESSED	(1 << 25)
+#define _PAGE_DIRTY	(1 << 26)
+
+#define _PAGE_CHG_MASK  (~(unsigned long)(_PAGE_PRESENT | _PAGE_WRITE |	\
+					  _PAGE_KERNEL | _PAGE_GLOBAL))
+
+#define _PAGE_PROT_NONE	_PAGE_GLOBAL
+
+#define _PAGE_BASE	(_PAGE_PRESENT | _PAGE_ACCESSED)
+
+#define PAGE_NONE	__pgprot(_PAGE_PROT_NONE)
+#define PAGE_READ	__pgprot(_PAGE_BASE)
+#define PAGE_WRITE	__pgprot(_PAGE_BASE | _PAGE_WRITE)
+#define PAGE_EXEC	__pgprot(_PAGE_BASE)
+#define PAGE_READ_EXEC	__pgprot(_PAGE_BASE)
+#define PAGE_WRITE_EXEC	__pgprot(_PAGE_BASE | _PAGE_WRITE)
+
+#define PAGE_COPY		PAGE_READ
+#define PAGE_COPY_EXEC		PAGE_READ_EXEC
+#define PAGE_SHARED		PAGE_WRITE
+#define PAGE_SHARED_EXEC	PAGE_WRITE_EXEC
+
+#define _PAGE_SWP_EXCLUSIVE (1 << 5)
+
+#define _PAGE_KERNEL_BASE	(_PAGE_PRESENT \
+				| _PAGE_WRITE \
+				| _PAGE_KERNEL \
+				| _PAGE_GLOBAL \
+				| _PAGE_ACCESSED \
+				| _PAGE_DIRTY)
+
+#define _PAGE_TABLE		_PAGE_KERNEL_BASE
+#define _PAGE_IOREMAP		(_PAGE_KERNEL_BASE | _PAGE_NO_CACHE)
+
+#define PAGE_KERNEL		__pgprot(_PAGE_KERNEL_BASE)
+#define PAGE_KERNEL_READ	__pgprot(_PAGE_KERNEL_BASE & ~_PAGE_WRITE)
+#define PAGE_KERNEL_EXEC	__pgprot(_PAGE_KERNEL_BASE)
+#define PAGE_KERNEL_READ_EXEC	__pgprot(_PAGE_KERNEL_BASE & ~_PAGE_WRITE)
+#define PAGE_KERNEL_IO		__pgprot(_PAGE_IOREMAP)
+#define PAGE_TABLE		__pgprot(_PAGE_TABLE)
+
+#define __page_val_to_pfn(_val)  (((_val) & GENMASK(24, 5)) >> PFN_PTE_SHIFT)
+
+#define swapper_pg_dir ((pgd_t *)_SWAPPER_PGD_ADDR)
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero,
+ * used for zero-mapped memory areas, etc.
+ */
+extern unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)];
+#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
+
+#define pgd_ERROR(e) \
+	pr_err("%s:%d: bad pgd " PTE_FMT ".\n", __FILE__, __LINE__, pgd_val(e))
+
+#define pgprot_noncached pgprot_noncached
+static inline pgprot_t pgprot_noncached(pgprot_t _prot)
+{
+	return __pgprot(pgprot_val(_prot) | _PAGE_NO_CACHE);
+}
+
+static inline pte_t pfn_pte(unsigned long pfn, pgprot_t prot)
+{
+	return __pte((pfn << PFN_PTE_SHIFT) | pgprot_val(prot));
+}
+
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{
+	return __pte((pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot));
+}
+
+static inline int pte_present(pte_t pte)
+{
+	return pte_val(pte) & (_PAGE_PRESENT | _PAGE_PROT_NONE);
+}
+
+static inline int pte_none(pte_t pte)
+{
+	return pte_val(pte) == 0;
+}
+
+static inline int pte_write(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_WRITE;
+}
+
+static inline int pte_young(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_ACCESSED;
+}
+
+static inline int pte_dirty(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_DIRTY;
+}
+
+static inline unsigned long pte_pfn(pte_t pte)
+{
+	return __page_val_to_pfn(pte_val(pte));
+}
+
+#define pte_page(x)	pfn_to_page(pte_pfn(x))
+
+static inline pte_t pte_mkold(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_ACCESSED);
+}
+
+static inline pte_t pte_mkyoung(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_ACCESSED);
+}
+
+static inline pte_t pte_mkclean(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_DIRTY);
+}
+
+static inline pte_t pte_mkdirty(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_DIRTY);
+}
+
+static inline pte_t pte_mkwrite_novma(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_WRITE);
+}
+
+static inline pte_t pte_wrprotect(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_WRITE);
+}
+
+static inline void set_pte(pte_t *ptep, pte_t pteval)
+{
+	WRITE_ONCE(*ptep, pteval);
+}
+
+void flush_icache_pte(struct mm_struct *mm, pte_t pte);
+
+static inline void __set_pte_at(struct mm_struct *mm, pte_t *ptep, pte_t pteval)
+{
+	if (pte_present(pteval))
+		flush_icache_pte(mm, pteval);
+
+	set_pte(ptep, pteval);
+}
+
+static inline void pte_clear(struct mm_struct *mm,
+			     unsigned long addr, pte_t *ptep)
+{
+	__set_pte_at(mm, ptep, __pte(0));
+}
+
+/*
+ * Encode/decode swap entries and swap PTEs. Swap PTEs are all PTEs that
+ * are !pte_none() && !pte_present().
+ *
+ * Format of swap PTE:
+ *	bit            0:	_PAGE_PRESENT (zero)
+ *	bit            1:	_PAGE_WRITE (zero)
+ *	bit            2:	_PAGE_KERNEL (zero)
+ *	bit            3:	_PAGE_NO_CACHE (zero)
+ *	bit            4:	_PAGE_PROT_NONE (zero)
+ *	bit            5:	exclusive marker
+ *	bits      6 to 11:	swap type
+ *	bits     12 to 31:	swap offset
+ */
+#define __SWP_TYPE_SHIFT	5
+#define __SWP_TYPE_BITS		6
+#define __SWP_TYPE_MASK		((1UL << __SWP_TYPE_BITS) - 1)
+#define __SWP_OFFSET_SHIFT	(__SWP_TYPE_BITS + __SWP_TYPE_SHIFT)
+
+#define MAX_SWAPFILES_CHECK()	\
+	BUILD_BUG_ON(MAX_SWAPFILES_SHIFT > __SWP_TYPE_BITS)
+
+#define __swp_type(x)	(((x).val >> __SWP_TYPE_SHIFT) & __SWP_TYPE_MASK)
+#define __swp_offset(x)	((x).val >> __SWP_OFFSET_SHIFT)
+#define __swp_entry(type, offset) ((swp_entry_t) \
+	{ (((type) & __SWP_TYPE_MASK) << __SWP_TYPE_SHIFT) | \
+	  ((offset) << __SWP_OFFSET_SHIFT) })
+
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })
+
+static inline bool pte_swp_exclusive(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_SWP_EXCLUSIVE;
+}
+
+static inline pte_t pte_swp_clear_exclusive(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_SWP_EXCLUSIVE);
+}
+
+static inline pte_t pte_swp_mkexclusive(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_SWP_EXCLUSIVE);
+}
+
+static inline pgd_t pfn_pgd(unsigned long pfn, pgprot_t prot)
+{
+	return __pgd((pfn << PFN_PTE_SHIFT) | pgprot_val(prot));
+}
+
+static inline void set_pmd(pmd_t *pmdp, pmd_t pmd)
+{
+	WRITE_ONCE(*pmdp, pmd);
+}
+
+static inline void pmd_clear(pmd_t *pmdp)
+{
+	set_pmd(pmdp, __pmd(0));
+}
+
+static inline int pmd_none(pmd_t pmd)
+{
+	return pmd_val(pmd) == 0;
+}
+
+static inline int pmd_bad(pmd_t pmd)
+{
+	return 0;
+}
+
+static inline int pmd_present(pmd_t pmd)
+{
+	return (pmd_val(pmd) & (_PAGE_PRESENT | _PAGE_PROT_NONE));
+}
+
+static inline struct page *pmd_page(pmd_t pmd)
+{
+	return pfn_to_page(__page_val_to_pfn(pmd_val(pmd)));
+}
+
+static inline unsigned long pmd_page_vaddr(pmd_t pmd)
+{
+	return (unsigned long)pfn_to_virt(__page_val_to_pfn(pmd_val(pmd)));
+}
+
+#define __pmd_to_phys(pmd)  (__page_val_to_pfn(pmd_val(pmd)) << PAGE_SHIFT)
+
+static inline unsigned long pmd_pfn(pmd_t pmd)
+{
+	return ((__pmd_to_phys(pmd) & PMD_MASK) >> PAGE_SHIFT);
+}
+
+static inline void update_mmu_cache_range(struct vm_fault *vmf,
+					  struct vm_area_struct *vma, unsigned long address,
+					  pte_t *ptep, unsigned int nr)
+{
+	while (nr--)
+		local_flush_tlb_page(address + nr * PAGE_SIZE);
+}
+
+#define update_mmu_cache(vma, addr, ptep)	\
+	update_mmu_cache_range(NULL, vma, addr, ptep, 1)
+
+extern void *_dtb_early_va;
+extern uintptr_t _dtb_early_pa;
+
+void paging_init(void);
+void misc_mem_init(void);
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#endif /* _ASM_XR17032_PGTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/processor.h linux-workdir/arch/xr17032/include/asm/processor.h
--- linux-clean/arch/xr17032/include/asm/processor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/processor.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PROCESSOR_H
+#define _ASM_XR17032_PROCESSOR_H
+
+#define DEFAULT_MAP_WINDOW	TASK_SIZE
+#define STACK_TOP_MAX		TASK_SIZE
+
+#define STACK_ALIGN		4
+#define STACK_TOP		DEFAULT_MAP_WINDOW
+#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
+
+struct pt_regs;
+
+static inline void cpu_relax(void)
+{
+	asm volatile("pause" ::: "memory");
+}
+
+struct thread_struct {
+	/* Callee-saved registers */
+	unsigned long s[18];
+	unsigned long sp;
+	unsigned long lr;
+};
+
+#define INIT_THREAD					\
+{							\
+	.sp = sizeof(init_stack) + (long)&init_stack,	\
+}
+
+#define task_pt_regs(tsk)						\
+	((struct pt_regs *)(task_stack_page(tsk) + THREAD_SIZE		\
+			    - ALIGN(sizeof(struct pt_regs), STACK_ALIGN)))
+
+#define KSTK_EIP(tsk)	(task_pt_regs(tsk)->pc)
+#define KSTK_ESP(tsk)	(task_pt_regs(tsk)->sp)
+
+extern unsigned long __get_wchan(struct task_struct *p);
+
+extern void start_thread(struct pt_regs *regs,
+			 unsigned long pc, unsigned long sp);
+
+#endif /* _ASM_XR17032_PROCESSOR_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/ptrace.h linux-workdir/arch/xr17032/include/asm/ptrace.h
--- linux-clean/arch/xr17032/include/asm/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/ptrace.h
@@ -0,0 +1,72 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PTRACE_H
+#define _ASM_XR17032_PTRACE_H
+
+#include <asm/cr.h>
+#include <linux/compiler.h>
+#include <uapi/asm/ptrace.h>
+
+struct pt_regs {
+	unsigned long pc;
+	unsigned long t0;
+	unsigned long t1;
+	unsigned long t2;
+	unsigned long t3;
+	unsigned long t4;
+	unsigned long t5;
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long s0;
+	unsigned long s1;
+	unsigned long s2;
+	unsigned long s3;
+	unsigned long s4;
+	unsigned long s5;
+	unsigned long s6;
+	unsigned long s7;
+	unsigned long s8;
+	unsigned long s9;
+	unsigned long s10;
+	unsigned long s11;
+	unsigned long s12;
+	unsigned long s13;
+	unsigned long s14;
+	unsigned long s15;
+	unsigned long s16;
+	unsigned long s17;
+	unsigned long tp;
+	unsigned long sp;
+	unsigned long lr;
+	unsigned long rs;
+	unsigned long orig_a3;
+};
+
+#define MAX_REG_OFFSET offsetof(struct pt_regs, pc)
+
+#define PTRACE_SYSEMU 0x1f
+#define PTRACE_SYSEMU_SINGLESTEP 0x20
+
+#define user_mode(regs) (((regs)->rs & RS_OLD_U) != 0)
+
+static inline unsigned long user_stack_pointer(struct pt_regs *regs)
+{
+	return regs->sp;
+}
+
+static inline unsigned long instruction_pointer(struct pt_regs *regs)
+{
+	return regs->pc;
+}
+
+static inline bool regs_irqs_disabled(struct pt_regs *regs)
+{
+	return !(regs->rs & RS_OLD_I);
+}
+
+#endif /* _ASM_XR17032_PTRACE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/set_memory.h linux-workdir/arch/xr17032/include/asm/set_memory.h
--- linux-clean/arch/xr17032/include/asm/set_memory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/set_memory.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SET_MEMORY_H
+#define _ASM_XR17032_SET_MEMORY_H
+
+#define SECTION_ALIGN L1_CACHE_BYTES
+
+#endif /* _ASM_XR17032_SET_MEMORY_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/smp.h linux-workdir/arch/xr17032/include/asm/smp.h
--- linux-clean/arch/xr17032/include/asm/smp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/smp.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SMP_H
+#define _ASM_XR17032_SMP_H
+
+#include <asm/errno.h>
+
+extern unsigned long boot_cpu_hwid;
+
+#ifdef CONFIG_SMP
+#error "TODO"
+#else
+
+static inline int xr17032_cpu_hwid_to_cpuid(unsigned long cpu_hwid)
+{
+	if (cpu_hwid == boot_cpu_hwid)
+		return 0;
+
+	return -ENOENT;
+}
+
+#endif /* CONFIG_SMP */
+
+#endif /* _ASM_XR17032_SMP_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/sparsemem.h linux-workdir/arch/xr17032/include/asm/sparsemem.h
--- linux-clean/arch/xr17032/include/asm/sparsemem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/sparsemem.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SPARSEMEM_H
+#define _ASM_XR17032_SPARSEMEM_H
+
+#ifdef CONFIG_SPARSEMEM
+#define MAX_PHYSMEM_BITS	32
+#define SECTION_SIZE_BITS	25
+#endif
+
+#endif /* _ASM_XR17032_SPARSEMEM_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/stacktrace.h linux-workdir/arch/xr17032/include/asm/stacktrace.h
--- linux-clean/arch/xr17032/include/asm/stacktrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/stacktrace.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_STACKTRACE_H
+#define _ASM_XR17032_STACKTRACE_H
+
+#include <linux/sched.h>
+
+static inline bool on_thread_stack(void)
+{
+	return !(((unsigned long)(current->stack) ^ current_stack_pointer)
+		 & ~(THREAD_SIZE - 1));
+}
+
+#endif /* _ASM_XR17032_STACKTRACE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/string.h linux-workdir/arch/xr17032/include/asm/string.h
--- linux-clean/arch/xr17032/include/asm/string.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/string.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_STRING_H
+#define _ASM_XR17032_STRING_H
+
+#include <linux/types.h>
+#include <linux/linkage.h>
+
+#define __HAVE_ARCH_MEMSET
+extern asmlinkage void *memset(void *, int, size_t);
+extern asmlinkage void *__memset(void *, int, size_t);
+#define __HAVE_ARCH_MEMCPY
+extern asmlinkage void *memcpy(void *, const void *, size_t);
+extern asmlinkage void *__memcpy(void *, const void *, size_t);
+
+#endif /* _ASM_XR17032_STRING_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/syscall.h linux-workdir/arch/xr17032/include/asm/syscall.h
--- linux-clean/arch/xr17032/include/asm/syscall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/syscall.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SYSCALL_H
+#define _ASM_XR17032_SYSCALL_H
+
+#include <asm/ptrace.h>
+#include <uapi/linux/audit.h>
+
+extern void * const sys_call_table[];
+
+static inline int syscall_get_arch(struct task_struct *task)
+{
+	return AUDIT_ARCH_XR17032;
+}
+
+static inline int syscall_get_nr(struct task_struct *task, struct pt_regs *regs)
+{
+	return regs->t5;
+}
+
+static inline void syscall_rollback(struct task_struct *task,
+				    struct pt_regs *regs)
+{
+	regs->a3 = regs->orig_a3;
+}
+
+static inline long syscall_get_return_value(struct task_struct *task,
+					    struct pt_regs *regs)
+{
+	return regs->a3;
+}
+
+static inline void syscall_get_arguments(struct task_struct *task,
+					 struct pt_regs *regs,
+					 unsigned long *args)
+{
+	args[0] = regs->a0;
+	args[1] = regs->a1;
+	args[2] = regs->a2;
+	args[3] = regs->orig_a3;
+	args[4] = regs->t0;
+	args[5] = regs->t1;
+}
+
+static inline bool arch_syscall_is_vdso_sigreturn(struct pt_regs *regs)
+{
+	return false;
+}
+
+typedef long (*syscall_t)(const struct pt_regs *);
+static inline void syscall_handler(struct pt_regs *regs, ulong syscall)
+{
+	syscall_t fn = sys_call_table[syscall];
+	regs->a3 = fn(regs);
+}
+
+#endif /* _ASM_XR17032_SYSCALL_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/syscall_wrapper.h linux-workdir/arch/xr17032/include/asm/syscall_wrapper.h
--- linux-clean/arch/xr17032/include/asm/syscall_wrapper.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/syscall_wrapper.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SYSCALL_WRAPPER_H
+#define _ASM_XR17032_SYSCALL_WRAPPER_H
+
+#include <asm/ptrace.h>
+
+asmlinkage long __xr17032_sys_ni_syscall(const struct pt_regs *__unused);
+
+/*
+ * Use type aliasing to ensure registers are correctly passed to the syscall
+ * implementation when >word-size arguments are used.
+ */
+#define __SYSCALL_SE_DEFINEx(x, prefix, name, ...)					\
+	__diag_push();									\
+	__diag_ignore(GCC, 8, "-Wattribute-alias",					\
+			"Type aliasing is used to sanitize syscall arguments");		\
+	static long __se_##prefix##name(ulong, ulong, ulong, ulong, ulong, ulong)	\
+			__attribute__((alias(__stringify(___se_##prefix##name))));	\
+	__diag_pop();									\
+	static long noinline ___se_##prefix##name(__MAP(x,__SC_LONG,__VA_ARGS__))	\
+			__used;								\
+	static long ___se_##prefix##name(__MAP(x,__SC_LONG,__VA_ARGS__))
+
+#define SC_XR17032_REGS_TO_ARGS(x, ...) \
+	regs->a0,regs->a1,regs->a2,regs->orig_a3,regs->t0,regs->t1
+
+#define __SYSCALL_DEFINEx(x, name, ...)						\
+	asmlinkage long __xr17032_sys##name(const struct pt_regs *regs);	\
+	ALLOW_ERROR_INJECTION(__xr17032_sys_##name, ERRNO);			\
+	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));	\
+	__SYSCALL_SE_DEFINEx(x, sys, name, __VA_ARGS__)				\
+	{									\
+		long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));	\
+		__MAP(x,__SC_TEST,__VA_ARGS__);					\
+		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));		\
+		return ret;							\
+	}									\
+	asmlinkage long __xr17032_sys##name(const struct pt_regs *regs)	\
+	{									\
+		return __se_sys##name(SC_XR17032_REGS_TO_ARGS(x,__VA_ARGS__));	\
+	}									\
+	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))
+
+#define SYSCALL_DEFINE0(sname)							\
+	SYSCALL_METADATA(_##sname, 0);						\
+	asmlinkage long __xr17032_sys_##sname(const struct pt_regs *__unused);	\
+	ALLOW_ERROR_INJECTION(__xr17032_sys_##sname, ERRNO);			\
+	asmlinkage long __xr17032_sys_##sname(const struct pt_regs *__unused)
+
+#define COND_SYSCALL(name)							\
+	asmlinkage long __weak __xr17032_sys_##name(const struct pt_regs *regs);\
+	asmlinkage long __weak __xr17032_sys_##name(const struct pt_regs *regs)	\
+	{									\
+		return sys_ni_syscall();					\
+	}
+
+#endif /* _ASM_XR17032_SYSCALL_WRAPPER_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/thread_info.h linux-workdir/arch/xr17032/include/asm/thread_info.h
--- linux-clean/arch/xr17032/include/asm/thread_info.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/thread_info.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_THREAD_INFO_H
+#define _ASM_XR17032_THREAD_INFO_H
+
+#include <asm/page.h>
+
+#define THREAD_SIZE_ORDER 	0
+#define THREAD_SIZE		(PAGE_SIZE << THREAD_SIZE_ORDER)
+#define THREAD_ALIGN		THREAD_SIZE
+
+#ifndef __ASSEMBLER__
+
+struct thread_info {
+	unsigned long 	flags;
+	int		preempt_count;
+	unsigned long	syscall_work;
+};
+
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.flags		= 0,			\
+	.preempt_count	= INIT_PREEMPT_COUNT,	\
+}
+
+#define TIF_NEED_RESCHED 0
+#define TIF_NOTIFY_SIGNAL 1
+#define TIF_SIGPENDING 2
+#define TIF_SYSCALL_TRACE 3
+#define TIF_MEMDIE 4
+#define TIF_NOTIFY_RESUME 5
+
+#define _TIF_NEED_RESCHED (1 << TIF_NEED_RESCHED)
+#define _TIF_NOTIFY_SIGNAL (1 << TIF_NOTIFY_SIGNAL)
+#define _TIF_SIGPENDING (1 << TIF_SIGPENDING)
+#define _TIF_SYSCALL_TRACE (1 << TIF_SYSCALL_TRACE)
+#define _TIF_MEMDIE (1 << TIF_MEMDIE)
+#define _TIF_NOTIFY_RESUME (1 << TIF_NOTIFY_RESUME)
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#endif /* _ASM_XR17032_THREAD_INFO_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/tlb.h linux-workdir/arch/xr17032/include/asm/tlb.h
--- linux-clean/arch/xr17032/include/asm/tlb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/tlb.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_TLB_H
+#define _ASM_XR17032_TLB_H
+
+struct mmu_gather;
+
+static void tlb_flush(struct mmu_gather *tlb);
+
+#define tlb_flush tlb_flush
+#include <asm-generic/tlb.h>
+
+static inline void tlb_flush(struct mmu_gather *tlb)
+{
+	if (tlb->fullmm || tlb->need_flush_all || tlb->freed_tables)
+		flush_tlb_mm(tlb->mm);
+	else
+		flush_tlb_mm_range(tlb->mm, tlb->start, tlb->end,
+				   tlb_get_unmap_size(tlb));
+}
+
+#endif /* _ASM_XR17032_TLB_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/tlbflush.h linux-workdir/arch/xr17032/include/asm/tlbflush.h
--- linux-clean/arch/xr17032/include/asm/tlbflush.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/tlbflush.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_TLBFLUSH_H
+#define _ASM_XR17032_TLBFLUSH_H
+
+#include <asm/page.h>
+#include <linux/mm_types.h>
+
+void flush_tlb_mm(struct mm_struct *mm);
+void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
+			unsigned long end, unsigned int page_size);
+void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr);
+void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+		     unsigned long end);
+void flush_tlb_kernel_range(unsigned long start, unsigned long end);
+
+static inline void local_flush_tlb_all(void)
+{
+	asm volatile("mtcr itbctrl, %0" :: "r" (1UL) : "memory");
+	asm volatile("mtcr dtbctrl, %0" :: "r" (1UL) : "memory");
+}
+
+static inline void local_flush_tlb_page(unsigned long addr)
+{
+	addr &= PAGE_MASK;
+	asm volatile("mtcr itbctrl, %0" :: "r" (addr) : "memory");
+	asm volatile("mtcr dtbctrl, %0" :: "r" (addr) : "memory");
+	asm volatile(
+		"mtcr dtbctrl, %0"
+		:
+		: "r" (_PGTABLE_ADDR | (addr >> 10))
+		: "memory"
+	);
+}
+
+#endif /* _ASM_XR17032_TLBFLUSH_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/uaccess.h linux-workdir/arch/xr17032/include/asm/uaccess.h
--- linux-clean/arch/xr17032/include/asm/uaccess.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/uaccess.h
@@ -0,0 +1,251 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_UACCESS_H
+#define _ASM_XR17032_UACCESS_H
+
+#include <asm/asm-extable.h>
+#include <asm/extable.h>
+#include <asm/pgtable.h>
+#include <asm-generic/access_ok.h>
+#include <linux/compiler.h>
+#include <linux/errno.h>
+
+unsigned long __must_check __asm_copy_to_user(void __user *to,
+					      const void *from,
+					      unsigned long n);
+unsigned long __must_check __asm_copy_from_user(void *to,
+						const void __user *from,
+						unsigned long n);
+
+#ifdef CONFIG_CC_HAS_ASM_GOTO_OUTPUT
+#define __get_user_asm(x, ptr, label)				\
+	asm_goto_output(					\
+		"1:\n"						\
+		"	mov %0, %1\n"				\
+		_ASM_EXTABLE_UACCESS_ERR(1b, %l2, %0)		\
+		: "=&r" (x)					\
+		: "m" (*(ptr)) : : label			\
+	)
+#define __get_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u32 __lo, __hi;						\
+	asm_goto_output(					\
+		"1:\n"						\
+		"	mov %0, %2\n"				\
+		"2:\n"						\
+		"	mov %1, %3\n"				\
+		_ASM_EXTABLE_UACCESS_ERR(1b, %l4, %0)		\
+		_ASM_EXTABLE_UACCESS_ERR(2b, %l4, %0)		\
+		: "=&r" (__lo), "=r" (__hi)			\
+		: "m" (__ptr[0]), "m" (__ptr[1])		\
+		: : label);                                     \
+	(x) = (typeof(x))((typeof((x) - (x)))(			\
+		(((u64)__hi << 32) | __lo)));			\
+} while (0)
+#else /* !CONFIG_CC_HAS_ASM_GOTO_OUTPUT */
+#define __get_user_asm(x, ptr, label)				\
+do {								\
+	long __gua_err = 0;					\
+	asm volatile(						\
+		"1:\n"						\
+		"	mov %1, %2\n"				\
+		"2:\n"						\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(1b, 2b, %0, %1)	\
+		: "+r" (__gua_err), "=&r" (x)			\
+		: "m" (*(ptr))					\
+	);							\
+	if (__gua_err)						\
+		goto label;					\
+} while (0)
+#define __get_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u32 __lo, __hi;						\
+	long __gu8_err = 0;					\
+	__asm__ __volatile__ (					\
+		"1:\n"						\
+		"	mov %1, %3\n"				\
+		"2:\n"						\
+		"	mov %2, %4\n"				\
+		"3:\n"						\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(1b, 3b, %0, %1)	\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(2b, 3b, %0, %1)	\
+		: "+r" (__gu8_err), "=&r" (__lo), "=r" (__hi)	\
+		: "m" (__ptr[0]), "m" (__ptr[1]));		\
+	if (__gu8_err) {					\
+		__hi = 0;					\
+		goto label;					\
+	}							\
+	(x) = (typeof(x))((typeof((x) - (x)))(			\
+		(((u64)__hi << 32) | __lo)));			\
+} while (0)
+#endif /* CONFIG_CC_HAS_ASM_GOTO_OUTPUT */
+
+#define __get_user_nocheck(x, __gu_ptr, label)				\
+do {									\
+	if (!IS_ALIGNED((uintptr_t)__gu_ptr, sizeof(*__gu_ptr))) {	\
+		if (__asm_copy_from_user((void *)&(x),			\
+					 (const void *)__gu_ptr,	\
+			                 sizeof(*__gu_ptr))) 		\
+			goto label;					\
+		break;							\
+	}								\
+	switch (sizeof(*__gu_ptr)) {					\
+	case 1:								\
+	case 2:								\
+	case 4:								\
+		__get_user_asm((x), __gu_ptr, label);			\
+		break;							\
+	case 8:								\
+		__get_user_8((x), __gu_ptr, label);			\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+} while (0)
+
+#define __get_user_error(x, ptr, err)					\
+do {									\
+	__label__ __gu_failed;						\
+									\
+	__get_user_nocheck(x, ptr, __gu_failed);			\
+		err = 0;						\
+		break;							\
+__gu_failed:								\
+		x = 0;							\
+		err = -EFAULT;						\
+} while (0)
+
+#define __get_user(x, ptr)					\
+({								\
+	const typeof(*(ptr)) __user *__gu_ptr = (ptr);		\
+	long __gu_err = 0;					\
+	typeof(x) __gu_val;					\
+								\
+	__chk_user_ptr(__gu_ptr);				\
+								\
+	__get_user_error(__gu_val, __gu_ptr, __gu_err);		\
+								\
+	(x) = __gu_val;						\
+								\
+	__gu_err;						\
+})
+
+#define get_user(x, ptr)					\
+({								\
+	const typeof(*(ptr)) __user *__p = (ptr);		\
+	might_fault();						\
+	access_ok(__p, sizeof(*__p)) ?				\
+		__get_user((x), __p) :				\
+		((x) = (__force typeof(x))0, -EFAULT);		\
+})
+
+#define __put_user_asm(x, ptr, label)				\
+do {								\
+	typeof(*(ptr)) __x = x;					\
+	asm goto(						\
+		"1:\n"						\
+		"	mov %1, %z0\n"				\
+		_ASM_EXTABLE(1b, %l2)				\
+		: : "rO" (__x), "m"(*(ptr)) : : label);		\
+} while (0)
+#define __put_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u64 __x = (typeof((x)-(x)))(x);				\
+	asm goto(						\
+		"1:\n"						\
+		"	mov %2, %z0\n"				\
+		"2:\n"						\
+		"	mov %3, %z1\n"				\
+		_ASM_EXTABLE(1b, %l4)				\
+		_ASM_EXTABLE(2b, %l4)				\
+		: : "rO" ((u32)__x), "rO" ((u32)(__x >> 32)),	\
+			"m" (__ptr[0]),				\
+			"m" (__ptr[1]) : : label);		\
+} while (0)
+
+#define __put_user_nocheck(x, __gu_ptr, label)				\
+do {									\
+	if (!IS_ALIGNED((uintptr_t)__gu_ptr, sizeof(*__gu_ptr))) {	\
+		if (__asm_copy_to_user((void *)__gu_ptr,		\
+				       (const void *)&((x)),		\
+				       sizeof(*__gu_ptr)))		\
+			goto label;					\
+		break;							\
+	}								\
+	switch (sizeof(*__gu_ptr)) {					\
+	case 1:								\
+	case 2:								\
+	case 4:								\
+		__put_user_asm((x), __gu_ptr, label);			\
+		break;							\
+	case 8:								\
+		__put_user_8((x), __gu_ptr, label);			\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+} while (0)
+
+#define __put_user_error(x, ptr, err)				\
+do {								\
+	__label__ err_label;					\
+	__put_user_nocheck(x, ptr, err_label);			\
+	break;							\
+err_label:							\
+	(err) = -EFAULT;					\
+} while (0)
+
+#define __put_user(x, ptr)					\
+({								\
+	typeof(*(ptr)) __user *__gu_ptr = (ptr); 		\
+	typeof(*__gu_ptr) __val = (x);				\
+	long __pu_err = 0;					\
+								\
+	__chk_user_ptr(__gu_ptr);				\
+								\
+	__put_user_error(__val, __gu_ptr, __pu_err);		\
+								\
+	__pu_err;						\
+})
+
+#define put_user(x, ptr)					\
+({								\
+	typeof(*(ptr)) __user *__p = (ptr);			\
+	might_fault();						\
+	access_ok(__p, sizeof(*__p)) ? __put_user((x), __p)	\
+				     : -EFAULT;			\
+})
+
+static inline unsigned long
+raw_copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	return __asm_copy_from_user(to, from, n);
+}
+
+static inline unsigned long
+raw_copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	return __asm_copy_to_user(to, from, n);
+}
+
+extern unsigned long __must_check __clear_user(void __user *addr,
+					       unsigned long n);
+
+static inline unsigned long __must_check clear_user(void __user *to,
+						    unsigned long n)
+{
+	might_fault();
+	return access_ok(to, n) ? __clear_user(to, n) : n;
+}
+
+extern long strncpy_from_user(char *dest, const char __user *src, long count);
+
+extern long __must_check strnlen_user(const char __user *str, long n);
+
+#endif /* _ASM_XR17032_UACCESS_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/unistd.h linux-workdir/arch/xr17032/include/asm/unistd.h
--- linux-clean/arch/xr17032/include/asm/unistd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/unistd.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_UNISTD_H
+#define _ASM_XR17032_UNISTD_H
+
+#define __ARCH_WANT_SYS_CLONE
+
+#include <uapi/asm/unistd.h>
+
+#define NR_syscalls (__NR_syscalls)
+
+#endif /* _ASM_XR17032_UNISTD_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/vmalloc.h linux-workdir/arch/xr17032/include/asm/vmalloc.h
--- linux-clean/arch/xr17032/include/asm/vmalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/vmalloc.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_VMALLOC_H
+#define _ASM_XR17032_VMALLOC_H
+
+#endif /* _ASM_XR17032_VMALLOC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/byteorder.h linux-workdir/arch/xr17032/include/uapi/asm/byteorder.h
--- linux-clean/arch/xr17032/include/uapi/asm/byteorder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/byteorder.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_BYTEORDER_H
+#define _UAPI_ASM_XR17032_BYTEORDER_H
+
+#include <linux/byteorder/little_endian.h>
+
+#endif /* _UAPI_ASM_XR17032_BYTEORDER_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/elf.h linux-workdir/arch/xr17032/include/uapi/asm/elf.h
--- linux-clean/arch/xr17032/include/uapi/asm/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/elf.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_ELF_H
+#define _UAPI_ASM_XR17032_ELF_H
+
+#include <asm/ptrace.h>
+
+typedef struct user_regs_struct elf_gregset_t;
+typedef unsigned int elf_fpregset_t;
+
+#endif /* _UAPI_ASM_XR17032_ELF_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/ptrace.h linux-workdir/arch/xr17032/include/uapi/asm/ptrace.h
--- linux-clean/arch/xr17032/include/uapi/asm/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/ptrace.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_PTRACE_H
+#define _UAPI_ASM_XR17032_PTRACE_H
+
+/* must be a prefix of struct pt_regs */
+struct user_regs_struct {
+	unsigned long pc;
+	unsigned long t0;
+	unsigned long t1;
+	unsigned long t2;
+	unsigned long t3;
+	unsigned long t4;
+	unsigned long t5;
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long s0;
+	unsigned long s1;
+	unsigned long s2;
+	unsigned long s3;
+	unsigned long s4;
+	unsigned long s5;
+	unsigned long s6;
+	unsigned long s7;
+	unsigned long s8;
+	unsigned long s9;
+	unsigned long s10;
+	unsigned long s11;
+	unsigned long s12;
+	unsigned long s13;
+	unsigned long s14;
+	unsigned long s15;
+	unsigned long s16;
+	unsigned long s17;
+	unsigned long tp;
+	unsigned long sp;
+	unsigned long lr;
+};
+
+#endif /* _UAPI_ASM_XR17032_PTRACE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/sigcontext.h linux-workdir/arch/xr17032/include/uapi/asm/sigcontext.h
--- linux-clean/arch/xr17032/include/uapi/asm/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/sigcontext.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_SIGCONTEXT_H
+#define _UAPI_ASM_XR17032_SIGCONTEXT_H
+
+#include <asm/ptrace.h>
+
+/*
+ * Signal context structure
+ *
+ * This contains the context saved before a signal handler is invoked;
+ * it is restored by sys_rt_sigreturn.
+ */
+struct sigcontext {
+	struct user_regs_struct sc_regs;
+};
+
+#endif /* _UAPI_ASM_XR17032_SIGCONTEXT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/ucontext.h linux-workdir/arch/xr17032/include/uapi/asm/ucontext.h
--- linux-clean/arch/xr17032/include/uapi/asm/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/ucontext.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_UCONTEXT_H
+#define _UAPI_ASM_XR17032_UCONTEXT_H
+
+#include <asm/signal.h>
+#include <linux/types.h>
+
+struct ucontext {
+	unsigned long	  uc_flags;
+	struct ucontext	 *uc_link;
+	stack_t		  uc_stack;
+	sigset_t	  uc_sigmask;
+	/*
+	 * There's some padding here to allow sigset_t to be expanded in the
+	 * future.  Though this is unlikely, other architectures put uc_sigmask
+	 * at the end of this structure and explicitly state it can be
+	 * expanded, so we didn't want to box ourselves in here.
+	 */
+	__u8		  __unused[1024 / 8 - sizeof(sigset_t)];
+	/*
+	 * We can't put uc_sigmask at the end of this structure because we need
+	 * to be able to expand sigcontext in the future.  For example, a
+	 * vector ISA extension would almost certainly add ISA state.  We want
+	 * to ensure all user-visible ISA state can be saved and restored via a
+	 * ucontext, so we're putting this at the end in order to allow for
+	 * infinite extensibility.  Since we know this will be extended and we
+	 * assume sigset_t won't be extended an extreme amount, we're
+	 * prioritizing this.
+	 */
+	struct sigcontext uc_mcontext;
+};
+
+#endif /* _UAPI_ASM_XR17032_UCONTEXT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/Makefile linux-workdir/arch/xr17032/kernel/Makefile
--- linux-clean/arch/xr17032/kernel/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/Makefile
@@ -0,0 +1,19 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the XR/17032 Linux kernel
+#
+
+always-$(KBUILD_BUILTIN)	+= vmlinux.lds
+
+obj-y	+= context.o
+obj-y	+= entry.o
+obj-y	+= head.o
+obj-y	+= irq.o
+obj-y	+= process.o
+obj-y	+= setup.o
+obj-y	+= signal.o
+obj-y	+= sys_xr17032.o
+obj-y	+= syscall_table.o
+obj-y	+= time.o
+
+obj-y	+= stubs.o
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/asm-offsets.c linux-workdir/arch/xr17032/kernel/asm-offsets.c
--- linux-clean/arch/xr17032/kernel/asm-offsets.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/asm-offsets.c
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/ptrace.h>
+#include <linux/kbuild.h>
+#include <linux/sched.h>
+
+void asm_offsets(void);
+
+void asm_offsets(void)
+{
+	DEFINE(PT_SIZE_ON_STACK, ALIGN(sizeof(struct pt_regs), STACK_ALIGN));
+	OFFSET(PT_T0, pt_regs, t0);
+	OFFSET(PT_T1, pt_regs, t1);
+	OFFSET(PT_T2, pt_regs, t2);
+	OFFSET(PT_T3, pt_regs, t3);
+	OFFSET(PT_T4, pt_regs, t4);
+	OFFSET(PT_T5, pt_regs, t5);
+	OFFSET(PT_A0, pt_regs, a0);
+	OFFSET(PT_A1, pt_regs, a1);
+	OFFSET(PT_A2, pt_regs, a2);
+	OFFSET(PT_A3, pt_regs, a3);
+	OFFSET(PT_S0, pt_regs, s0);
+	OFFSET(PT_S1, pt_regs, s1);
+	OFFSET(PT_S2, pt_regs, s2);
+	OFFSET(PT_S3, pt_regs, s3);
+	OFFSET(PT_S4, pt_regs, s4);
+	OFFSET(PT_S5, pt_regs, s5);
+	OFFSET(PT_S6, pt_regs, s6);
+	OFFSET(PT_S7, pt_regs, s7);
+	OFFSET(PT_S8, pt_regs, s8);
+	OFFSET(PT_S9, pt_regs, s9);
+	OFFSET(PT_S10, pt_regs, s10);
+	OFFSET(PT_S11, pt_regs, s11);
+	OFFSET(PT_S12, pt_regs, s12);
+	OFFSET(PT_S13, pt_regs, s13);
+	OFFSET(PT_S14, pt_regs, s14);
+	OFFSET(PT_S15, pt_regs, s15);
+	OFFSET(PT_S16, pt_regs, s16);
+	OFFSET(PT_S17, pt_regs, s17);
+	OFFSET(PT_TP, pt_regs, tp);
+	OFFSET(PT_SP, pt_regs, sp);
+	OFFSET(PT_LR, pt_regs, lr);
+	OFFSET(PT_PC, pt_regs, pc);
+	OFFSET(PT_RS, pt_regs, rs);
+	OFFSET(TASK_THREAD_S0, task_struct, thread.s[0]);
+	OFFSET(TASK_THREAD_S1, task_struct, thread.s[1]);
+	OFFSET(TASK_THREAD_S2, task_struct, thread.s[2]);
+	OFFSET(TASK_THREAD_S3, task_struct, thread.s[3]);
+	OFFSET(TASK_THREAD_S4, task_struct, thread.s[4]);
+	OFFSET(TASK_THREAD_S5, task_struct, thread.s[5]);
+	OFFSET(TASK_THREAD_S6, task_struct, thread.s[6]);
+	OFFSET(TASK_THREAD_S7, task_struct, thread.s[7]);
+	OFFSET(TASK_THREAD_S8, task_struct, thread.s[8]);
+	OFFSET(TASK_THREAD_S9, task_struct, thread.s[9]);
+	OFFSET(TASK_THREAD_S10, task_struct, thread.s[10]);
+	OFFSET(TASK_THREAD_S11, task_struct, thread.s[11]);
+	OFFSET(TASK_THREAD_S12, task_struct, thread.s[12]);
+	OFFSET(TASK_THREAD_S13, task_struct, thread.s[13]);
+	OFFSET(TASK_THREAD_S14, task_struct, thread.s[14]);
+	OFFSET(TASK_THREAD_S15, task_struct, thread.s[15]);
+	OFFSET(TASK_THREAD_S16, task_struct, thread.s[16]);
+	OFFSET(TASK_THREAD_S17, task_struct, thread.s[17]);
+	OFFSET(TASK_THREAD_SP, task_struct, thread.sp);
+	OFFSET(TASK_THREAD_LR, task_struct, thread.lr);
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/context.c linux-workdir/arch/xr17032/kernel/context.c
--- linux-clean/arch/xr17032/kernel/context.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/context.c
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/mmu_context.h>
+#include <linux/linkage.h>
+#include <linux/sched/mm.h>
+
+asmlinkage void xr17032_switch_mm(unsigned long pfn);
+
+static inline void set_mm(struct mm_struct *prev, struct mm_struct *next,
+			  unsigned int cpu)
+{
+	cpumask_set_cpu(cpu, mm_cpumask(next));
+	cpumask_clear_cpu(cpu, mm_cpumask(prev));
+
+	unsigned long flags = arch_local_irq_save();
+	xr17032_switch_mm(virt_to_pfn(next->pgd));
+	arch_local_irq_restore(flags);
+}
+
+static inline void flush_icache_deferred(struct mm_struct *mm, unsigned int cpu,
+					 struct task_struct *task)
+{
+#ifdef CONFIG_SMP
+	if (cpumask_test_and_clear_cpu(cpu, &mm->context.icache_stale_mask)) {
+		smp_mb();
+
+		if (!(task && switch_to_should_flush_icache(task)))
+			local_flush_icache_all();
+	}
+#endif
+}
+
+void switch_mm(struct mm_struct *prev, struct mm_struct *next,
+	       struct task_struct *task)
+{
+	if (unlikely(prev == next))
+		return;
+
+	unsigned int cpu = smp_processor_id();
+	set_mm(prev, next, cpu);
+	flush_icache_deferred(next, cpu, task);
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/entry.c linux-workdir/arch/xr17032/kernel/entry.c
--- linux-clean/arch/xr17032/kernel/entry.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/entry.c
@@ -0,0 +1,269 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/bug.h>
+#include <asm/irq_regs.h>
+#include <asm/ptrace.h>
+#include <asm/syscall.h>
+#include <linux/entry-common.h>
+#include <linux/hardirq.h>
+#include <linux/irq.h>
+#include <linux/kdebug.h>
+#include <linux/linkage.h>
+#include <linux/mm.h>
+#include <linux/panic.h>
+#include <linux/randomize_kstack.h>
+#include <linux/sched/debug.h>
+#include <linux/sched/signal.h>
+#include <linux/signal.h>
+
+int show_unhandled_signals = 1;
+
+static DEFINE_RAW_SPINLOCK(die_lock);
+
+static int copy_code(struct pt_regs *regs, u32 *val, const u32 *insns)
+{
+	const void __user *uaddr = (__force const void __user *)insns;
+
+	if (!user_mode(regs))
+		return get_kernel_nofault(*val, insns);
+
+	/* The user space code from other tasks cannot be accessed. */
+	if (regs != task_pt_regs(current))
+		return -EPERM;
+
+	return copy_from_user_nofault(val, uaddr, sizeof(*val));
+}
+
+static void dump_instr(const char *loglvl, struct pt_regs *regs)
+{
+	char str[sizeof("00000000 ") * 12 + 2 + 1], *p = str;
+	const u32 *insns = (u32 *)instruction_pointer(regs);
+
+	for (int i = -10; i < 2; i++) {
+		u32 val;
+		long bad = copy_code(regs, &val, &insns[i]);
+		if (!bad) {
+			p += sprintf(p, i == 0 ? "(%08x) " : "%08x ", val);
+		} else {
+			printk("%sCode: Unable to access instruction at 0x%px.\n",
+			       loglvl, &insns[i]);
+			return;
+		}
+	}
+
+	printk("%sCode: %s\n", loglvl, str);
+}
+
+void die(struct pt_regs *regs, const char *str)
+{
+	static int die_counter;
+	int ret;
+	long cause;
+	unsigned long flags;
+
+	oops_enter();
+
+	raw_spin_lock_irqsave(&die_lock, flags);
+	console_verbose();
+	bust_spinlocks(1);
+
+	pr_emerg("%s [#%d]\n", str, ++die_counter);
+	print_modules();
+	if (regs) {
+		show_regs(regs);
+		dump_instr(KERN_EMERG, regs);
+	}
+
+	cause = regs ? (regs->rs >> 28) : -1;
+	ret = notify_die(DIE_OOPS, str, regs, 0, cause, SIGSEGV);
+
+	bust_spinlocks(0);
+	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);
+	raw_spin_unlock_irqrestore(&die_lock, flags);
+	oops_exit();
+
+	if (in_interrupt())
+		panic("Fatal exception in interrupt");
+	if (panic_on_oops)
+		panic("Fatal exception");
+	if (ret != NOTIFY_STOP)
+		make_task_dead(SIGSEGV);
+}
+
+void do_trap(struct pt_regs *regs, int signo, int code, unsigned long addr)
+{
+	struct task_struct *tsk = current;
+
+	if (show_unhandled_signals && unhandled_signal(tsk, signo)
+	    && printk_ratelimit()) {
+		pr_info("%s[%d]: unhandled signal %d code 0x%x at 0x%08lx",
+			tsk->comm, task_pid_nr(tsk), signo, code, addr);
+		print_vma_addr(KERN_CONT " in ", instruction_pointer(regs));
+		pr_cont("\n");
+		__show_regs(regs);
+		dump_instr(KERN_INFO, regs);
+	}
+
+	force_sig_fault(signo, code, (void __user *)addr);
+}
+
+
+static void do_trap_error(struct pt_regs *regs, int signo, int code,
+			  unsigned long addr, const char *str)
+{
+	if (user_mode(regs)) {
+		do_trap(regs, signo, code, addr);
+	} else {
+		if (!fixup_exception(regs))
+			die(regs, str);
+	}
+}
+
+void handle_break(struct pt_regs *regs)
+{
+	if (user_mode(regs))
+		force_sig_fault(SIGTRAP, TRAP_BRKPT, (void __user *)regs->pc);
+#ifdef CONFIG_KGDB
+	else if (notify_die(DIE_TRAP, "BRK", regs, 0, regs->rs >> 28, SIGTRAP)
+		 == NOTIFY_STOP)
+		return;
+#endif
+	else if (report_bug(regs->pc, regs) == BUG_TRAP_TYPE_WARN)
+		return;
+	else
+		die(regs, "Kernel BUG");
+}
+
+#define TRAP_FUNC_PROTO(name) asmlinkage void name(struct pt_regs *regs)
+#define TRAP_FUNC(name) TRAP_FUNC_PROTO(name); TRAP_FUNC_PROTO(name)
+
+TRAP_FUNC(xr17032_handle_interrupt)
+{
+	irqentry_state_t state = irqentry_enter(regs);
+
+	irq_enter_rcu();
+	struct pt_regs *old_regs = set_irq_regs(regs);
+	handle_arch_irq(regs);
+	set_irq_regs(old_regs);
+	irq_exit_rcu();
+
+	irqentry_exit(regs, state);
+}
+
+TRAP_FUNC(xr17032_handle_page_fault)
+{
+	irqentry_state_t state = irqentry_enter(regs);
+
+	handle_page_fault(regs);
+
+	irqentry_exit(regs, state);
+}
+
+TRAP_FUNC(xr17032_handle_syscall)
+{
+	if (!user_mode(regs)) {
+		irqentry_state_t state = irqentry_nmi_enter(regs);
+
+		do_trap_error(regs, SIGILL, ILL_ILLTRP, regs->pc,
+			      "Oops - syscall from kernel mode");
+
+		irqentry_nmi_exit(regs, state);
+	}
+
+	long syscall = regs->t5;
+
+	regs->orig_a3 = regs->a3;
+	regs->a3 = -ENOSYS;
+
+	syscall = syscall_enter_from_user_mode(regs, syscall);
+
+	add_random_kstack_offset();
+
+	if (syscall >= 0 && syscall < NR_syscalls)
+		syscall_handler(regs, syscall);
+
+	choose_random_kstack_offset(get_random_u16());
+
+	syscall_exit_to_user_mode(regs);
+}
+
+TRAP_FUNC(xr17032_handle_breakpoint)
+{
+	if (user_mode(regs)) {
+		irqentry_enter_from_user_mode(regs);
+		local_irq_enable();
+
+		handle_break(regs);
+
+		local_irq_disable();
+		irqentry_exit_to_user_mode(regs);
+	} else {
+		irqentry_state_t state = irqentry_nmi_enter(regs);
+
+		handle_break(regs);
+
+		irqentry_nmi_exit(regs, state);
+	}
+}
+
+TRAP_FUNC(xr17032_handle_bus_error)
+{
+	if (user_mode(regs)) {
+		irqentry_enter_from_user_mode(regs);
+		local_irq_enable();
+
+		die(regs, "Oops - bus error");
+
+		local_irq_disable();
+		irqentry_exit_to_user_mode(regs);
+	} else {
+		irqentry_state_t state = irqentry_nmi_enter(regs);
+
+		die(regs, "Oops - bus error");
+
+		irqentry_nmi_exit(regs, state);
+	}
+}
+
+TRAP_FUNC(xr17032_handle_nmi)
+{
+	if (user_mode(regs)) {
+		irqentry_enter_from_user_mode(regs);
+		local_irq_enable();
+
+		die(regs, "Oops - non-maskable interrupt");
+
+		local_irq_disable();
+		irqentry_exit_to_user_mode(regs);
+	} else {
+		irqentry_state_t state = irqentry_nmi_enter(regs);
+
+		die(regs, "Oops - non-maskable interrupt");
+
+		irqentry_nmi_exit(regs, state);
+	}
+}
+
+#define DO_ERROR_INFO(name, signo, code, str)					\
+TRAP_FUNC(name)									\
+{										\
+	if (user_mode(regs)) {							\
+		irqentry_enter_from_user_mode(regs);				\
+		local_irq_enable();						\
+		do_trap_error(regs, signo, code, regs->pc, "Oops - " str);	\
+		local_irq_disable();						\
+		irqentry_exit_to_user_mode(regs);				\
+	} else {								\
+		irqentry_state_t state = irqentry_nmi_enter(regs);		\
+		do_trap_error(regs, signo, code, regs->pc, "Oops - " str);	\
+		irqentry_nmi_exit(regs, state);					\
+	}									\
+}
+
+DO_ERROR_INFO(xr17032_handle_invalid_instruction, SIGILL, ILL_ILLOPC,
+	      "illegal instruction")
+DO_ERROR_INFO(xr17032_handle_unaligned_access, SIGBUS, BUS_ADRALN,
+	      "unaligned access")
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/head.S linux-workdir/arch/xr17032/kernel/head.S
--- linux-clean/arch/xr17032/kernel/head.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/head.S
@@ -0,0 +1,456 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/cr.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/thread_info.h>
+#include <asm/unistd.h>
+#include <generated/asm-offsets.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+
+__HEAD
+.Lexception_block:
+
+SYM_DATA_START_LOCAL(xrlinux_header)
+	.long 0x584c5258		# magic
+	.word 0				# minor version
+	.word 2				# major version
+	.long xrlinux_header		# virtual address
+	.long _end - xrlinux_header	# size in memory
+	.long _start			# entrypoint
+	.long 1				# flags: map dtb
+	.long _end			# dtb address
+	.long FIXADDR_START - 1		# max dtb end
+SYM_DATA_END(xrlinux_header)
+
+SYM_CODE_START(_start)
+	# set up everything in advance so that in the region where nmi masking
+	# is necessary (from first rs write to functioning irq entry/exit) we
+	# only execute mtcr (and one jump)
+
+	# value to write to *itbctrl to clear the tb
+	addi t0, zero, 3
+
+	# virtual address of exception block
+	lui t1, zero, %hi(.Lexception_block)
+	ori t1, t1, %lo(.Lexception_block)
+
+	# itbtag value for exception block
+	add t2, zero, t1 RSH 12
+
+	# itbpte value for exception block
+	add t3, zero, a0 RSH 7
+	ori t3, t3, 0x17 # global, kernel, writable, valid
+
+	# dtbtag value for page table
+	lui t4, zero, %hi(_PGD_ADDR >> 12)
+	ori t4, t4, %lo(_PGD_ADDR >> 12)
+
+	# dtbpte value for page table
+	add t5, zero, s0 RSH 7
+	ori t5, t5, 0x17 # global, kernel, writable, valid
+
+	# create entry for recursive paging
+	# all cpus will do this, but they'll all be writing the same value to
+	# the same address, so it doesn't matter
+	mov long [s0 + ((_PGTABLE_ADDR >> 22) * 4)], t5
+
+	# value to write to *tbaddr
+	lui s0, zero, %hi(_PGTABLE_ADDR)
+	ori s0, s0, %lo(_PGTABLE_ADDR)
+
+	# value to write to scratch2
+	lui tp, zero, %hi(init_task)
+	ori tp, tp, %lo(init_task)
+
+	# value to write to scratch3
+	add s1, zero, t5 RSH 5
+
+	# initial value for *tbindex and value to write to rs to enable paging
+	addi s1, zero, 4
+
+	# itbtag value for temporary identity map of exception block
+	add s2, zero, a0 RSH 12
+
+	# canonicalize rs to T=0, M=0, I=0, U=0
+	mtcr rs, zero
+
+	# fully clear the tbs
+	mtcr itbctrl, t0
+	mtcr dtbctrl, t0
+
+	# set up exception block (incl. wired itb entry)
+	mtcr eb, t1
+	mtcr itbindex, zero
+	mtcr itbtag, t2
+	mtcr itbpte, t3
+
+	# set up wired dtb entry for page table
+	mtcr dtbindex, zero
+	mtcr dtbtag, t4
+	mtcr dtbpte, t5
+
+	# prepare for enabling paging
+	mtcr itbaddr, s0
+	mtcr dtbaddr, s0
+	mtcr itbindex, s1
+	mtcr dtbindex, s1
+
+	# create non-wired tb entry for identity map of exception block
+	mtcr itbtag, s2
+	mtcr itbpte, t3
+
+	# enable paging
+	mtcr rs, s1
+
+	# set up scratch registers
+	mtcr scratch1, zero
+	mtcr scratch2, tp
+	mtcr scratch3, t5
+
+	# jump to virtual addressing (and out of exception block)
+	jalr zero, t1, _start_kernel - .Lexception_block
+SYM_CODE_END(_start)
+
+.macro trap_entry cfunc
+	mtcr scratch0, sp
+	mfcr sp, scratch1
+	bne sp, 1f
+	mfcr sp, scratch0
+1:	mtcr scratch1, zero # make sure nested irqs don't reset the stack
+	# save registers on the newly obtained stack
+	subi sp, sp, PT_SIZE_ON_STACK
+	mov long [sp + PT_T0], t0
+	mfcr t0, scratch0
+	mov long [sp + PT_T1], t1
+	mfcr t1, epc
+	mov long [sp + PT_T2], t2
+	mfcr t2, rs
+	mov long [sp + PT_T3], t3
+	mov long [sp + PT_T4], t4
+	mov long [sp + PT_T5], t5
+	mov long [sp + PT_A0], a0
+	mov long [sp + PT_A1], a1
+	mov long [sp + PT_A2], a2
+	mov long [sp + PT_A3], a3
+	mov long [sp + PT_S0], s0
+	mov long [sp + PT_S1], s1
+	mov long [sp + PT_S2], s2
+	mov long [sp + PT_S3], s3
+	mov long [sp + PT_S4], s4
+	mov long [sp + PT_S5], s5
+	mov long [sp + PT_S6], s6
+	mov long [sp + PT_S7], s7
+	mov long [sp + PT_S8], s8
+	mov long [sp + PT_S9], s9
+	mov long [sp + PT_S10], s10
+	mov long [sp + PT_S11], s11
+	mov long [sp + PT_S12], s12
+
+	mov long [sp + PT_S13], s13
+	mov long [sp + PT_S14], s14
+	mov long [sp + PT_S15], s15
+	mov long [sp + PT_S16], s16
+	mov long [sp + PT_S17], s17
+	mov long [sp + PT_TP], tp
+	mov long [sp + PT_SP], t0
+	mov long [sp + PT_LR], lr
+	mov long [sp + PT_PC], t1
+	mov long [sp + PT_RS], t2
+
+	# set up c environment
+	addi s0, zero, 0
+	mfcr tp, scratch2
+
+	# call c function
+	add a0, sp, zero
+	jal \cfunc
+	j return_from_trap
+.endm
+
+.org 0x100
+SYM_CODE_START_LOCAL(interrupt_entry)
+	trap_entry xr17032_handle_interrupt
+SYM_CODE_END(interrupt_entry)
+
+.org 0x200
+SYM_CODE_START_LOCAL(syscall_entry)
+	trap_entry xr17032_handle_syscall
+SYM_CODE_END(syscall_entry)
+
+.org 0x300
+SYM_CODE_START(xr17032_switch_mm)
+	# dtbtag value
+	lui t1, zero, (_PGD_ADDR >> 12)
+	ori t1, t1, (_PGD_ADDR >> 12)
+
+	# dtbpte value
+	add t2, zero, a0 LSH 5
+	ori t2, t2, 0x17 # global, kernel, writable, valid
+
+	# do switch
+	mfcr t0, dtbindex
+	mtcr dtbindex, zero
+	mtcr dtbtag, t1
+	mtcr dtbpte, t2
+	mtcr dtbindex, t0
+	mtcr scratch3, a0
+
+	# invalidate non-global tb entries
+	addi t0, zero, 2
+	mtcr itbctrl, t0
+	mtcr dtbctrl, t0
+
+	# return
+	jalr zero, lr, 0
+SYM_CODE_END(xr17032_switch_mm)
+
+.org 0x400
+SYM_CODE_START_LOCAL(bus_error_entry)
+	trap_entry xr17032_handle_bus_error
+SYM_CODE_END(bus_error_entry)
+
+.org 0x500
+SYM_CODE_START_LOCAL(nmi_entry)
+	trap_entry xr17032_handle_nmi
+SYM_CODE_END(nmi_entry)
+
+.org 0x600
+SYM_CODE_START_LOCAL(breakpoint_entry)
+	trap_entry xr17032_handle_breakpoint
+SYM_CODE_END(breakpoint_entry)
+
+.org 0x700
+SYM_CODE_START_LOCAL(invalid_instruction_entry)
+	trap_entry xr17032_handle_invalid_instruction
+SYM_CODE_END(invalid_instruction_entry)
+
+.org 0x800
+SYM_CODE_START_LOCAL(privileged_instruction_entry)
+	trap_entry xr17032_handle_invalid_instruction
+SYM_CODE_END(privileged_instruction_entry)
+
+.org 0x900
+SYM_CODE_START_LOCAL(unaligned_access_entry)
+	trap_entry xr17032_handle_unaligned_access
+SYM_CODE_END(unaligned_access_entry)
+
+.org 0xc00
+SYM_CODE_START_LOCAL(read_page_fault_entry)
+	trap_entry xr17032_handle_page_fault
+SYM_CODE_END(read_page_fault_entry)
+
+.org 0xd00
+SYM_CODE_START_LOCAL(write_page_fault_entry)
+	trap_entry xr17032_handle_page_fault
+SYM_CODE_END(write_page_fault_entry)
+
+.org 0xe00
+SYM_CODE_START_LOCAL(handle_itb_miss)
+	mfcr zero, itbaddr
+	mov zero, long [zero]
+	mtcr itbpte, zero
+	rfe
+SYM_CODE_END(handle_itb_miss)
+
+.org 0xf00
+SYM_CODE_START_LOCAL(handle_dtb_miss)
+	mfcr zero, dtbaddr
+	mov zero, long [zero]
+	mtcr dtbpte, zero
+	rfe
+SYM_CODE_END(handle_dtb_miss)
+
+# skip over exception block
+.org 0x1000
+
+SYM_CODE_START_LOCAL(_start_kernel)
+	# remove temporary identity map itb entry
+	addi t0, zero, 1
+	mtcr itbctrl, t0
+
+	# get a logical cpu id
+	lui t0, zero, %hi(num_started_cpus)
+	ori t0, t0, %lo(num_started_cpus)
+1:	ll a0, t0
+	addi t1, a0, 1
+	sc t1, t0, t1
+	beq t1, 1b
+
+	# make sure we don't have more cpus than we know how to deal with
+#ifdef CONFIG_SMP
+	slti t1, a0, CONFIG_NR_CPUS
+	bne t1, .Lpark_cpu
+#else
+	bne a0, .Lpark_cpu
+#endif
+
+	# only continue on cpu0
+	bne a0, .Lpark_cpu
+
+	# set up boot_cpu_hwid
+	lui t0, zero, %hi(boot_cpu_hwid)
+	ori t0, t0, %lo(boot_cpu_hwid)
+	mfcr t1, whami
+	mov long [t0], t1
+
+	# set up c environment
+	lui sp, zero, %hi(init_thread_union + THREAD_SIZE - PT_SIZE_ON_STACK)
+	ori sp, sp, %lo(init_thread_union + THREAD_SIZE - PT_SIZE_ON_STACK)
+
+	addi s0, zero, 0
+
+	# wait until all cpus have entered the kernel
+	lui t0, zero, %hi(num_started_cpus)
+	ori t0, t0, %lo(num_started_cpus)
+1:	mov t1, long [t0]
+	slt t1, t1, a2
+	bne t1, 1b
+	mb
+
+	# call c entry point
+	add a0, a1, zero
+	jal setup_vm
+	jal start_kernel
+	brk
+
+.Lpark_cpu:
+	hlt
+	beq zero, .Lpark_cpu
+SYM_CODE_END(_start_kernel)
+
+SYM_CODE_START(ret_from_fork_kernel_asm)
+	jal schedule_tail
+	add a0, s2, zero
+	add a1, s1, zero
+	add s2, sp, zero
+	jal ret_from_fork_kernel
+	j return_from_trap
+SYM_CODE_END(ret_from_fork_kernel_asm)
+
+SYM_CODE_START(ret_from_fork_user_asm)
+	jal schedule_tail
+	add a0, sp, zero
+	jal ret_from_fork_user
+	j return_from_trap
+SYM_CODE_END(ret_from_fork_user_asm)
+
+SYM_CODE_START_LOCAL(return_from_trap)
+	# restore most registers
+	mov t1, long [sp + PT_T1]
+	mov t2, long [sp + PT_T2]
+	mov t3, long [sp + PT_T3]
+	mov t4, long [sp + PT_T4]
+	mov t5, long [sp + PT_T5]
+	mov a0, long [sp + PT_A0]
+	mov a1, long [sp + PT_A1]
+	mov a2, long [sp + PT_A2]
+	mov a3, long [sp + PT_A3]
+	mov s0, long [sp + PT_S0]
+	mov s1, long [sp + PT_S1]
+	mov s2, long [sp + PT_S2]
+	mov s3, long [sp + PT_S3]
+	mov s4, long [sp + PT_S4]
+	mov s5, long [sp + PT_S5]
+	mov s6, long [sp + PT_S6]
+	mov s7, long [sp + PT_S7]
+	mov s8, long [sp + PT_S8]
+	mov s9, long [sp + PT_S9]
+	mov s10, long [sp + PT_S10]
+	mov s11, long [sp + PT_S11]
+	mov s12, long [sp + PT_S12]
+	mov s13, long [sp + PT_S13]
+	mov s14, long [sp + PT_S14]
+	mov s15, long [sp + PT_S15]
+	mov s16, long [sp + PT_S16]
+	mov s17, long [sp + PT_S17]
+	mov lr, long [sp + PT_LR]
+
+	# restore rs first since this will also disable irqs
+	mov t0, long [sp + PT_RS]
+	mtcr rs, t0
+	# set up scratch1 if going to user mode
+	andi t0, t0, RS_OLD_U
+	beq t0, 1f
+	addi t0, sp, PT_SIZE_ON_STACK
+	mtcr scratch1, t0
+1:	# finish register restoration
+	mov tp, long [sp + PT_TP]
+	mov t0, long [sp + PT_PC]
+	mtcr epc, t0
+	mov t0, long [sp + PT_T0]
+	mov sp, long [sp + PT_SP]
+	rfe
+SYM_CODE_END(return_from_trap)
+
+# note: this function must preserve a0 and a1
+SYM_CODE_START(__switch_to)
+	# save registers to old task
+	mov long [a0 + TASK_THREAD_S0], s0
+	mov long [a0 + TASK_THREAD_S1], s1
+	mov long [a0 + TASK_THREAD_S2], s2
+	mov long [a0 + TASK_THREAD_S3], s3
+	mov long [a0 + TASK_THREAD_S4], s4
+	mov long [a0 + TASK_THREAD_S5], s5
+	mov long [a0 + TASK_THREAD_S6], s6
+	mov long [a0 + TASK_THREAD_S7], s7
+	mov long [a0 + TASK_THREAD_S8], s8
+	mov long [a0 + TASK_THREAD_S9], s9
+	mov long [a0 + TASK_THREAD_S10], s10
+	mov long [a0 + TASK_THREAD_S11], s11
+	mov long [a0 + TASK_THREAD_S12], s12
+	mov long [a0 + TASK_THREAD_S13], s13
+	mov long [a0 + TASK_THREAD_S14], s14
+	mov long [a0 + TASK_THREAD_S15], s15
+	mov long [a0 + TASK_THREAD_S16], s16
+	mov long [a0 + TASK_THREAD_S17], s17
+	mov long [a0 + TASK_THREAD_SP], sp
+	mov long [a0 + TASK_THREAD_LR], lr
+
+	# set new thread pointer
+	add tp, a1, zero
+	mtcr scratch2, tp
+
+	# restore registers from new task
+	mov s0, long [a1 + TASK_THREAD_S0]
+	mov s1, long [a1 + TASK_THREAD_S1]
+	mov s2, long [a1 + TASK_THREAD_S2]
+	mov s3, long [a1 + TASK_THREAD_S3]
+	mov s4, long [a1 + TASK_THREAD_S4]
+	mov s5, long [a1 + TASK_THREAD_S5]
+	mov s6, long [a1 + TASK_THREAD_S6]
+	mov s7, long [a1 + TASK_THREAD_S7]
+	mov s8, long [a1 + TASK_THREAD_S8]
+	mov s9, long [a1 + TASK_THREAD_S9]
+	mov s10, long [a1 + TASK_THREAD_S10]
+	mov s11, long [a1 + TASK_THREAD_S11]
+	mov s12, long [a1 + TASK_THREAD_S12]
+	mov s13, long [a1 + TASK_THREAD_S13]
+	mov s14, long [a1 + TASK_THREAD_S14]
+	mov s15, long [a1 + TASK_THREAD_S15]
+	mov s16, long [a1 + TASK_THREAD_S16]
+	mov s17, long [a1 + TASK_THREAD_S17]
+	mov sp, long [a1 + TASK_THREAD_SP]
+	mov lr, long [a1 + TASK_THREAD_LR]
+
+	jalr zero, lr, 0
+SYM_CODE_END(__switch_to)
+
+.section ".rodata", "a", %progbits
+
+.balign 4
+SYM_DATA_START(__user_rt_sigreturn)
+	addi t5, zero, __NR_rt_sigreturn
+	sys
+SYM_DATA_END(__user_rt_sigreturn)
+
+.bss
+
+.balign 4
+SYM_DATA_START_LOCAL(num_started_cpus)
+	.space 4
+SYM_DATA_END(num_started_cpus)
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/irq.c linux-workdir/arch/xr17032/kernel/irq.c
--- linux-clean/arch/xr17032/kernel/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/irq.c
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/panic.h>
+
+void __init init_IRQ(void)
+{
+	irqchip_init();
+	if (!handle_arch_irq)
+		panic("no interrupt controllers found");
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/process.c linux-workdir/arch/xr17032/kernel/process.c
--- linux-clean/arch/xr17032/kernel/process.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/process.c
@@ -0,0 +1,110 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/bug.h>
+#include <linux/entry-common.h>
+#include <linux/linkage.h>
+#include <linux/printk.h>
+#include <linux/ptrace.h>
+#include <linux/sched.h>
+#include <linux/sched/debug.h>
+
+asmlinkage void ret_from_fork_kernel_asm(void);
+asmlinkage void ret_from_fork_kernel(void *fn_arg, int (*fn)(void *),
+				     struct pt_regs *regs);
+
+asmlinkage void ret_from_fork_user_asm(void);
+asmlinkage void ret_from_fork_user(struct pt_regs *regs);
+
+asmlinkage void ret_from_fork_kernel(void *fn_arg, int (*fn)(void *),
+				     struct pt_regs *regs)
+{
+	fn(fn_arg);
+	syscall_exit_to_user_mode(regs);
+}
+
+asmlinkage void ret_from_fork_user(struct pt_regs *regs)
+{
+	syscall_exit_to_user_mode(regs);
+}
+
+int copy_thread(struct task_struct *p, const struct kernel_clone_args *args)
+{
+	unsigned long clone_flags = args->flags;
+	unsigned long usp = args->stack;
+	unsigned long tls = args->tls;
+	struct pt_regs *childregs = task_pt_regs(p);
+
+	memset(&p->thread, 0, sizeof(p->thread));
+
+	if (unlikely(args->fn)) {
+		memset(childregs, 0, sizeof(*childregs));
+		childregs->rs = RS_OLD_M | RS_OLD_I | RS_M;
+
+		p->thread.s[1] = (unsigned long)args->fn;
+		p->thread.s[2] = (unsigned long)args->fn_arg;
+		p->thread.lr = (unsigned long)ret_from_fork_kernel_asm;
+	} else {
+		*childregs = *current_pt_regs();
+		if (usp)
+			childregs->sp = usp;
+		if (clone_flags & CLONE_SETTLS)
+			childregs->tp = tls;
+		childregs->a3 = 0; /* return value of fork() */
+		p->thread.lr = (unsigned long)ret_from_fork_user_asm;
+	}
+
+	p->thread.sp = (unsigned long)childregs;
+	return 0;
+}
+
+void flush_thread(void)
+{
+}
+
+void start_thread(struct pt_regs *regs, unsigned long pc, unsigned long sp)
+{
+	regs->rs = RS_OLD_M | RS_OLD_I | RS_OLD_U | RS_M;
+	regs->pc = pc;
+	regs->sp = sp;
+}
+
+void __show_regs(struct pt_regs *regs)
+{
+	show_regs_print_info(KERN_DEFAULT);
+
+	if (!user_mode(regs)) {
+		pr_cont(" pc : %pS\n", (void *)regs->pc);
+		pr_cont(" lr : %pS\n", (void *)regs->lr);
+	}
+
+	pr_cont(" t0 : %08lx t1 : %08lx t2 : %08lx\n",
+		regs->t0, regs->t1, regs->t2);
+	pr_cont(" t3 : %08lx t4 : %08lx t5 : %08lx\n",
+		regs->t3, regs->t4, regs->t5);
+	pr_cont(" a0 : %08lx a1 : %08lx a2 : %08lx\n",
+		regs->a0, regs->a1, regs->a2);
+	pr_cont(" a3 : %08lx s0 : %08lx s1 : %08lx\n",
+		regs->a3, regs->s0, regs->s1);
+	pr_cont(" s2 : %08lx s3 : %08lx s4 : %08lx\n",
+		regs->s2, regs->s3, regs->s4);
+	pr_cont(" s5 : %08lx s6 : %08lx s7 : %08lx\n",
+		regs->s5, regs->s6, regs->s7);
+	pr_cont(" s8 : %08lx s9 : %08lx s10: %08lx\n",
+		regs->s8, regs->s9, regs->s10);
+	pr_cont(" s11: %08lx s12: %08lx s13: %08lx\n",
+		regs->s11, regs->s12, regs->s13);
+	pr_cont(" s14: %08lx s15: %08lx s16: %08lx\n",
+		regs->s14, regs->s15, regs->s16);
+	pr_cont(" s17: %08lx tp : %08lx sp : %08lx\n",
+		regs->s17, regs->tp, regs->sp);
+	pr_cont(" lr : %08lx pc : %08lx rs : %08lx\n",
+		regs->lr, regs->pc, regs->rs);
+}
+
+void show_regs(struct pt_regs *regs)
+{
+	__show_regs(regs);
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/setup.c linux-workdir/arch/xr17032/kernel/setup.c
--- linux-clean/arch/xr17032/kernel/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/setup.c
@@ -0,0 +1,132 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/early_ioremap.h>
+#include <asm/pgtable.h>
+#include <asm/sections.h>
+#include <asm/smp.h>
+#include <linux/memblock.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/jump_label.h>
+#include <linux/of_fdt.h>
+#include <linux/panic.h>
+#include <linux/printk.h>
+
+unsigned long boot_cpu_hwid;
+
+static void __init parse_dtb(void)
+{
+	if (early_init_dt_scan(_dtb_early_va, _dtb_early_pa)) {
+		const char *name = of_flat_dt_get_machine_name();
+
+		if (name) {
+			pr_info("Machine model: %s\n", name);
+			dump_stack_set_arch_desc("%s", name);
+		}
+	} else {
+		pr_err("Invalid DTB");
+	}
+}
+
+static int num_standard_resources;
+static struct resource *standard_resources;
+
+static int __init add_resource(struct resource *parent, struct resource *res)
+{
+	int ret = insert_resource(parent, res);
+	if (ret < 0) {
+		pr_err("Failed to add a %s resource at %llx\n", res->name,
+		       (unsigned long long) res->start);
+		return ret;
+	}
+
+	return 1;
+}
+
+static void __init init_resources(void)
+{
+	struct memblock_region *region = NULL;
+	struct resource *res = NULL;
+	struct resource *mem_res = NULL;
+
+	/* +1 as memblock_alloc() might increase memblock.reserved.cnt */
+	int num_resources = memblock.memory.cnt + memblock.reserved.cnt + 1;
+	int res_idx = num_resources - 1;
+	int non_resv_res = 0;
+
+	size_t mem_res_sz = num_resources * sizeof(*mem_res);
+	mem_res = memblock_alloc_or_panic(mem_res_sz, SMP_CACHE_BYTES);
+
+	int ret;
+
+	for_each_reserved_mem_region(region) {
+		res = &mem_res[res_idx--];
+
+		res->name = "Reserved";
+		res->flags = IORESOURCE_MEM | IORESOURCE_EXCLUSIVE;
+		res->start = __pfn_to_phys(memblock_region_reserved_base_pfn(region));
+		res->end = __pfn_to_phys(memblock_region_reserved_end_pfn(region)) - 1;
+
+		if (memblock_is_memory(res->start)) {
+			res_idx++;
+			continue;
+		}
+
+		ret = add_resource(&iomem_resource, res);
+		if (ret < 0)
+			goto error;
+	}
+
+	for_each_mem_region(region) {
+		res = &mem_res[res_idx--];
+		non_resv_res++;
+
+		if (unlikely(memblock_is_nomap(region))) {
+			res->name = "Reserved";
+			res->flags = IORESOURCE_MEM | IORESOURCE_EXCLUSIVE;
+		} else {
+			res->name = "System RAM";
+			res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+		}
+
+		res->start = __pfn_to_phys(memblock_region_reserved_base_pfn(region));
+		res->end = __pfn_to_phys(memblock_region_reserved_end_pfn(region)) - 1;
+
+		ret = add_resource(&iomem_resource, res);
+		if (ret < 0)
+			goto error;
+	}
+
+	num_standard_resources = non_resv_res;
+	standard_resources = &mem_res[res_idx + 1];
+
+	if (res_idx >= 0)
+		memblock_free(mem_res, (res_idx + 1) * sizeof(*mem_res));
+	return;
+
+error:
+	release_child_resources(&iomem_resource);
+	memblock_free(mem_res, mem_res_sz);
+}
+
+void __init setup_arch(char **cmdline_p)
+{
+	parse_dtb();
+	setup_initial_init_mm(_stext, _etext, _edata, _end);
+
+	*cmdline_p = boot_command_line;
+
+	early_ioremap_setup();
+	jump_label_init();
+	parse_early_param();
+
+	paging_init();
+
+	unflatten_device_tree();
+	misc_mem_init();
+
+	init_resources();
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/signal.c linux-workdir/arch/xr17032/kernel/signal.c
--- linux-clean/arch/xr17032/kernel/signal.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/signal.c
@@ -0,0 +1,249 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/cr.h>
+#include <asm/ucontext.h>
+#include <linux/entry-common.h>
+#include <linux/signal.h>
+#include <linux/syscalls.h>
+
+extern u32 __user_rt_sigreturn[2];
+
+#define DEBUG_SIG 0
+
+struct rt_sigframe {
+	struct siginfo info;
+	struct ucontext uc;
+	u32 sigreturn_code[2];
+};
+
+static long restore_sigcontext(struct pt_regs *regs,
+	struct sigcontext __user *sc)
+{
+	/* sc_regs is structured the same as the start of pt_regs */
+	long err = __copy_from_user(regs, &sc->sc_regs, sizeof(sc->sc_regs));
+	if (unlikely(err))
+		return err;
+
+	return 0;
+}
+
+SYSCALL_DEFINE0(rt_sigreturn)
+{
+	struct pt_regs *regs = current_pt_regs();
+	struct rt_sigframe __user *frame;
+	struct task_struct *task;
+	sigset_t set;
+	size_t frame_size = sizeof(*frame);
+
+	/* Always make any pending restarted system calls return -EINTR */
+	current->restart_block.fn = do_no_restart_syscall;
+
+	frame = (struct rt_sigframe __user *)regs->sp;
+
+	if (!access_ok(frame, frame_size))
+		goto badframe;
+
+	if (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))
+		goto badframe;
+
+	set_current_blocked(&set);
+
+	if (restore_sigcontext(regs, &frame->uc.uc_mcontext))
+		goto badframe;
+
+	if (restore_altstack(&frame->uc.uc_stack))
+		goto badframe;
+
+	return regs->a3;
+
+badframe:
+	task = current;
+	if (show_unhandled_signals) {
+		pr_info_ratelimited(
+			"%s[%d]: bad frame in %s: frame=%p pc=%p sp=%p\n",
+			task->comm, task_pid_nr(task), __func__,
+			frame, (void *)regs->pc, (void *)regs->sp);
+	}
+	force_sig(SIGSEGV);
+	return 0;
+}
+
+static long setup_sigcontext(struct rt_sigframe __user *frame,
+	struct pt_regs *regs)
+{
+	struct sigcontext __user *sc = &frame->uc.uc_mcontext;
+	long err;
+
+	/* sc_regs is structured the same as the start of pt_regs */
+	err = __copy_to_user(&sc->sc_regs, regs, sizeof(sc->sc_regs));
+
+	return err;
+}
+
+static inline void __user *get_sigframe(struct ksignal *ksig,
+	struct pt_regs *regs, size_t framesize)
+{
+	unsigned long sp;
+	/* Default to using normal stack */
+	sp = regs->sp;
+
+	/*
+	 * If we are on the alternate signal stack and would overflow it, don't.
+	 * Return an always-bogus address instead so we will die with SIGSEGV.
+	 */
+	if (on_sig_stack(sp) && !likely(on_sig_stack(sp - framesize)))
+		return (void __user __force *)(-1UL);
+
+	/* This is the X/Open sanctioned signal stack switching. */
+	sp = sigsp(sp, ksig) - framesize;
+
+	/* Align the stack frame. */
+	sp &= ~0x3UL;
+
+	return (void __user *)sp;
+}
+
+
+static int setup_rt_frame(struct ksignal *ksig, sigset_t *set,
+	struct pt_regs *regs)
+{
+	struct rt_sigframe __user *frame;
+	size_t frame_size = sizeof(*frame);
+
+	frame = get_sigframe(ksig, regs, frame_size);
+	if (!access_ok(frame, frame_size))
+		return -EFAULT;
+
+	long err = copy_siginfo_to_user(&frame->info, &ksig->info);
+
+	/* Create the ucontext. */
+	err |= __put_user(0, &frame->uc.uc_flags);
+	err |= __put_user(NULL, &frame->uc.uc_link);
+	err |= __save_altstack(&frame->uc.uc_stack, regs->sp);
+	err |= setup_sigcontext(frame, regs);
+	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
+	if (err)
+		return -EFAULT;
+
+	/* Set up to return from userspace. */
+	/*
+	 * TODO: For now we don't have a vDSO. Instead we push two
+	 * instructions to call the rt_sigreturn syscall onto the user stack
+	 */
+	if (copy_to_user(&frame->sigreturn_code, __user_rt_sigreturn,
+		sizeof(frame->sigreturn_code)))
+		return -EFAULT;
+
+	unsigned long addr = (unsigned long)&frame->sigreturn_code;
+	/* Make sure the two instructions are pushed to icache. */
+	flush_icache_range(addr, addr + sizeof(frame->sigreturn_code));
+
+	regs->lr = addr;
+
+	/*
+	 * Set up registers for signal handler.
+	 * Registers that we don't modify keep the value they had from
+	 * user-space at the time we took the signal.
+	 * We always pass siginfo and mcontext, regardless of SA_SIGINFO,
+	 * since some things rely on this (e.g. glibc's debug/segfault.c).
+	 */
+	regs->pc = (unsigned long)ksig->ka.sa.sa_handler;
+	regs->sp = (unsigned long)frame;
+	regs->a0 = ksig->sig;                     /* a0: signal number */
+	regs->a1 = (unsigned long)(&frame->info); /* a1: siginfo pointer */
+	regs->a2 = (unsigned long)(&frame->uc);   /* a2: ucontext pointer */
+
+#if DEBUG_SIG
+	pr_info("SIG deliver (%s:%d): sig=%d pc=%p lr=%p sp=%p\n",
+		current->comm, task_pid_nr(current), ksig->sig,
+		(void *)regs->pc, (void *)regs->lr, frame);
+#endif
+
+	return 0;
+}
+
+static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
+{
+	sigset_t *oldset = sigmask_to_save();
+	int ret;
+
+	rseq_signal_deliver(ksig, regs);
+
+	/* Set up the stack frame */
+	ret = setup_rt_frame(ksig, oldset, regs);
+
+	signal_setup_done(ret, ksig, 0);
+}
+
+
+void arch_do_signal_or_restart(struct pt_regs *regs)
+{
+	unsigned long continue_addr = 0, restart_addr = 0;
+	int retval = 0;
+	struct ksignal ksig;
+	bool syscall = (regs->rs & RS_ECAUSE) == RS_ECAUSE_SYS;
+
+	/* If we were from a system call, check for system call restarting */
+	if (syscall) {
+		continue_addr = regs->pc;
+		restart_addr = continue_addr - 4;
+		retval = regs->a3;
+
+		/* Avoid additional syscall restarting via ret_from_exception */
+		regs->rs &= ~RS_ECAUSE;
+
+		/*
+		 * Prepare for system call restart. We do this here so that a
+		 * debugger will see the already changed PC.
+		 */
+		switch (retval) {
+		case -ERESTARTNOHAND:
+		case -ERESTARTSYS:
+		case -ERESTARTNOINTR:
+		case -ERESTART_RESTARTBLOCK:
+			regs->a3 = regs->orig_a3;
+			regs->pc = restart_addr;
+			break;
+		}
+	}
+
+	/*
+	 * Get the signal to deliver. When running under ptrace, at this point
+	 * the debugger may change all of our registers.
+	 */
+	if (get_signal(&ksig)) {
+		/*
+		 * Depending on the signal settings, we may need to revert the
+		 * decision to restart the system call, but skip this if a
+		 * debugger has chosen to restart at a different PC.
+		 */
+		if (regs->pc == restart_addr &&
+		    (retval == -ERESTARTNOHAND ||
+		     retval == -ERESTART_RESTARTBLOCK ||
+		     (retval == -ERESTARTSYS &&
+		      !(ksig.ka.sa.sa_flags & SA_RESTART)))) {
+			regs->a3 = -EINTR;
+			regs->pc = continue_addr;
+		}
+
+		/* Actually deliver the signal */
+		handle_signal(&ksig, regs);
+		return;
+	}
+
+	/*
+	 * Handle restarting a different system call. As above, if a debugger
+	 * has chosen to restart at a different PC, ignore the restart.
+	 */
+	if (syscall && regs->pc == restart_addr && retval == -ERESTART_RESTARTBLOCK)
+		regs->t5 = __NR_restart_syscall;
+
+	/*
+	 * If there is no signal to deliver, we just put the saved
+	 * sigmask back.
+	 */
+	restore_saved_sigmask();
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/stubs.c linux-workdir/arch/xr17032/kernel/stubs.c
--- linux-clean/arch/xr17032/kernel/stubs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/stubs.c
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/mmu_context.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/tlbflush.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/panic.h>
+#include <linux/ptrace.h>
+#include <linux/reboot.h>
+#include <linux/sched.h>
+#include <linux/sched/debug.h>
+#include <linux/seq_file.h>
+
+const struct seq_operations cpuinfo_op;
+
+long arch_ptrace(struct task_struct *child, long request,
+		 unsigned long addr, unsigned long data)
+{
+	panic("TODO arch_ptrace");
+}
+
+unsigned long __get_wchan(struct task_struct *task)
+{
+	panic("TODO __get_wchan");
+}
+
+void machine_halt(void)
+{
+	panic("TODO machine_halt");
+}
+
+void machine_power_off(void)
+{
+	panic("TODO machine_power_off");
+}
+
+void machine_restart(char *cmd)
+{
+	panic("TODO machine_restart");
+}
+
+void ptrace_disable(struct task_struct *child)
+{
+	panic("TODO ptrace_disable");
+}
+
+void show_stack(struct task_struct *task, unsigned long *sp, const char *loglvl)
+{
+	pr_cont("TODO show_stack\n");
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/sys_xr17032.c linux-workdir/arch/xr17032/kernel/sys_xr17032.c
--- linux-clean/arch/xr17032/kernel/sys_xr17032.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/sys_xr17032.c
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/syscalls.h>
+
+static long xr17032_sys_mmap(unsigned long addr, unsigned long len,
+			     unsigned long prot, unsigned long flags,
+			     unsigned long fd, off_t offset,
+			     unsigned long page_shift_offset)
+{
+	if (unlikely(offset & (~PAGE_MASK >> page_shift_offset)))
+		return -EINVAL;
+
+	return ksys_mmap_pgoff(addr, len, prot, flags, fd,
+			       offset >> (PAGE_SHIFT - page_shift_offset));
+}
+
+SYSCALL_DEFINE6(mmap2, unsigned long, addr, unsigned long, len,
+		unsigned long, prot, unsigned long, flags,
+		unsigned long, fd, unsigned long, offset)
+{
+	/*
+	 * Note that the shift for mmap2 is constant (12),
+	 * regardless of PAGE_SIZE
+	 */
+	return xr17032_sys_mmap(addr, len, prot, flags, fd, offset, 12);
+}
+
+asmlinkage long __xr17032_sys_ni_syscall(const struct pt_regs *__unused)
+{
+	return -ENOSYS;
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/syscall_table.c linux-workdir/arch/xr17032/kernel/syscall_table.c
--- linux-clean/arch/xr17032/kernel/syscall_table.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/syscall_table.c
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/syscall.h>
+#include <asm-generic/syscalls.h>
+#include <linux/linkage.h>
+#include <linux/syscalls.h>
+
+#define __SYSCALL_WITH_COMPAT(nr, native, compat) __SYSCALL(nr, native)
+
+#undef __SYSCALL
+#define __SYSCALL(nr, call)	asmlinkage long __xr17032_##call(const struct pt_regs *);
+#include <asm/syscall_table_32.h>
+
+#undef __SYSCALL
+#define __SYSCALL(nr, call)	[nr] = __xr17032_##call,
+
+void * const sys_call_table[__NR_syscalls] = {
+	[0 ... __NR_syscalls - 1] = __xr17032_sys_ni_syscall,
+#include <asm/syscall_table_32.h>
+};
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/time.c linux-workdir/arch/xr17032/kernel/time.c
--- linux-clean/arch/xr17032/kernel/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/time.c
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/clocksource.h>
+#include <linux/init.h>
+#include <linux/of_clk.h>
+
+void __init time_init(void)
+{
+	of_clk_init(NULL);
+	timer_probe();
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/vmlinux.lds.S linux-workdir/arch/xr17032/kernel/vmlinux.lds.S
--- linux-clean/arch/xr17032/kernel/vmlinux.lds.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/vmlinux.lds.S
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/pgtable.h>
+#define LOAD_OFFSET KERNEL_LINK_ADDR
+
+#include <asm/vmlinux.lds.h>
+#include <asm/page.h>
+#include <asm/cache.h>
+#include <asm/thread_info.h>
+#include <asm/set_memory.h>
+
+#include <linux/sizes.h>
+
+OUTPUT_ARCH(xr17032)
+ENTRY(_start)
+
+jiffies = jiffies_64;
+
+SECTIONS
+{
+	. = LOAD_OFFSET;
+	HEAD_TEXT_SECTION
+	. = ALIGN(PAGE_SIZE);
+
+	.text : {
+		_text = .;
+		_stext = .;
+		TEXT_TEXT
+		SCHED_TEXT
+		LOCK_TEXT
+		KPROBES_TEXT
+		ENTRY_TEXT
+		IRQENTRY_TEXT
+		SOFTIRQENTRY_TEXT
+		_etext = .;
+	}
+
+	. = ALIGN(SECTION_ALIGN);
+	__init_begin = .;
+	__init_text_begin = .;
+	.init.text : AT(ADDR(.init.text) - LOAD_OFFSET) ALIGN(SECTION_ALIGN) { \
+		_sinittext = .;						\
+		INIT_TEXT						\
+		_einittext = .;						\
+	}
+
+	/* we have to discard exit text and such at runtime, not link time */
+	__exittext_begin = .;
+	.exit.text :
+	{
+		EXIT_TEXT
+	}
+	__exittext_end = .;
+
+	__init_text_end = .;
+	. = ALIGN(SECTION_ALIGN);
+	/* Start of init data section */
+	__init_data_begin = .;
+	INIT_DATA_SECTION(16)
+
+	.init.pi : {
+		KEEP(*(.init.pi*))
+	}
+
+	.init.bss : {
+		KEEP(*(.init.bss*))
+	}
+	.exit.data :
+	{
+		EXIT_DATA
+	}
+
+	RUNTIME_CONST_VARIABLES
+
+	PERCPU_SECTION(L1_CACHE_BYTES)
+
+	.rel.dyn : {
+		*(.rel.dyn*)
+	}
+
+	.rela.dyn : ALIGN(8) {
+		__rela_dyn_start = .;
+		*(.rela .rela*)
+		__rela_dyn_end = .;
+	}
+
+	__init_data_end = .;
+
+	. = ALIGN(8);
+	.alternative : {
+		__alt_start = .;
+		KEEP(*(.alternative))
+		__alt_end = .;
+	}
+	__init_end = .;
+
+	/* Start of data section */
+	_sdata = .;
+	RO_DATA(SECTION_ALIGN)
+	.srodata : {
+		*(.srodata*)
+	}
+
+	. = ALIGN(SECTION_ALIGN);
+	_data = .;
+
+	RW_DATA(L1_CACHE_BYTES, PAGE_SIZE, THREAD_ALIGN)
+
+	.got : { *(.got*) }
+
+#ifdef CONFIG_RELOCATABLE
+	.data.rel : { *(.data.rel*) }
+	.plt : { *(.plt) }
+	.dynamic : { *(.dynamic) }
+	.dynsym : { *(.dynsym) }
+	.dynstr : { *(.dynstr) }
+	.hash : { *(.hash) }
+	.gnu.hash : { *(.gnu.hash) }
+#endif
+
+	/* End of data section */
+	_edata = .;
+
+	BSS_SECTION(PAGE_SIZE, PAGE_SIZE, 0)
+
+	_end = .;
+
+	STABS_DEBUG
+	DWARF_DEBUG
+	ELF_DETAILS
+
+	DISCARDS
+}
diff -urN --no-dereference linux-clean/arch/xr17032/lib/Makefile linux-workdir/arch/xr17032/lib/Makefile
--- linux-clean/arch/xr17032/lib/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-only
+lib-y	+= delay.o
+lib-y	+= memcpy.o
+lib-y	+= memset.o
+lib-y	+= uaccess.o
diff -urN --no-dereference linux-clean/arch/xr17032/lib/delay.c linux-workdir/arch/xr17032/lib/delay.c
--- linux-clean/arch/xr17032/lib/delay.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/delay.c
@@ -0,0 +1,28 @@
+#include <linux/compiler.h>
+#include <linux/delay.h>
+
+noinline void __delay(unsigned long loops)
+{
+	asm volatile(
+		"	beq %0, 2f\n"
+		"	beq zero, 1f\n"
+		".balign 16\n"
+		"1:	subi %0, %0, 1\n"
+		"	bne %0, 1b\n"
+		"2:"
+		: "+r" (loops)
+	);
+}
+
+void __const_udelay(unsigned long xloops)
+{
+	xloops *= 4;
+	xloops = ((uint64_t)xloops * (loops_per_jiffy * (HZ / 4))) >> 32;
+
+	__delay(++xloops);
+}
+
+void __udelay(unsigned long loops)
+{
+	__const_udelay(loops * UDELAY_CONST_MULT);
+}
diff -urN --no-dereference linux-clean/arch/xr17032/lib/memcpy.S linux-workdir/arch/xr17032/lib/memcpy.S
--- linux-clean/arch/xr17032/lib/memcpy.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/memcpy.S
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/linkage.h>
+
+/* void *memcpy(void *, const void *, size_t) */
+SYM_FUNC_START(__memcpy)
+	add t5, a0, zero  /* Preserve return value */
+
+	/* Defer to byte-oriented copy for small sizes */
+	slti a3, a2, 128
+	bne a3, 4f
+	/* Use word-oriented copy only if low-order bits match */
+	andi a3, a0, 3
+	andi t0, a1, 3
+	sub t0, t0, a3
+	bne t0, 4f
+
+	beq a3, 2f  /* Skip if already aligned */
+	/*
+	 * Round to nearest double word-aligned address
+	 * greater than or equal to start address
+	 */
+	sub a3, a1, a3
+	addi a3, a3, 4
+	/* Handle initial misalignment */
+	sub t0, a3, a1
+1:
+	mov t1, byte[a1]
+	addi a1, a1, 1
+	mov byte [t5], t1
+	addi t5, t5, 1
+	slt t1, a1, a3
+	bne t1, 1b
+	sub a2, a2, t0  /* Update count */
+
+2:
+	andi t0, a2, 0x3f
+	sub t0, a2, t0
+	beq t0, 4f
+	add a3, a1, t0
+3:
+	mov t0, long [a1 + 0x00]
+	mov t1, long [a1 + 0x04]
+	mov t2, long [a1 + 0x08]
+	mov t3, long [a1 + 0x0c]
+	mov t4, long [a1 + 0x10]
+	mov long [t5 + 0x00], t0
+	mov long [t5 + 0x04], t1
+	mov long [t5 + 0x08], t2
+	mov long [t5 + 0x0c], t3
+	mov long [t5 + 0x10], t4
+	mov t0, long [a1 + 0x14]
+	mov t1, long [a1 + 0x18]
+	mov t2, long [a1 + 0x1c]
+	mov t3, long [a1 + 0x20]
+	mov t4, long [a1 + 0x24]
+	mov long [t5 + 0x14], t0
+	mov long [t5 + 0x18], t1
+	mov long [t5 + 0x1c], t2
+	mov long [t5 + 0x20], t3
+	mov long [t5 + 0x24], t4
+	mov t0, long [a1 + 0x28]
+	mov t1, long [a1 + 0x2c]
+	mov t2, long [a1 + 0x30]
+	mov t3, long [a1 + 0x34]
+	mov t4, long [a1 + 0x38]
+	mov long [t5 + 0x28], t0
+	mov long [t5 + 0x2c], t1
+	mov long [t5 + 0x30], t2
+	mov long [t5 + 0x34], t3
+	mov long [t5 + 0x38], t4
+	mov t0, long [a1 + 0x3c]
+	addi a1, a1, 0x40
+	mov long [t5 + 0x3c], t0
+	addi t5, t5, 0x40
+	slt t0, a1, a3
+	bne t0, 3b
+	andi a2, a2, 0x3f  /* Update count */
+
+4:
+	/* Handle trailing misalignment */
+	beq a2, 6f
+	add a3, a1, a2
+
+	/* Use short-oriented copy if co-aligned to short boundary */
+	or t1, a1, t5
+	or t1, t1, a3
+	bpo t1, 5f
+7:
+	mov t0, int [a1]
+	addi a1, a1, 2
+	mov int [t5], t0
+	addi t5, t5, 2
+	slt t0, a1, a3
+	bne t0, 7b
+
+	add a3, a0, zero
+	jalr zero, lr, 0
+
+5:
+	mov t0, byte [a1]
+	addi a1, a1, 1
+	mov byte [t5], t0
+	addi t5, t5, 1
+	slt t0, a1, a3
+	bne t0, 5b
+6:
+	add a3, a0, zero
+	jalr zero, lr, 0
+SYM_FUNC_END(__memcpy)
+SYM_FUNC_ALIAS_WEAK(memcpy, __memcpy)
+SYM_FUNC_ALIAS(__pi_memcpy, __memcpy)
+SYM_FUNC_ALIAS(__pi___memcpy, __memcpy)
diff -urN --no-dereference linux-clean/arch/xr17032/lib/memset.S linux-workdir/arch/xr17032/lib/memset.S
--- linux-clean/arch/xr17032/lib/memset.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/memset.S
@@ -0,0 +1,113 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/linkage.h>
+
+/* void *memset(void *, int, size_t) */
+SYM_FUNC_START(__memset)
+	add t0, a0, zero  /* Preserve return value */
+
+	/* Defer to byte-oriented fill for small sizes */
+	slti a3, a2, 16
+	bne a3, 4f
+
+	/*
+	 * Round to nearest word-aligned address
+	 * greater than or equal to start address
+	 */
+	subi t1, zero, 4
+	addi a3, a0, 3
+	and a3, a3, t1
+	sub t1, a3, t0
+	beq t1, 2f  /* Skip if already aligned */
+	/* Handle initial misalignment */
+	sub t1, a3, t0
+1:
+	mov byte [t0], a1
+	addi t0, t0, 1
+	slt t2, t0, a3
+	bne t2, 1b
+	sub a2, a2, t1  /* Update count */
+
+2: /* Duff's device with 32 word stores per iteration */
+	/* Broadcast value into all bytes */
+	andi a1, a1, 0xff
+	add a3, zero, a1 LSH 8
+	or a1, a3, a1
+	add a3, zero, a1 LSH 16
+	or a1, a3, a1
+
+	/* Calculate end address */
+	subi t1, zero, 4
+	and t1, a2, t1
+	add a3, t0, t1
+
+	andi t1, t1, 127  /* Calculate remainder */
+	beq t1, 3f        /* Shortcut if no remainder */
+	sub t1, zero, t1
+	addi t1, t1, 128  /* Calculate initial offset */
+
+	/* Adjust start address with offset */
+	sub t0, t0, t1
+
+	/* Jump into loop body */
+1:	adr t2, %pcrel_hi(3f)
+	addi t2, t2, %pcrel_lo(1b)
+	add t2, t2, t1
+	jalr zero, t2, 0
+3:
+	mov long [t0 + 0x00], a1
+	mov long [t0 + 0x04], a1
+	mov long [t0 + 0x08], a1
+	mov long [t0 + 0x0c], a1
+	mov long [t0 + 0x10], a1
+	mov long [t0 + 0x14], a1
+	mov long [t0 + 0x18], a1
+	mov long [t0 + 0x1c], a1
+	mov long [t0 + 0x20], a1
+	mov long [t0 + 0x24], a1
+	mov long [t0 + 0x28], a1
+	mov long [t0 + 0x2c], a1
+	mov long [t0 + 0x30], a1
+	mov long [t0 + 0x34], a1
+	mov long [t0 + 0x38], a1
+	mov long [t0 + 0x3c], a1
+	mov long [t0 + 0x40], a1
+	mov long [t0 + 0x44], a1
+	mov long [t0 + 0x48], a1
+	mov long [t0 + 0x4c], a1
+	mov long [t0 + 0x50], a1
+	mov long [t0 + 0x54], a1
+	mov long [t0 + 0x58], a1
+	mov long [t0 + 0x5c], a1
+	mov long [t0 + 0x60], a1
+	mov long [t0 + 0x64], a1
+	mov long [t0 + 0x68], a1
+	mov long [t0 + 0x6c], a1
+	mov long [t0 + 0x70], a1
+	mov long [t0 + 0x74], a1
+	mov long [t0 + 0x78], a1
+	mov long [t0 + 0x7c], a1
+	addi t0, t0, 128
+	slt t1, t0, a3
+	bne t1, 3b
+	andi a2, a2, 3  /* Update count */
+
+4:
+	/* Handle trailing misalignment */
+	beq a2, 6f
+	add a3, t0, a2
+5:
+	mov byte [t0], a1
+	addi t0, t0, 1
+	slt t1, t0, a3
+	bne t1, 5b
+6:
+	add a3, a0, zero
+	jalr zero, lr, 0
+SYM_FUNC_END(__memset)
+SYM_FUNC_ALIAS_WEAK(memset, __memset)
+SYM_FUNC_ALIAS(__pi_memset, __memset)
+SYM_FUNC_ALIAS(__pi___memset, __memset)
diff -urN --no-dereference linux-clean/arch/xr17032/lib/uaccess.S linux-workdir/arch/xr17032/lib/uaccess.S
--- linux-clean/arch/xr17032/lib/uaccess.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/uaccess.S
@@ -0,0 +1,79 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/asm-extable.h>
+#include <linux/linkage.h>
+
+.macro fixup dst, src, lbl
+100:	mov \dst, \src
+	_asm_extable 100b, \lbl
+.endm
+
+SYM_FUNC_START(__asm_copy_to_user)
+	add	t5, a0, a2
+
+	beq	a2, .Lout_copy_user
+1:	fixup	t0, byte [a1], .Lcopy_user_fail
+	addi	a1, a1, 1
+	fixup	byte [a0], t0, .Lcopy_user_fail
+	addi	a0, a0, 1
+	subi	a2, a2, 1
+	bne	a2, 1b
+
+.Lout_copy_user:
+	addi	a3, zero, 0
+	jalr	zero, lr, 0
+
+.Lcopy_user_fail:
+	sub	a3, t5, a0
+	jalr	zero, lr, 0
+SYM_FUNC_END(__asm_copy_to_user)
+SYM_FUNC_ALIAS(__asm_copy_from_user, __asm_copy_to_user)
+
+SYM_FUNC_START(__clear_user)
+	subi t2, zero, 4
+
+	add a3, a0, a1
+	addi t0, a0, 3
+	and t1, a3, t2
+	and t0, t0, t2
+	/*
+	 * a3: terminal address of target region
+	 * t0: lowest word-aligned address in target region
+	 * t1: highest word-aligned address in target region
+	 */
+	slt t2, t0, t1
+	beq t2, 2f
+	slt t2, a0, t0
+	bne t2, 4f
+
+1:	fixup long [a0], zero, 11f
+	addi a0, a0, 4
+	slt t2, a0, t1
+	bne t2, 1b
+
+2:	slt t2, a0, a3
+	bne t2, 5f
+
+3:	addi a3, zero, 0
+	jalr zero, lr, 0
+
+4:	/* Edge case: not aligned */
+	fixup byte [a0], zero, 11f
+	addi a0, a0, 1
+	slt t2, a0, t0
+	bne t2, 4b
+	beq zero, 1b
+5:	/* Edge case: remainder */
+	fixup byte [a0], zero, 11f
+	addi a0, a0, 1
+	slt t2, a0, t3
+	bne t2, 5b
+	beq zero, 3b
+
+11:	/* Exception fixup code */
+	sub a3, a3, a0
+	jalr zero, lr, 0
+SYM_FUNC_END(__clear_user)
diff -urN --no-dereference linux-clean/arch/xr17032/mm/Makefile linux-workdir/arch/xr17032/mm/Makefile
--- linux-clean/arch/xr17032/mm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+obj-y	+= cacheflush.o
+obj-y	+= dma.o
+obj-y	+= extable.o
+obj-y	+= fault.o
+obj-y	+= init.o
+obj-y	+= tlbflush.o
diff -urN --no-dereference linux-clean/arch/xr17032/mm/cacheflush.c linux-workdir/arch/xr17032/mm/cacheflush.c
--- linux-clean/arch/xr17032/mm/cacheflush.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/cacheflush.c
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/cacheflush.h>
+#include <asm/page.h>
+
+#define ICACHE_FLUSH_ALL_THRESHOLD 64
+
+void local_flush_icache_range(unsigned long start, unsigned long end)
+{
+	unsigned long nr_ptes_in_range = DIV_ROUND_UP(end - start, PAGE_SIZE);
+
+	if (nr_ptes_in_range > ICACHE_FLUSH_ALL_THRESHOLD) {
+		local_flush_icache_all();
+		return;
+	}
+
+	for (unsigned long i = 0; i < nr_ptes_in_range; i++) {
+		local_flush_icache_page(start);
+		start += PAGE_SIZE;
+	}
+}
diff -urN --no-dereference linux-clean/arch/xr17032/mm/dma.c linux-workdir/arch/xr17032/mm/dma.c
--- linux-clean/arch/xr17032/mm/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/dma.c
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/cr.h>
+#include <asm/page.h>
+#include <linux/dma-map-ops.h>
+
+static inline void arch_dma_cache_inv(phys_addr_t paddr, size_t size)
+{
+	paddr &= PAGE_MASK;
+	size_t nr_ptes_in_range = DIV_ROUND_UP(size, PAGE_SIZE);
+
+	for (size_t i = 0; i < nr_ptes_in_range; i++) {
+		cr_write(dcachectrl, paddr | 2);
+		paddr += PAGE_SIZE;
+	}
+}
+
+void arch_setup_dma_ops(struct device *dev, bool coherent)
+{
+	dev->dma_coherent = coherent;
+}
+
+void arch_sync_dma_for_cpu(phys_addr_t paddr, size_t size,
+			   enum dma_data_direction dir)
+{
+	switch (dir) {
+	case DMA_TO_DEVICE:
+		break;
+	case DMA_FROM_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		arch_dma_cache_inv(paddr, size);
+		break;
+	default:
+		break;
+	}
+}
diff -urN --no-dereference linux-clean/arch/xr17032/mm/extable.c linux-workdir/arch/xr17032/mm/extable.c
--- linux-clean/arch/xr17032/mm/extable.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/extable.c
@@ -0,0 +1,66 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/asm-extable.h>
+#include <asm/bug.h>
+#include <asm/errno.h>
+#include <asm/extable.h>
+#include <asm/ptrace.h>
+#include <linux/bitfield.h>
+#include <linux/extable.h>
+
+static inline unsigned long
+get_ex_fixup(const struct exception_table_entry *ex)
+{
+	return ex->fixup;
+}
+
+static bool ex_handler_fixup(const struct exception_table_entry *ex,
+			     struct pt_regs *regs)
+{
+	regs->pc = get_ex_fixup(ex);
+	return true;
+}
+
+static inline void regs_set_gpr(struct pt_regs *regs, unsigned int offset,
+				unsigned long val)
+{
+	if (unlikely(offset > MAX_REG_OFFSET))
+		return;
+
+	if (offset)
+		*(unsigned long *)((unsigned long)regs + offset) = val;
+}
+
+static bool ex_handler_uaccess_err_zero(const struct exception_table_entry *ex,
+					struct pt_regs *regs)
+{
+	int reg_err = FIELD_GET(EX_DATA_REG_ERR, ex->data);
+	int reg_zero = FIELD_GET(EX_DATA_REG_ZERO, ex->data);
+
+	regs_set_gpr(regs, reg_err * sizeof(unsigned long), -EFAULT);
+	regs_set_gpr(regs, reg_zero * sizeof(unsigned long), 0);
+
+	regs->pc = get_ex_fixup(ex);
+	return true;
+}
+
+bool fixup_exception(struct pt_regs *regs)
+{
+	const struct exception_table_entry *ex;
+
+	ex = search_exception_tables(regs->pc);
+	if (!ex)
+		return false;
+
+	switch (ex->type) {
+	case EX_TYPE_FIXUP:
+		return ex_handler_fixup(ex, regs);
+	case EX_TYPE_UACCESS_ERR_ZERO:
+		return ex_handler_uaccess_err_zero(ex, regs);
+	}
+
+	BUG();
+}
diff -urN --no-dereference linux-clean/arch/xr17032/mm/fault.c linux-workdir/arch/xr17032/mm/fault.c
--- linux-clean/arch/xr17032/mm/fault.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/fault.c
@@ -0,0 +1,374 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/cr.h>
+#include <asm/extable.h>
+#include <asm/pgtable.h>
+#include <asm/siginfo.h>
+#include <linux/entry-common.h>
+#include <linux/kernel.h>
+#include <linux/kfence.h>
+#include <linux/kprobes.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+
+static void show_pte(unsigned long addr)
+{
+	pgd_t *pgdp, pgd;
+	p4d_t *p4dp, p4d;
+	pud_t *pudp, pud;
+	pmd_t *pmdp, pmd;
+	pte_t *ptep, pte;
+	struct mm_struct *mm = current->mm;
+
+	if (!mm)
+		mm = &init_mm;
+
+	pr_alert("Current %s pgtable: %luK pagesize, pgdp=0x%08lx\n",
+		 current->comm, PAGE_SIZE / SZ_1K, virt_to_phys(mm->pgd));
+
+	pgdp = pgd_offset(mm, addr);
+	pgd = pgdp_get(pgdp);
+	pr_alert("[%016lx] pgd=%016lx", addr, pgd_val(pgd));
+	if (pgd_none(pgd) || pgd_bad(pgd) || pgd_leaf(pgd))
+		goto out;
+
+	p4dp = p4d_offset(pgdp, addr);
+	p4d = p4dp_get(p4dp);
+	pr_cont(", p4d=%016lx", p4d_val(p4d));
+	if (p4d_none(p4d) || p4d_bad(p4d) || p4d_leaf(p4d))
+		goto out;
+
+	pudp = pud_offset(p4dp, addr);
+	pud = pudp_get(pudp);
+	pr_cont(", pud=%016lx", pud_val(pud));
+	if (pud_none(pud) || pud_bad(pud) || pud_leaf(pud))
+		goto out;
+
+	pmdp = pmd_offset(pudp, addr);
+	pmd = pmdp_get(pmdp);
+	pr_cont(", pmd=%016lx", pmd_val(pmd));
+	if (pmd_none(pmd) || pmd_bad(pmd) || pmd_leaf(pmd))
+		goto out;
+
+	ptep = pte_offset_map(pmdp, addr);
+	if (!ptep)
+		goto out;
+
+	pte = ptep_get(ptep);
+	pr_cont(", pte=%016lx", pte_val(pte));
+	pte_unmap(ptep);
+out:
+	pr_cont("\n");
+}
+
+static void die_kernel_fault(const char *msg, unsigned long addr,
+			     struct pt_regs *regs)
+{
+	bust_spinlocks(1);
+
+	pr_alert("Unable to handle kernel %s at virtual address 0x%08lx\n", msg,
+		 addr);
+
+	bust_spinlocks(0);
+	show_pte(addr);
+	die(regs, "Oops");
+	make_task_dead(SIGKILL);
+}
+
+static inline void no_context(struct pt_regs *regs, unsigned long addr)
+{
+	const char *msg;
+
+	/* Are we prepared to handle this kernel fault? */
+	if (fixup_exception(regs))
+		return;
+
+	/*
+	 * Oops. The kernel tried to access some bad page. We'll have to
+	 * terminate things with extreme prejudice.
+	 */
+	if (addr < PAGE_SIZE)
+		msg = "NULL pointer dereference";
+	else {
+		if (kfence_handle_page_fault(addr, (regs->rs & RS_ECAUSE)
+						   == RS_ECAUSE_PF_W, regs))
+			return;
+
+		msg = "paging request";
+	}
+
+	die_kernel_fault(msg, addr, regs);
+}
+
+
+static inline void mm_fault_error(struct pt_regs *regs, unsigned long addr, vm_fault_t fault)
+{
+	if (!user_mode(regs)) {
+		no_context(regs, addr);
+		return;
+	}
+
+	if (fault & VM_FAULT_OOM) {
+		/*
+		 * We ran out of memory, call the OOM killer, and return the userspace
+		 * (which will retry the fault, or kill us if we got oom-killed).
+		 */
+		pagefault_out_of_memory();
+		return;
+	} else if (fault & (VM_FAULT_SIGBUS | VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE)) {
+		/* Kernel mode? Handle exceptions or die */
+		do_trap(regs, SIGBUS, BUS_ADRERR, addr);
+		return;
+	} else if (fault & VM_FAULT_SIGSEGV) {
+		do_trap(regs, SIGSEGV, SEGV_MAPERR, addr);
+		return;
+	}
+
+	BUG();
+}
+
+static inline void
+bad_area_nosemaphore(struct pt_regs *regs, int code, unsigned long addr)
+{
+	/*
+	 * Something tried to access memory that isn't in our memory map.
+	 * Fix it, but check if it's kernel or user first.
+	 */
+	/* User mode accesses just cause a SIGSEGV */
+	if (user_mode(regs)) {
+		do_trap(regs, SIGSEGV, code, addr);
+		return;
+	}
+
+	no_context(regs, addr);
+}
+
+static inline void
+bad_area(struct pt_regs *regs, struct mm_struct *mm, int code,
+	 unsigned long addr)
+{
+	mmap_read_unlock(mm);
+
+	bad_area_nosemaphore(regs, code, addr);
+}
+
+static inline void vmalloc_fault(struct pt_regs *regs, int code,
+				 unsigned long addr)
+{
+	/* User mode accesses just cause a SIGSEGV */
+	if (user_mode(regs))
+		return do_trap(regs, SIGSEGV, code, addr);
+
+	/*
+	 * Synchronize this task's top level page-table
+	 * with the 'reference' page table.
+	 *
+	 * Do _not_ use "tsk->active_mm->pgd" here.
+	 * We might be inside an interrupt in the middle
+	 * of a task switch.
+	 */
+	int index = pgd_index(addr);
+	unsigned long pfn = cr_read(scratch3);
+	pgd_t *pgd = (pgd_t *)pfn_to_virt(pfn) + index;
+	pgd_t *pgd_k = init_mm.pgd + index;
+
+	if (!pgd_present(pgdp_get(pgd_k))) {
+		no_context(regs, addr);
+		return;
+	}
+	set_pgd(pgd, pgdp_get(pgd_k));
+
+	p4d_t *p4d_k = p4d_offset(pgd_k, addr);
+	if (!p4d_present(p4dp_get(p4d_k))) {
+		no_context(regs, addr);
+		return;
+	}
+
+	pud_t *pud_k = pud_offset(p4d_k, addr);
+	if (!pud_present(pudp_get(pud_k))) {
+		no_context(regs, addr);
+		return;
+	}
+	if (pud_leaf(pudp_get(pud_k)))
+		goto flush_tlb;
+
+	/*
+	 * Since the vmalloc area is global, it is unnecessary
+	 * to copy individual PTEs
+	 */
+	pmd_t *pmd_k = pmd_offset(pud_k, addr);
+	if (!pmd_present(pmdp_get(pmd_k))) {
+		no_context(regs, addr);
+		return;
+	}
+	if (pmd_leaf(pmdp_get(pmd_k)))
+		goto flush_tlb;
+
+	/*
+	 * Make sure the actual PTE exists as well to
+	 * catch kernel vmalloc-area accesses to non-mapped
+	 * addresses. If we don't do this, this will just
+	 * silently loop forever.
+	 */
+	pte_t *pte_k = pte_offset_kernel(pmd_k, addr);
+	if (!pte_present(ptep_get(pte_k))) {
+		no_context(regs, addr);
+		return;
+	}
+
+flush_tlb:
+	local_flush_tlb_page(addr);
+}
+
+static inline bool access_error(unsigned long cause, struct vm_area_struct *vma)
+{
+	switch (cause) {
+	case 0xc:
+		/* Write implies read */
+		if (!(vma->vm_flags & (VM_READ | VM_WRITE))) {
+			return true;
+		}
+		break;
+	case 0xd:
+		if (!(vma->vm_flags & VM_WRITE)) {
+			return true;
+		}
+		break;
+	default:
+		panic("%s: unhandled cause %lu", __func__, cause);
+	}
+	return false;
+}
+
+void handle_page_fault(struct pt_regs *regs)
+{
+	unsigned long addr = cr_read(ebadaddr);
+	unsigned long cause = regs->rs >> 28;
+
+	if (kprobe_page_fault(regs, cause))
+		return;
+
+	int code = SEGV_MAPERR;
+
+	if (unlikely(addr >= VMALLOC_START && addr <= VMALLOC_END)) {
+		vmalloc_fault(regs, code, addr);
+		return;
+	}
+
+	if (!regs_irqs_disabled(regs))
+		local_irq_enable();
+
+	struct task_struct *tsk = current;
+	struct mm_struct *mm = tsk->mm;
+
+	if (unlikely(faulthandler_disabled() || !mm)) {
+		no_context(regs, addr);
+		return;
+	}
+
+	unsigned int flags = FAULT_FLAG_DEFAULT;
+
+	if (user_mode(regs))
+		flags |= FAULT_FLAG_USER;
+
+	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, addr);
+
+	if (cause == 0xd)
+		flags |= FAULT_FLAG_WRITE;
+	if (!(flags & FAULT_FLAG_USER))
+		goto lock_mmap;
+
+	struct vm_area_struct *vma = lock_vma_under_rcu(mm, addr);
+	if (!vma)
+		goto lock_mmap;
+
+	if (unlikely(access_error(cause, vma))) {
+		vma_end_read(vma);
+		count_vm_vma_lock_event(VMA_LOCK_SUCCESS);
+		bad_area_nosemaphore(regs, SEGV_ACCERR, addr);
+		return;
+	}
+
+	vm_fault_t fault = handle_mm_fault(vma, addr,
+					   flags | FAULT_FLAG_VMA_LOCK, regs);
+	if (!(fault & (VM_FAULT_RETRY | VM_FAULT_COMPLETED)))
+		vma_end_read(vma);
+
+	if (!(fault & VM_FAULT_RETRY)) {
+		count_vm_vma_lock_event(VMA_LOCK_SUCCESS);
+		goto done;
+	}
+	count_vm_vma_lock_event(VMA_LOCK_RETRY);
+	if (fault & VM_FAULT_MAJOR)
+		flags |= FAULT_FLAG_TRIED;
+
+	if (fault_signal_pending(fault, regs)) {
+		if (!user_mode(regs))
+			no_context(regs, addr);
+		return;
+	}
+lock_mmap:
+
+retry:
+	vma = lock_mm_and_find_vma(mm, addr, regs);
+	if (unlikely(!vma)) {
+		bad_area_nosemaphore(regs, code, addr);
+		return;
+	}
+
+	/*
+	 * Ok, we have a good vm_area for this memory access, so
+	 * we can handle it.
+	 */
+	code = SEGV_ACCERR;
+
+	if (unlikely(access_error(cause, vma))) {
+		bad_area(regs, mm, code, addr);
+		return;
+	}
+
+	/*
+	 * If for any reason at all we could not handle the fault,
+	 * make sure we exit gracefully rather than endlessly redo
+	 * the fault.
+	 */
+	fault = handle_mm_fault(vma, addr, flags, regs);
+
+	/*
+	 * If we need to retry but a fatal signal is pending, handle the
+	 * signal first. We do not need to release the mmap_lock because it
+	 * would already be released in __lock_page_or_retry in mm/filemap.c.
+	 */
+	if (fault_signal_pending(fault, regs)) {
+		if (!user_mode(regs))
+			no_context(regs, addr);
+		return;
+	}
+
+	/* The fault is fully completed (including releasing mmap lock) */
+	if (fault & VM_FAULT_COMPLETED)
+		return;
+
+	if (unlikely(fault & VM_FAULT_RETRY)) {
+		flags |= FAULT_FLAG_TRIED;
+
+		/*
+		 * No need to mmap_read_unlock(mm) as we would
+		 * have already released it in __lock_page_or_retry
+		 * in mm/filemap.c.
+		 */
+		goto retry;
+	}
+
+	mmap_read_unlock(mm);
+
+done:
+	if (unlikely(fault & VM_FAULT_ERROR)) {
+		mm_fault_error(regs, addr, fault);
+		return;
+	}
+	return;
+}
diff -urN --no-dereference linux-clean/arch/xr17032/mm/init.c linux-workdir/arch/xr17032/mm/init.c
--- linux-clean/arch/xr17032/mm/init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/init.c
@@ -0,0 +1,233 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/fixmap.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <linux/align.h>
+#include <linux/dma-map-ops.h>
+#include <linux/initrd.h>
+#include <linux/linkage.h>
+#include <linux/memblock.h>
+#include <linux/minmax.h>
+#include <linux/mm.h>
+#include <linux/mmzone.h>
+#include <linux/of_fdt.h>
+
+void *_dtb_early_va;
+uintptr_t _dtb_early_pa;
+
+unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)]
+__page_aligned_bss;
+
+static pte_t fixmap_pte[PTRS_PER_PTE] __page_aligned_bss;
+
+static const pgprot_t protection_map[] = {
+	[VM_NONE]					= PAGE_NONE,
+	[VM_READ]					= PAGE_READ,
+	[VM_WRITE]					= PAGE_COPY,
+	[VM_WRITE | VM_READ]				= PAGE_COPY,
+	[VM_EXEC]					= PAGE_EXEC,
+	[VM_EXEC | VM_READ]				= PAGE_READ_EXEC,
+	[VM_EXEC | VM_WRITE]				= PAGE_COPY_EXEC,
+	[VM_EXEC | VM_WRITE | VM_READ]			= PAGE_COPY_EXEC,
+	[VM_SHARED]					= PAGE_NONE,
+	[VM_SHARED | VM_READ]				= PAGE_READ,
+	[VM_SHARED | VM_WRITE]				= PAGE_SHARED,
+	[VM_SHARED | VM_WRITE | VM_READ]		= PAGE_SHARED,
+	[VM_SHARED | VM_EXEC]				= PAGE_EXEC,
+	[VM_SHARED | VM_EXEC | VM_READ]			= PAGE_READ_EXEC,
+	[VM_SHARED | VM_EXEC | VM_WRITE]		= PAGE_SHARED_EXEC,
+	[VM_SHARED | VM_EXEC | VM_WRITE | VM_READ]	= PAGE_SHARED_EXEC
+};
+
+DECLARE_VM_GET_PAGE_PROT
+
+phys_addr_t dma32_phys_limit;
+
+void __set_fixmap(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot)
+{
+	unsigned long addr = __fix_to_virt(idx);
+	pte_t *ptep;
+
+	BUG_ON(idx <= FIX_HOLE || idx >= __end_of_fixed_addresses);
+
+	ptep = &fixmap_pte[pte_index(addr)];
+
+	if (pgprot_val(prot))
+		set_pte(ptep, pfn_pte(phys >> PAGE_SHIFT, prot));
+	else
+		pte_clear(&init_mm, addr, ptep);
+	local_flush_tlb_page(addr);
+}
+
+static void __meminit create_pgd_mapping(pgd_t *pgdp, uintptr_t va, phys_addr_t pa)
+{
+	uintptr_t pgd_idx = pgd_index(va);
+
+	BUG_ON(pgd_val(pgdp[pgd_idx]));
+
+	pgdp[pgd_idx] = pfn_pgd(PFN_DOWN(pa), PAGE_TABLE);
+}
+
+static void __init reserve_mapped_memory(void)
+{
+	pte_t *cur_pte = (pte_t *)_PGTABLE_ADDR;
+	pgd_t *cur_pgd = swapper_pg_dir;
+
+	for (unsigned i = 0; i < PTRS_PER_PGD; i++) {
+		pgd_t pgd_entry = *cur_pgd++;
+
+		if (pgd_val(pgd_entry)) {
+			for (unsigned j = 0; j < PTRS_PER_PTE; j++) {
+				pte_t pte_entry = *cur_pte++;
+
+				if (pte_val(pte_entry)) {
+					unsigned long pfn = pte_pfn(pte_entry);
+					memblock_reserve(pfn << PAGE_SHIFT,
+							 PAGE_SIZE);
+				}
+			}
+		} else {
+			cur_pte += PTRS_PER_PTE;
+		}
+	}
+}
+
+asmlinkage void __init setup_vm(uintptr_t dtb_pa);
+
+asmlinkage void __init setup_vm(uintptr_t dtb_pa)
+{
+	extern char _end[];
+
+	_dtb_early_va = (void *)ALIGN((uintptr_t)_end, PAGE_SIZE);
+	_dtb_early_pa = dtb_pa;
+
+	pgd_t *early_pg_dir = (pgd_t *)_PGD_ADDR;
+
+	*(pte_t *)(_PGTABLE_ADDR | (_SWAPPER_PGD_ADDR >> 10))
+		= pfn_pte(__pa(early_pg_dir) >> PAGE_SHIFT, PAGE_KERNEL);
+	create_pgd_mapping(early_pg_dir, FIXADDR_START, __pa(fixmap_pte));
+
+	local_flush_tlb_all();
+
+	reserve_mapped_memory();
+}
+
+static void __init setup_bootmem(void)
+{
+	phys_addr_t max_mapped_addr = __pa(-PAGE_SIZE);
+	memblock_reserve(max_mapped_addr, (phys_addr_t)-max_mapped_addr);
+
+	phys_addr_t phys_ram_base = memblock_start_of_DRAM();
+	phys_addr_t phys_ram_end = memblock_end_of_DRAM();
+
+	min_low_pfn = PFN_UP(phys_ram_base);
+	max_low_pfn = max_pfn = PFN_DOWN(phys_ram_end);
+
+	reserve_initrd_mem();
+	early_init_fdt_scan_reserved_mem();
+
+	dma32_phys_limit = max(4UL * SZ_1G,
+			       (unsigned long)PFN_PHYS(max_low_pfn));
+
+	dma_contiguous_reserve(dma32_phys_limit);
+}
+
+static void __meminit create_linear_mapping_range(phys_addr_t start,
+						  phys_addr_t end)
+{
+	pgd_t *pgdp = swapper_pg_dir;
+
+	uintptr_t vhead = (uintptr_t)__va(start);
+	uintptr_t vtail = (uintptr_t)__va(end - 1);
+
+	uintptr_t pgd_head = pgd_index(vhead);
+	uintptr_t pte_head = pte_index(vhead);
+
+	uintptr_t pgd_tail = pgd_index(vtail);
+	uintptr_t pte_tail = pte_index(vtail);
+
+	for (uintptr_t pgd_idx = pgd_head; pgd_idx <= pgd_tail; pgd_idx++) {
+		uintptr_t cur_pte_tail;
+
+		if (pgd_idx != pgd_tail)
+			cur_pte_tail = PTRS_PER_PTE - 1;
+		else
+			cur_pte_tail = pte_tail;
+
+		phys_addr_t pte_phys;
+		pte_t *ptep;
+
+		if (pgd_val(pgdp[pgd_idx]) == 0) {
+			pte_phys = memblock_phys_alloc(PAGE_SIZE, PAGE_SIZE);
+			pgdp[pgd_idx] = pfn_pgd(PFN_DOWN(pte_phys), PAGE_TABLE);
+			ptep = (pte_t *)set_fixmap_offset(FIX_TEMP, pte_phys);
+			memset(ptep, 0, PAGE_SIZE);
+		} else {
+			ptep = (pte_t *)set_fixmap_offset(FIX_TEMP, pte_phys);
+		}
+
+		for (uintptr_t pte_idx = pte_head; pte_idx <= cur_pte_tail;
+		     pte_idx++) {
+			unsigned long pfn = PFN_DOWN(start);
+			ptep[pte_idx] = pfn_pte(pfn, PAGE_KERNEL_EXEC);
+			start += PAGE_SIZE;
+		}
+
+		clear_fixmap(FIX_TEMP);
+
+		pte_head = 0;
+	}
+}
+
+static void __init create_linear_mapping_page_table(void)
+{
+	phys_addr_t start, end;
+	u64 i;
+
+	for_each_mem_range(i, &start, &end) {
+		if (start >= end)
+			break;
+		if (start <= __pa(PAGE_OFFSET) && __pa(PAGE_OFFSET) < end)
+			start = __pa(PAGE_OFFSET);
+
+		create_linear_mapping_range(start, end);
+	}
+}
+
+static void __init setup_vm_final(void)
+{
+	create_linear_mapping_page_table();
+
+	local_flush_tlb_all();
+}
+
+void __init paging_init(void)
+{
+	setup_bootmem();
+	setup_vm_final();
+	memblock_allow_resize();
+}
+
+static void __init zone_sizes_init(void)
+{
+	unsigned long max_zone_pfns[MAX_NR_ZONES] = { 0, };
+
+#ifdef CONFIG_ZONE_DMA32
+	max_zone_pfns[ZONE_DMA32] = PFN_DOWN(dma32_phys_limit);
+#endif
+	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
+
+	free_area_init(max_zone_pfns);
+}
+
+void __init misc_mem_init(void)
+{
+	early_memtest(min_low_pfn << PAGE_SHIFT, max_low_pfn << PAGE_SHIFT);
+	sparse_init();
+	zone_sizes_init();
+	memblock_dump_all();
+}
diff -urN --no-dereference linux-clean/arch/xr17032/mm/tlbflush.c linux-workdir/arch/xr17032/mm/tlbflush.c
--- linux-clean/arch/xr17032/mm/tlbflush.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/tlbflush.c
@@ -0,0 +1,93 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/tlbflush.h>
+#include <linux/smp.h>
+
+#define FLUSH_TLB_MAX_SIZE	~0UL
+#define TLB_FLUSH_ALL_THRESHOLD 64
+
+static inline void local_flush_tlb_range(unsigned long start,
+					 unsigned long size)
+{
+	if (size == FLUSH_TLB_MAX_SIZE) {
+		local_flush_tlb_all();
+		return;
+	}
+
+	unsigned long nr_ptes_in_range = DIV_ROUND_UP(size, PAGE_SIZE);
+
+	if (nr_ptes_in_range > TLB_FLUSH_ALL_THRESHOLD) {
+		local_flush_tlb_all();
+		return;
+	}
+
+	for (unsigned long i = 0; i < nr_ptes_in_range; i++) {
+		local_flush_tlb_page(start);
+		start += PAGE_SIZE;
+	}
+}
+
+struct flush_tlb_range_data {
+	unsigned long start;
+	unsigned long size;
+};
+
+static void __ipi_flush_tlb_range_asid(void *info)
+{
+	struct flush_tlb_range_data *d = info;
+
+	local_flush_tlb_range(d->start, d->size);
+}
+
+static void __flush_tlb_range(struct mm_struct *mm,
+			      const struct cpumask *cmask,
+			      unsigned long start, unsigned long size)
+{
+	if (cpumask_empty(cmask))
+		return;
+
+	unsigned int cpu = get_cpu();
+
+	if (cpumask_any_but(cmask, cpu) >= nr_cpu_ids) {
+		local_flush_tlb_range(start, size);
+	} else {
+		struct flush_tlb_range_data ftd;
+		ftd.start = start;
+		ftd.size = size;
+		on_each_cpu_mask(cmask, __ipi_flush_tlb_range_asid, &ftd, 1);
+	}
+
+	put_cpu();
+}
+
+void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+		     unsigned long end)
+{
+	__flush_tlb_range(vma->vm_mm, mm_cpumask(vma->vm_mm), start,
+			  end - start);
+}
+
+void flush_tlb_mm(struct mm_struct *mm)
+{
+	__flush_tlb_range(mm, mm_cpumask(mm), 0, FLUSH_TLB_MAX_SIZE);
+}
+
+
+void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)
+{
+	__flush_tlb_range(vma->vm_mm, mm_cpumask(vma->vm_mm), addr, PAGE_SIZE);
+}
+
+void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
+			unsigned long end, unsigned int page_size)
+{
+	__flush_tlb_range(mm, mm_cpumask(mm), start, end - start);
+}
+
+void flush_tlb_kernel_range(unsigned long start, unsigned long end)
+{
+	__flush_tlb_range(NULL, cpu_online_mask, start, end - start);
+}
diff -urN --no-dereference linux-clean/drivers/Kconfig linux-workdir/drivers/Kconfig
--- linux-clean/drivers/Kconfig
+++ linux-workdir/drivers/Kconfig
@@ -247,4 +247,6 @@
 
 source "drivers/dpll/Kconfig"
 
+source "drivers/amtsu/Kconfig"
+
 endmenu
diff -urN --no-dereference linux-clean/drivers/Makefile linux-workdir/drivers/Makefile
--- linux-clean/drivers/Makefile
+++ linux-workdir/drivers/Makefile
@@ -196,3 +196,5 @@
 obj-$(CONFIG_DPLL)		+= dpll/
 
 obj-$(CONFIG_S390)		+= s390/
+
+obj-$(CONFIG_AMTSU)		+= amtsu/
diff -urN --no-dereference linux-clean/drivers/amtsu/Kconfig linux-workdir/drivers/amtsu/Kconfig
--- linux-clean/drivers/amtsu/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/amtsu/Kconfig
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0-only
+config AMTSU
+	tristate "XR/arch Amtsu bus driver"
+	depends on OF
+	help
+	  Enables support for the XR/arch Amtsu bus.
diff -urN --no-dereference linux-clean/drivers/amtsu/Makefile linux-workdir/drivers/amtsu/Makefile
--- linux-clean/drivers/amtsu/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/amtsu/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-y	+= amtsu.o
diff -urN --no-dereference linux-clean/drivers/amtsu/amtsu.c linux-workdir/drivers/amtsu/amtsu.c
--- linux-clean/drivers/amtsu/amtsu.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/amtsu/amtsu.c
@@ -0,0 +1,377 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/amtsu.h>
+#include <linux/device.h>
+#include <linux/device/bus.h>
+#include <linux/device/driver.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#define AMTSU_DEVICES	4
+
+#define AMTSU_SELECT	0x00
+#define AMTSU_MID	0x04
+#define AMTSU_CMD	0x08
+#define AMTSU_A		0x0c
+#define AMTSU_B		0x10
+
+#define AMTSU_IDX_NONE (-2)
+#define AMTSU_IDX_CTRL (-1)
+
+#define AMTSU_CMD_ENABLE_IRQ	0x1
+#define AMTSU_CMD_RESET		0x2
+#define AMTSU_CMD_DISABLE_IRQ	0x3
+
+struct amtsu_ctrl {
+	struct platform_device *pdev;
+	struct amtsu_ctrl_device *devices[AMTSU_DEVICES];
+	void __iomem *regs;
+	spinlock_t lock;
+	int selected;
+};
+
+struct amtsu_ctrl_device {
+	struct amtsu_device adev;
+	struct amtsu_ctrl *ctrl;
+	int index;
+	bool irq_enabled;
+};
+
+#define amtsu_to_ctrl(_dev)	container_of_const(_dev, struct amtsu_ctrl_device, adev)
+
+static DEFINE_IDA(amtsu_index_ida);
+
+static int amtsu_register_device(struct amtsu_device *dev);
+static void amtsu_unregister_device(struct amtsu_device *dev);
+
+static void amtsu_ctrl_select(struct amtsu_ctrl *ctrl, int index)
+{
+	if (ctrl->selected == index)
+		return;
+
+	writel(index + 1, ctrl->regs + AMTSU_SELECT);
+	ctrl->selected = index;
+}
+
+static void amtsu_ctrl_enable_irq(struct amtsu_device *_d)
+{
+	struct amtsu_ctrl_device *dev = amtsu_to_ctrl(_d);
+
+	unsigned long flags;
+	spin_lock_irqsave(&dev->ctrl->lock, flags);
+
+	if (!dev->irq_enabled) {
+		amtsu_ctrl_select(dev->ctrl, AMTSU_IDX_CTRL);
+
+		writel(dev->index + 1, dev->ctrl->regs + AMTSU_B);
+		writel(AMTSU_CMD_ENABLE_IRQ, dev->ctrl->regs + AMTSU_CMD);
+
+		dev->irq_enabled = true;
+	}
+
+	spin_unlock_irqrestore(&dev->ctrl->lock, flags);
+}
+
+static void amtsu_ctrl_disable_irq(struct amtsu_device *_d)
+{
+	struct amtsu_ctrl_device *dev = amtsu_to_ctrl(_d);
+
+	unsigned long flags;
+	spin_lock_irqsave(&dev->ctrl->lock, flags);
+
+	if (dev->irq_enabled) {
+		amtsu_ctrl_select(dev->ctrl, AMTSU_IDX_CTRL);
+
+		writel(dev->index + 1, dev->ctrl->regs + AMTSU_B);
+		writel(AMTSU_CMD_DISABLE_IRQ, dev->ctrl->regs + AMTSU_CMD);
+
+		dev->irq_enabled = false;
+	}
+
+	spin_unlock_irqrestore(&dev->ctrl->lock, flags);
+}
+
+static void amtsu_ctrl_command(struct amtsu_device *_d, u32 cmd, u32 cmd_flags,
+			       u32 *a, u32 *b)
+{
+	struct amtsu_ctrl_device *dev = amtsu_to_ctrl(_d);
+
+	unsigned long flags;
+	spin_lock_irqsave(&dev->ctrl->lock, flags);
+
+	amtsu_ctrl_select(dev->ctrl, dev->index);
+
+	if (cmd_flags & AMTSU_CMD_WRITE_A)
+		writel(*a, dev->ctrl->regs + AMTSU_A);
+	if (cmd_flags & AMTSU_CMD_WRITE_B)
+		writel(*b, dev->ctrl->regs + AMTSU_B);
+
+	writel(cmd, dev->ctrl->regs + AMTSU_CMD);
+
+	if (cmd_flags & AMTSU_CMD_READ_A)
+		*a = readl(dev->ctrl->regs + AMTSU_A);
+	if (cmd_flags & AMTSU_CMD_READ_B)
+		*b = readl(dev->ctrl->regs + AMTSU_B);
+
+	spin_unlock_irqrestore(&dev->ctrl->lock, flags);
+}
+
+static const struct amtsu_bus_ops amtsu_ctrl_ops = {
+	.enable_irq	= amtsu_ctrl_enable_irq,
+	.disable_irq	= amtsu_ctrl_disable_irq,
+	.command	= amtsu_ctrl_command,
+};
+
+static void amtsu_ctrl_release_dev(struct device *_d)
+{
+	struct amtsu_ctrl_device *dev = amtsu_to_ctrl(dev_to_amtsu(_d));
+
+	kfree(dev);
+}
+
+static int amtsu_ctrl_probe(struct platform_device *pdev)
+{
+	struct amtsu_ctrl *ctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl),
+					       GFP_KERNEL);
+	if (!ctrl)
+		return -ENOMEM;
+
+	ctrl->pdev = pdev;
+	spin_lock_init(&ctrl->lock);
+	ctrl->selected = AMTSU_IDX_NONE;
+
+	int ret;
+	ctrl->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(ctrl->regs)) {
+		ret = PTR_ERR(ctrl->regs);
+		goto fail_free_ctrl;
+	}
+
+	platform_set_drvdata(pdev, ctrl);
+
+	amtsu_ctrl_select(ctrl, AMTSU_IDX_CTRL);
+
+	// disable all device irqs and reset them
+
+	for (int idx = 0; idx < AMTSU_DEVICES; idx++) {
+		writel(idx + 1, ctrl->regs + AMTSU_B);
+		writel(AMTSU_CMD_DISABLE_IRQ, ctrl->regs + AMTSU_CMD);
+	}
+
+	writel(AMTSU_CMD_RESET, ctrl->regs + AMTSU_CMD);
+
+	// discover devices
+
+	for (int idx = 0; idx < AMTSU_DEVICES; idx++) {
+		unsigned long flags;
+		spin_lock_irqsave(&ctrl->lock, flags);
+
+		amtsu_ctrl_select(ctrl, idx);
+		u32 model_id = readl(ctrl->regs + AMTSU_MID);
+
+		spin_unlock_irqrestore(&ctrl->lock, flags);
+
+		if (!model_id) continue;
+
+		struct amtsu_ctrl_device *dev = kzalloc(sizeof(*dev),
+							GFP_KERNEL);
+		if (!dev) {
+			dev_warn(&pdev->dev,
+				 "failed to allocate amtsu device %d\n", idx);
+			continue;
+		}
+
+		dev->adev.dev.parent = &pdev->dev;
+		dev->adev.dev.release = amtsu_ctrl_release_dev;
+		dev->adev.id.model_id = model_id;
+		dev->adev.bus = &amtsu_ctrl_ops;
+		dev->ctrl = ctrl;
+		dev->index = idx;
+
+		ret = platform_get_irq(pdev, idx);
+		if (ret < 0) {
+			kfree(dev);
+			continue;
+		}
+		dev->adev.irq = ret;
+
+		ret = amtsu_register_device(&dev->adev);
+		if (ret)
+			put_device(&dev->adev.dev);
+
+		ctrl->devices[idx] = dev;
+	}
+
+	return 0;
+fail_free_ctrl:
+	devm_kfree(&pdev->dev, ctrl);
+	return ret;
+}
+
+static void amtsu_ctrl_remove(struct platform_device *pdev)
+{
+	struct amtsu_ctrl *ctrl = platform_get_drvdata(pdev);
+
+	for (int idx = 0; idx < AMTSU_DEVICES; idx++) {
+		struct amtsu_ctrl_device *dev = ctrl->devices[idx];
+
+		if (dev) {
+			amtsu_unregister_device(&dev->adev);
+		}
+	}
+}
+
+static const struct of_device_id amtsu_ctrl_match[] = {
+	{ .compatible = "xrarch,amtsu" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, amtsu_ctrl_match);
+
+static struct platform_driver amtsu_ctrl_driver = {
+	.probe	= amtsu_ctrl_probe,
+	.remove	= amtsu_ctrl_remove,
+	.driver	= {
+		.name		= "amtsu",
+		.of_match_table	= amtsu_ctrl_match,
+	},
+};
+module_platform_driver(amtsu_ctrl_driver);
+
+static ssize_t model_id_show(struct device *_d, struct device_attribute *attr,
+			     char *buf)
+{
+	struct amtsu_device *dev = dev_to_amtsu(_d);
+	return sysfs_emit(buf, "0x%04x", dev->id.model_id);
+}
+static DEVICE_ATTR_RO(model_id);
+
+static struct attribute *amtsu_dev_attrs[] = {
+	&dev_attr_model_id.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(amtsu_dev);
+
+static int amtsu_dev_match(struct device *_dv, const struct device_driver *_dr)
+{
+	struct amtsu_device *dev = dev_to_amtsu(_dv);
+	const struct amtsu_device_id *ids = drv_to_amtsu(_dr)->id_table;
+
+	for (unsigned int i = 0; ids[i].model_id; i++) {
+		if (ids[i].model_id == dev->id.model_id)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int amtsu_dev_probe(struct device *_d)
+{
+	struct amtsu_device *dev = dev_to_amtsu(_d);
+	struct amtsu_driver *drv = drv_to_amtsu(dev->dev.driver);
+
+	return drv->probe(dev);
+}
+
+static void amtsu_dev_remove(struct device *_d)
+{
+	struct amtsu_device *dev = dev_to_amtsu(_d);
+	struct amtsu_driver *drv = drv_to_amtsu(dev->dev.driver);
+
+	drv->remove(dev);
+}
+
+static void amtsu_dev_shutdown(struct device *_d)
+{
+	struct amtsu_device *dev = dev_to_amtsu(_d);
+	struct amtsu_driver *drv = drv_to_amtsu(dev->dev.driver);
+
+	if (!drv)
+		return;
+
+	if (drv->shutdown) {
+		drv->shutdown(dev);
+		return;
+	}
+
+	dev->bus->disable_irq(dev);
+}
+
+static const struct bus_type amtsu_bus = {
+	.name		= "amtsu",
+	.dev_groups	= amtsu_dev_groups,
+	.match		= amtsu_dev_match,
+	.probe		= amtsu_dev_probe,
+	.remove		= amtsu_dev_remove,
+	.shutdown	= amtsu_dev_shutdown,
+};
+
+static int amtsu_register_device(struct amtsu_device *dev)
+{
+	dev->dev.bus = &amtsu_bus;
+	device_initialize(&dev->dev);
+
+	int ret = ida_alloc(&amtsu_index_ida, GFP_KERNEL);
+	if (ret < 0)
+		return ret;
+	dev->idx = ret;
+
+	ret = dev_set_name(&dev->dev, "amtsu%u", dev->idx);
+	if (ret)
+		goto fail_free_ida;
+
+	ret = device_add(&dev->dev);
+	if (ret)
+		goto fail_free_ida;
+
+	return 0;
+
+fail_free_ida:
+	ida_free(&amtsu_index_ida, dev->idx);
+	return ret;
+}
+
+static void amtsu_unregister_device(struct amtsu_device *dev)
+{
+	ida_free(&amtsu_index_ida, dev->idx);
+}
+
+int __amtsu_driver_register(struct amtsu_driver *driver, struct module *owner)
+{
+	driver->driver.bus = &amtsu_bus;
+	driver->driver.owner = owner;
+
+	return driver_register(&driver->driver);
+}
+
+void amtsu_driver_unregister(struct amtsu_driver *driver)
+{
+	driver_unregister(&driver->driver);
+}
+
+static int amtsu_init(void)
+{
+	if (bus_register(&amtsu_bus))
+		panic("amtsu bus registration failed");
+	return 0;
+}
+
+static void __exit amtsu_exit(void)
+{
+	bus_unregister(&amtsu_bus);
+	ida_destroy(&amtsu_index_ida);
+}
+
+core_initcall(amtsu_init);
+module_exit(amtsu_exit);
+
+MODULE_AUTHOR("monkuous");
+MODULE_DESCRIPTION("Amtsu bus driver");
+MODULE_LICENSE("GPL");
diff -urN --no-dereference linux-clean/drivers/block/Kconfig linux-workdir/drivers/block/Kconfig
--- linux-clean/drivers/block/Kconfig
+++ linux-workdir/drivers/block/Kconfig
@@ -426,4 +426,10 @@
 
 	  If unsure, say N.
 
+config BLK_DEV_XRARCH
+	tristate "XR/arch disk controller support"
+	depends on BLK_DEV && OF
+	help
+	  Support for the disk controller found in XR/computer systems.
+
 endif # BLK_DEV
diff -urN --no-dereference linux-clean/drivers/block/Makefile linux-workdir/drivers/block/Makefile
--- linux-clean/drivers/block/Makefile
+++ linux-workdir/drivers/block/Makefile
@@ -43,4 +43,6 @@
 obj-$(CONFIG_BLK_DEV_UBLK)			+= ublk_drv.o
 obj-$(CONFIG_BLK_DEV_ZONED_LOOP) += zloop.o
 
+obj-$(CONFIG_BLK_DEV_XRARCH)	+= xrarch.o
+
 swim_mod-y	:= swim.o swim_asm.o
diff -urN --no-dereference linux-clean/drivers/block/xrarch.c linux-workdir/drivers/block/xrarch.c
--- linux-clean/drivers/block/xrarch.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/block/xrarch.c
@@ -0,0 +1,401 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#define pr_fmt(fmt) "xrarch-disk: " fmt
+#include <linux/blkdev.h>
+#include <linux/blk-mq.h>
+#include <linux/dma-mapping.h>
+#include <linux/idr.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/panic.h>
+#include <linux/platform_device.h>
+
+#define PART_BITS	4
+
+#define DRIVER_NAME	"xrarch-disk"
+#define DEV_NAME	"xrdisk"
+
+#define XRDISK_CMD	0x00
+#define XRDISK_DATA0	0x04
+#define XRDISK_DATA1	0x08
+
+#define XRDISK_SELECT	0x01
+#define XRDISK_READ	0x02
+#define XRDISK_WRITE	0x03
+#define XRDISK_COMPLETE	0x04
+#define XRDISK_INFO	0x05
+#define XRDISK_IRQ_ON	0x06
+#define XRDISK_IRQ_OFF	0x07
+#define XRDISK_COUNT	0x08
+#define XRDISK_DEST	0x09
+
+#define XRDISK_MAX		8
+#define XRDISK_SECT_SHIFT	9
+
+struct xrarch_disk;
+
+struct xrarch_disk_ctrl {
+	struct device *dev;
+	void __iomem *regs;
+	spinlock_t lock;
+	struct xrarch_disk *disks[XRDISK_MAX];
+};
+
+struct xrarch_disk {
+	struct xrarch_disk_ctrl *ctrl;
+	int index;
+	int id;
+	struct gendisk *disk;
+	struct blk_mq_tag_set tag_set;
+	struct request *req;
+	dma_addr_t dma_addr;
+	size_t dma_length;
+	enum dma_data_direction dma_direction;
+};
+
+static DEFINE_IDA(xrarch_disk_id_ida);
+static int xrarch_disk_major;
+
+static void xrarch_disk_write(struct xrarch_disk_ctrl *ctrl, u32 reg, u32 value)
+{
+	writel(value, ctrl->regs + reg);
+}
+
+static u32 xrarch_disk_read(struct xrarch_disk_ctrl *ctrl, u32 reg)
+{
+	return readl(ctrl->regs + reg);
+}
+
+static irqreturn_t xrarch_disk_int(int irq, void *dev_id)
+{
+	struct xrarch_disk_ctrl *ctrl = dev_id;
+
+	unsigned long flags;
+	spin_lock_irqsave(&ctrl->lock, flags);
+
+	xrarch_disk_write(ctrl, XRDISK_CMD, XRDISK_COMPLETE);
+	u32 complete = xrarch_disk_read(ctrl, XRDISK_DATA1);
+
+	for (int idx = 0; idx < XRDISK_MAX && complete != 0; idx++) {
+		if ((complete & (1U << idx)) == 0) continue;
+
+		struct xrarch_disk *xdisk = ctrl->disks[idx];
+		struct request *req = xdisk->req;
+		xdisk->req = NULL;
+
+		BUG_ON(!req);
+
+		dma_unmap_page(ctrl->dev, xdisk->dma_addr, xdisk->dma_length,
+			       xdisk->dma_direction);
+		blk_mq_complete_request(req);
+	}
+
+	spin_unlock_irqrestore(&ctrl->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static blk_status_t xrarch_disk_queue_rq(struct blk_mq_hw_ctx *hctx,
+					 const struct blk_mq_queue_data *bd)
+{
+	struct xrarch_disk *xdisk = hctx->queue->queuedata;
+	struct request *req = bd->rq;
+
+	BUG_ON(blk_rq_nr_phys_segments(req) != 1);
+
+	u32 submit_cmd;
+	enum dma_data_direction dma_direction;
+
+	switch (req_op(req)) {
+	case REQ_OP_READ:
+		submit_cmd = XRDISK_READ;
+		dma_direction = DMA_FROM_DEVICE;
+		break;
+	case REQ_OP_WRITE:
+		submit_cmd = XRDISK_WRITE;
+		dma_direction = DMA_TO_DEVICE;
+		break;
+	default:
+		WARN_ON_ONCE(1);
+		return BLK_STS_IOERR;
+	}
+
+	u32 sector = blk_rq_pos(req) << (XRDISK_SECT_SHIFT - SECTOR_SHIFT);
+
+	struct bio_vec bvec;
+	struct bvec_iter iter;
+
+	bio_for_each_segment(bvec, req->bio, iter)
+		break;
+
+	u32 size = bvec.bv_len;
+
+	BUG_ON(size & ((1U << XRDISK_SECT_SHIFT) - 1));
+	BUG_ON(size > (8U << XRDISK_SECT_SHIFT));
+
+	dma_addr_t dma_addr = dma_map_bvec(xdisk->ctrl->dev, &bvec,
+					   dma_direction, 0);
+	if (dma_mapping_error(xdisk->ctrl->dev, dma_addr))
+		return BLK_STS_IOERR;
+
+	BUG_ON(dma_addr & ((1U << XRDISK_SECT_SHIFT) - 1));
+
+	blk_mq_start_request(req);
+
+	unsigned long flags;
+	spin_lock_irqsave(&xdisk->ctrl->lock, flags);
+
+	BUG_ON(xdisk->req);
+
+	xdisk->req = req;
+	xdisk->dma_addr = dma_addr;
+	xdisk->dma_length = size;
+	xdisk->dma_direction = dma_direction;
+
+	xrarch_disk_write(xdisk->ctrl, XRDISK_DATA0, xdisk->index);
+	xrarch_disk_write(xdisk->ctrl, XRDISK_CMD, XRDISK_SELECT);
+	xrarch_disk_write(xdisk->ctrl, XRDISK_DATA0, dma_addr);
+	xrarch_disk_write(xdisk->ctrl, XRDISK_CMD, XRDISK_DEST);
+	xrarch_disk_write(xdisk->ctrl, XRDISK_DATA0, size >> XRDISK_SECT_SHIFT);
+	xrarch_disk_write(xdisk->ctrl, XRDISK_CMD, XRDISK_COUNT);
+	xrarch_disk_write(xdisk->ctrl, XRDISK_DATA0, sector);
+	xrarch_disk_write(xdisk->ctrl, XRDISK_CMD, submit_cmd);
+
+	spin_unlock_irqrestore(&xdisk->ctrl->lock, flags);
+	return BLK_STS_OK;
+}
+
+static void xrarch_disk_complete(struct request *req)
+{
+	blk_mq_end_request(req, BLK_STS_OK);
+}
+
+static const struct blk_mq_ops xrarch_disk_mq_ops = {
+	.queue_rq	= xrarch_disk_queue_rq,
+	.complete	= xrarch_disk_complete,
+};
+
+static void xrarch_disk_free_disk(struct gendisk *disk)
+{
+	struct xrarch_disk *xdisk = disk->private_data;
+
+	ida_free(&xrarch_disk_id_ida, xdisk->id);
+	devm_kfree(xdisk->ctrl->dev, xdisk);
+}
+
+static const struct block_device_operations xrarch_disk_fops = {
+	.owner		= THIS_MODULE,
+	.free_disk	= xrarch_disk_free_disk,
+};
+
+static int minor_to_id(int minor)
+{
+	return minor >> PART_BITS;
+}
+
+static int id_to_minor(int id)
+{
+	return id << PART_BITS;
+}
+
+static int xrarch_disk_init_one(struct xrarch_disk_ctrl *ctrl, int idx,
+				u32 sectors)
+{
+	struct queue_limits lim = {
+		.features		= BLK_FEAT_ROTATIONAL,
+		.max_hw_sectors		= 8,
+		.max_segment_size	= 8U << XRDISK_SECT_SHIFT,
+		.physical_block_size	= 1U << XRDISK_SECT_SHIFT,
+		.logical_block_size	= 1U << XRDISK_SECT_SHIFT,
+		.max_segments		= 1,
+		.max_write_streams	= 1,
+		.dma_alignment		= 1U << XRDISK_SECT_SHIFT,
+	};
+
+	struct xrarch_disk *xdisk = devm_kzalloc(ctrl->dev, sizeof(*xdisk),
+						 GFP_KERNEL);
+	if (!xdisk)
+		return -ENOMEM;
+
+	xdisk->ctrl = ctrl;
+	xdisk->index = idx;
+
+	int ret = ida_alloc_range(&xrarch_disk_id_ida, 0,
+				  minor_to_id(1 << MINORBITS) - 1,
+				  GFP_KERNEL);
+	if (ret < 0)
+		goto fail_free_xdisk;
+
+	xdisk->id = ret;
+
+	xdisk->tag_set.ops = &xrarch_disk_mq_ops;
+	xdisk->tag_set.nr_maps = 1;
+	xdisk->tag_set.nr_hw_queues = 1;
+	xdisk->tag_set.queue_depth = 1;
+	xdisk->tag_set.numa_node = NUMA_NO_NODE;
+	xdisk->tag_set.driver_data = xdisk;
+
+	ret = blk_mq_alloc_tag_set(&xdisk->tag_set);
+	if (ret)
+		goto fail_free_id;
+
+	xdisk->disk = blk_mq_alloc_disk(&xdisk->tag_set, &lim, xdisk);
+	if (IS_ERR(xdisk->disk)) {
+		ret = PTR_ERR(xdisk->disk);
+		goto fail_free_tag_set;
+	}
+
+	snprintf(xdisk->disk->disk_name, DISK_NAME_LEN, DEV_NAME "%d",
+		 xdisk->id);
+
+	xdisk->disk->major = xrarch_disk_major;
+	xdisk->disk->first_minor = id_to_minor(xdisk->id);
+	xdisk->disk->minors = 1 << PART_BITS;
+	xdisk->disk->private_data = xdisk;
+	xdisk->disk->fops = &xrarch_disk_fops;
+
+	set_capacity(xdisk->disk, (u64)sectors << (XRDISK_SECT_SHIFT
+						   - SECTOR_SHIFT));
+
+	ctrl->disks[idx] = xdisk;
+
+	ret = device_add_disk(ctrl->dev, xdisk->disk, NULL);
+	if (ret)
+		goto fail_free_disk;
+
+	return 0;
+fail_free_disk:
+	put_disk(xdisk->disk);
+fail_free_tag_set:
+	blk_mq_free_tag_set(&xdisk->tag_set);
+fail_free_id:
+	ida_free(&xrarch_disk_id_ida, xdisk->id);
+fail_free_xdisk:
+	devm_kfree(ctrl->dev, xdisk);
+	return ret;
+}
+
+static int xrarch_disk_probe(struct platform_device *pdev)
+{
+	struct xrarch_disk_ctrl *ctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl),
+						     GFP_KERNEL);
+	if (!ctrl)
+		return -ENOMEM;
+
+	ctrl->dev = &pdev->dev;
+	spin_lock_init(&ctrl->lock);
+
+	int ret;
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENOMEM;
+		goto fail_free_ctrl;
+	}
+
+	ctrl->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ctrl->regs)) {
+		ret = PTR_ERR(ctrl->regs);
+		goto fail_free_ctrl;
+	}
+
+	ret = platform_get_irq(pdev, 0);
+	if (ret < 0)
+		goto fail_free_regs;
+	int irq = ret;
+
+	// wait for the controller to become idle
+	while (xrarch_disk_read(ctrl, XRDISK_CMD)) {
+		cpu_relax();
+	}
+
+	// make sure next completion status doesn't include stale info
+	xrarch_disk_write(ctrl, XRDISK_CMD, XRDISK_COMPLETE);
+
+	// set up irq
+	ret = request_irq(irq, xrarch_disk_int, 0, DRIVER_NAME, ctrl);
+	if (ret)
+		goto fail_free_irq;
+	xrarch_disk_write(ctrl, XRDISK_CMD, XRDISK_IRQ_ON);
+
+	// discover disks
+	for (int idx = 0; idx < XRDISK_MAX; idx++) {
+		unsigned long flags;
+		spin_lock_irqsave(&ctrl->lock, flags);
+		xrarch_disk_write(ctrl, XRDISK_DATA0, idx);
+		xrarch_disk_write(ctrl, XRDISK_CMD, XRDISK_INFO);
+		u32 present = xrarch_disk_read(ctrl, XRDISK_DATA0);
+		u32 sectors = xrarch_disk_read(ctrl, XRDISK_DATA1);
+		spin_unlock_irqrestore(&ctrl->lock, flags);
+
+		if (!present) continue;
+
+		int error = xrarch_disk_init_one(ctrl, idx, sectors);
+		if (error)
+			dev_warn(&pdev->dev,
+				 "failed to initialize disk %d (%d)\n", idx,
+				 error);
+	}
+
+	return 0;
+fail_free_irq:
+	irq_dispose_mapping(irq);
+fail_free_regs:
+	devm_iounmap(&pdev->dev, ctrl->regs);
+fail_free_ctrl:
+	devm_kfree(&pdev->dev, ctrl);
+	return ret;
+}
+
+static void xrarch_disk_remove(struct platform_device *pdev)
+{
+	panic("TODO xrarch_disk_remove");
+}
+
+static const struct of_device_id xrarch_disk_dt_ids[] = {
+	{ .compatible = "xrarch,disk-controller" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, xrarch_disk_dt_ids);
+
+static struct platform_driver xrarch_disk_driver = {
+	.probe	= xrarch_disk_probe,
+	.remove	= xrarch_disk_remove,
+	.driver	= {
+		.name		= DRIVER_NAME,
+		.of_match_table	= xrarch_disk_dt_ids,
+	},
+};
+
+static int __init xrarch_disk_init(void)
+{
+	int error = register_blkdev(0, DEV_NAME);
+	if (error < 0)
+		return error;
+	xrarch_disk_major = error;
+
+	error = platform_driver_register(&xrarch_disk_driver);
+	if (error)
+		goto fail_unregister_blkdev;
+
+	return 0;
+fail_unregister_blkdev:
+	unregister_blkdev(xrarch_disk_major, DEV_NAME);
+	return error;
+}
+
+static void __exit xrarch_disk_exit(void)
+{
+	platform_driver_unregister(&xrarch_disk_driver);
+	unregister_blkdev(xrarch_disk_major, DEV_NAME);
+}
+
+module_init(xrarch_disk_init);
+module_exit(xrarch_disk_exit);
+
+MODULE_AUTHOR("monkuous");
+MODULE_DESCRIPTION("Driver for the XR/arch disk controller");
+MODULE_LICENSE("GPL");
diff -urN --no-dereference linux-clean/drivers/clocksource/Kconfig linux-workdir/drivers/clocksource/Kconfig
--- linux-clean/drivers/clocksource/Kconfig
+++ linux-workdir/drivers/clocksource/Kconfig
@@ -779,4 +779,12 @@
           Enables the support for NXP System Timer Module found in the
           s32g NXP platform series.
 
+config XRARCH_RTC
+	bool "XR/arch RTC driver"
+	depends on OF
+	select TIMER_PROBE
+	select TIMER_OF
+	help
+	  Enables support for the RTC device found in XR/computer systems.
+
 endmenu
diff -urN --no-dereference linux-clean/drivers/clocksource/Makefile linux-workdir/drivers/clocksource/Makefile
--- linux-clean/drivers/clocksource/Makefile
+++ linux-workdir/drivers/clocksource/Makefile
@@ -94,3 +94,4 @@
 obj-$(CONFIG_EP93XX_TIMER)		+= timer-ep93xx.o
 obj-$(CONFIG_RALINK_TIMER)		+= timer-ralink.o
 obj-$(CONFIG_NXP_STM_TIMER)		+= timer-nxp-stm.o
+obj-$(CONFIG_XRARCH_RTC)		+= timer-xrarch-rtc.o
diff -urN --no-dereference linux-clean/drivers/clocksource/timer-xrarch-rtc.c linux-workdir/drivers/clocksource/timer-xrarch-rtc.c
--- linux-clean/drivers/clocksource/timer-xrarch-rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/clocksource/timer-xrarch-rtc.c
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#define pr_fmt(fmt) "xrarch-rtc: " fmt
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#define RTC_LATCH	((1000UL + (HZ / 2)) / HZ)
+
+#define RTC_CMD		0x00
+#define RTC_DATA	0x04
+
+#define RTC_SET_IRQ	0x01
+#define RTC_GET_TIME	0x02
+#define RTC_GET_TIME_MS	0x03
+#define RTC_SET_TIME	0x04
+#define RTC_SET_TIME_MS	0x05
+
+struct xrarch_rtc {
+	struct clock_event_device base;
+	void __iomem *regs;
+	raw_spinlock_t lock;
+};
+
+static irqreturn_t xrarch_rtc_irq(int irq, void *dev_id)
+{
+	struct xrarch_rtc *device = dev_id;
+	device->base.event_handler(&device->base);
+	return IRQ_HANDLED;
+}
+
+static int xrarch_rtc_shutdown(struct clock_event_device *evt)
+{
+	struct xrarch_rtc *device = (struct xrarch_rtc *)evt;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&device->lock, flags);
+	writel(0, device->regs + RTC_DATA);
+	writel(RTC_SET_IRQ, device->regs + RTC_CMD);
+	raw_spin_unlock_irqrestore(&device->lock, flags);
+
+	return 0;
+}
+
+static int xrarch_rtc_periodic(struct clock_event_device *evt)
+{
+	struct xrarch_rtc *device = (struct xrarch_rtc *)evt;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&device->lock, flags);
+	writel(RTC_LATCH, device->regs + RTC_DATA);
+	writel(RTC_SET_IRQ, device->regs + RTC_CMD);
+	raw_spin_unlock_irqrestore(&device->lock, flags);
+
+	return 0;
+}
+
+static int __init xrarch_rtc_init(struct device_node *np)
+{
+	BUG_ON(RTC_LATCH < 1);
+
+	void __iomem *regs = of_iomap(np, 0);
+	if (!regs)
+		return -ENOMEM;
+
+	int error;
+
+	struct xrarch_rtc *data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		error = -ENOMEM;
+		goto fail_free_regs;
+	}
+
+	data->base.name = "xrarch-rtc";
+	data->base.features = CLOCK_EVT_FEAT_PERIODIC;
+	data->base.set_state_shutdown = xrarch_rtc_shutdown;
+	data->base.set_state_periodic = xrarch_rtc_periodic;
+	data->base.cpumask = cpumask_of(smp_processor_id());
+	data->regs = regs;
+	raw_spin_lock_init(&data->lock);
+
+	xrarch_rtc_shutdown(&data->base);
+
+	int irq = of_irq_get(np, 0);
+	if (irq <= 0) {
+		error = irq ? irq : -ENODEV;
+		goto fail_free_data;
+	}
+
+	error = request_irq(irq, xrarch_rtc_irq, IRQF_NOBALANCING |
+			    IRQF_IRQPOLL | IRQF_TIMER, "xrarch-rtc", data);
+	if (error)
+		goto fail_free_data;
+
+	clockevents_config_and_register(&data->base, 1000, 0, 0);
+
+	return 0;
+
+fail_free_data:
+	kfree(data);
+fail_free_regs:
+	iounmap(regs);
+	return error;
+}
+
+TIMER_OF_DECLARE(xrarch_rtc, "xrarch,rtc", xrarch_rtc_init);
diff -urN --no-dereference linux-clean/drivers/input/keyboard/Kconfig linux-workdir/drivers/input/keyboard/Kconfig
--- linux-clean/drivers/input/keyboard/Kconfig
+++ linux-workdir/drivers/input/keyboard/Kconfig
@@ -797,4 +797,10 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called cypress-sf.
 
+config KEYBOARD_AISA
+	tristate "XR/arch AISA keyboard support"
+	depends on AMTSU
+	help
+	  Say Y here if you want to enable support for XR/arch AISA keyboards.
+
 endif
diff -urN --no-dereference linux-clean/drivers/input/keyboard/Makefile linux-workdir/drivers/input/keyboard/Makefile
--- linux-clean/drivers/input/keyboard/Makefile
+++ linux-workdir/drivers/input/keyboard/Makefile
@@ -9,6 +9,7 @@
 obj-$(CONFIG_KEYBOARD_ADP5520)		+= adp5520-keys.o
 obj-$(CONFIG_KEYBOARD_ADP5588)		+= adp5588-keys.o
 obj-$(CONFIG_KEYBOARD_ADP5589)		+= adp5589-keys.o
+obj-$(CONFIG_KEYBOARD_AISA)		+= aisa-kbd.o
 obj-$(CONFIG_KEYBOARD_AMIGA)		+= amikbd.o
 obj-$(CONFIG_KEYBOARD_APPLESPI)		+= applespi.o
 obj-$(CONFIG_KEYBOARD_ATARI)		+= atakbd.o
diff -urN --no-dereference linux-clean/drivers/input/keyboard/aisa-kbd.c linux-workdir/drivers/input/keyboard/aisa-kbd.c
--- linux-clean/drivers/input/keyboard/aisa-kbd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/input/keyboard/aisa-kbd.c
@@ -0,0 +1,153 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/amtsu.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/keyboard.h>
+#include <linux/module.h>
+
+#define AISA_KBD_SCANCODES	86
+
+#define AISA_KBD_POP		0x01
+#define AISA_KBD_RESET		0x02
+
+static const unsigned short aisa_kbd_keycodes[AISA_KBD_SCANCODES] = {
+	[0]	= KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I,
+		  KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R,
+		  KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z,
+	[26]	= KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8,
+		  KEY_9,
+	[36]	= KEY_SEMICOLON, KEY_SPACE, KEY_TAB,
+	[39]	= KEY_MINUS, KEY_EQUAL, KEY_LEFTBRACE, KEY_RIGHTBRACE,
+		  KEY_BACKSLASH,
+	[45]	= KEY_SLASH, KEY_DOT, KEY_APOSTROPHE, KEY_COMMA, KEY_GRAVE,
+	[50]	= KEY_ENTER, KEY_BACKSPACE, KEY_CAPSLOCK, KEY_ESC,
+	[54]	= KEY_LEFT, KEY_RIGHT, KEY_DOWN, KEY_UP,
+	[80]	= KEY_LEFTCTRL, KEY_RIGHTCTRL, KEY_LEFTSHIFT, KEY_RIGHTSHIFT,
+		  KEY_LEFTALT, KEY_RIGHTALT,
+};
+
+static irqreturn_t aisa_kbd_int(int irq, void *dev_id)
+{
+	struct amtsu_device *adev = dev_id;
+	struct input_dev *dev = adev->priv;
+
+	for (;;) {
+		u32 scancode;
+		adev->bus->command(adev, AISA_KBD_POP, AMTSU_CMD_READ_A,
+				   &scancode, NULL);
+		if (scancode == 0xffff) break;
+
+		input_event(dev, EV_MSC, MSC_RAW, scancode);
+
+		bool released = scancode & 0x8000;
+		scancode = scancode & 0x7fff;
+
+		if (scancode >= ARRAY_SIZE(aisa_kbd_keycodes))
+			goto sync;
+
+		unsigned short keycode = aisa_kbd_keycodes[scancode];
+		if (!keycode)
+			goto sync;
+
+		input_event(dev, EV_MSC, MSC_SCAN, scancode);
+		input_event(dev, EV_KEY, keycode, !released);
+	sync:
+		input_sync(dev);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int aisa_kbd_probe(struct amtsu_device *adev)
+{
+	struct input_dev *dev = devm_input_allocate_device(&adev->dev);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->name = dev_name(&adev->dev);
+	dev->phys = "aisa-kbd/input0";
+	dev->id.bustype = BUS_AMTSU;
+	dev->id.vendor = 0x0001;
+	dev->id.product = 0x0001;
+	dev->id.version = 0x0100;
+
+	dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) | BIT_MASK(EV_MSC);
+
+	for (int i = 0; i < AISA_KBD_SCANCODES; i++)
+		set_bit(i, dev->keybit);
+
+	adev->priv = dev;
+
+	int ret;
+	dev->keycode = kmalloc(sizeof(aisa_kbd_keycodes), GFP_KERNEL);
+	if (!dev->keycode) {
+		ret = -ENOMEM;
+		goto fail_free_dev;
+	}
+	dev->keycodesize = sizeof(*aisa_kbd_keycodes);
+	dev->keycodemax = ARRAY_SIZE(aisa_kbd_keycodes);
+	memcpy(dev->keycode, aisa_kbd_keycodes, dev->keycodemax);
+
+	for (int i = 0; i < ARRAY_SIZE(aisa_kbd_keycodes); i++) {
+		if (aisa_kbd_keycodes[i] != KEY_RESERVED) {
+			__set_bit(aisa_kbd_keycodes[i], dev->keybit);
+		}
+	}
+
+	adev->bus->command(adev, AISA_KBD_RESET, 0, NULL, NULL);
+
+	ret = devm_request_irq(&adev->dev, adev->irq, aisa_kbd_int, 0,
+			       "aisa-keyboard", adev);
+	if (ret)
+		goto fail_free_keycode;
+
+	ret = input_register_device(dev);
+	if (ret)
+		goto fail_free_irq;
+
+	adev->bus->enable_irq(adev);
+
+	return 0;
+
+fail_free_irq:
+	devm_free_irq(&adev->dev, adev->irq, dev);
+fail_free_keycode:
+	kfree(dev->keycode);
+fail_free_dev:
+	input_free_device(dev);
+	return ret;
+}
+
+static const struct amtsu_device_id aisa_kbd_ids[] = {
+	{ .model_id = 0x8fc48fc4 },
+	{ },
+};
+MODULE_DEVICE_TABLE(amtsu, aisa_kbd_ids);
+
+static struct amtsu_driver aisa_kbd_driver = {
+	.driver.name = "aisa-keyboard",
+	.id_table = aisa_kbd_ids,
+	.probe = aisa_kbd_probe,
+};
+
+static int __init aisa_kbd_init(void)
+{
+	return amtsu_driver_register(&aisa_kbd_driver);
+}
+
+static void __exit aisa_kbd_exit(void)
+{
+	amtsu_driver_unregister(&aisa_kbd_driver);
+}
+
+module_init(aisa_kbd_init);
+module_exit(aisa_kbd_exit);
+
+MODULE_AUTHOR("monkuous");
+MODULE_DESCRIPTION("XR/arch AISA keyboard driver");
+MODULE_LICENSE("GPL");
diff -urN --no-dereference linux-clean/drivers/irqchip/Kconfig linux-workdir/drivers/irqchip/Kconfig
--- linux-clean/drivers/irqchip/Kconfig
+++ linux-workdir/drivers/irqchip/Kconfig
@@ -794,4 +794,14 @@
 	  chained controller, routing all interrupt source in P-Chip to
 	  the primary controller on C-Chip.
 
+config XR17032_INTC
+	bool
+	depends on XR17032
+	select IRQ_DOMAIN_HIERARCHY
+
+config XRARCH_LSIC
+	bool
+	depends on XR17032
+	select IRQ_DOMAIN_HIERARCHY
+
 endmenu
diff -urN --no-dereference linux-clean/drivers/irqchip/Makefile linux-workdir/drivers/irqchip/Makefile
--- linux-clean/drivers/irqchip/Makefile
+++ linux-workdir/drivers/irqchip/Makefile
@@ -132,3 +132,5 @@
 obj-$(CONFIG_MCHP_EIC)			+= irq-mchp-eic.o
 obj-$(CONFIG_SOPHGO_SG2042_MSI)		+= irq-sg2042-msi.o
 obj-$(CONFIG_SUNPLUS_SP7021_INTC)	+= irq-sp7021-intc.o
+obj-$(CONFIG_XRARCH_LSIC)		+= irq-xrarch-lsic.o
+obj-$(CONFIG_XR17032_INTC)		+= irq-xr17032-intc.o
diff -urN --no-dereference linux-clean/drivers/irqchip/irq-xr17032-intc.c linux-workdir/drivers/irqchip/irq-xr17032-intc.c
--- linux-clean/drivers/irqchip/irq-xr17032-intc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/irqchip/irq-xr17032-intc.c
@@ -0,0 +1,118 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#define pr_fmt(fmt) "xr17032-intc: " fmt
+#include <asm/irq.h>
+#include <asm/smp.h>
+#include <linux/fwnode.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/smp.h>
+
+#define INTC_IRQS 16
+
+struct irq_domain *xr17032_intc_domain;
+
+static void xr17032_intc_irq(struct pt_regs *regs)
+{
+	unsigned long cause = regs->rs >> 28;
+
+	if (generic_handle_domain_irq(xr17032_intc_domain, cause))
+		pr_warn_ratelimited("failed to handle interrupt (cause: %lu)\n",
+				    cause);
+}
+
+static void xr17032_intc_eoi(struct irq_data *d)
+{
+	// Without this function, the chained_irq functions will try to mask
+	// the IRQ, which is both impossible and unnecessary.
+}
+
+static struct irq_chip xr17032_intc_chip = {
+	.name		= "XR/17032 INTC",
+	.irq_eoi	= xr17032_intc_eoi,
+};
+
+static int xr17032_intc_domain_map(struct irq_domain *d, unsigned int irq,
+				   irq_hw_number_t hwirq)
+{
+	struct irq_chip *chip = d->host_data;
+
+	irq_set_percpu_devid(irq);
+	irq_domain_set_info(d, irq, hwirq, chip, NULL, handle_percpu_devid_irq,
+			    NULL, NULL);
+
+	return 0;
+}
+
+static int xr17032_intc_domain_alloc(struct irq_domain *domain,
+				     unsigned int virq, unsigned int nr_irqs,
+				     void *arg)
+{
+	struct irq_fwspec *fwspec = arg;
+	irq_hw_number_t hwirq;
+	unsigned int type = IRQ_TYPE_NONE;
+
+	int ret = irq_domain_translate_onecell(domain, fwspec, &hwirq, &type);
+	if (ret)
+		return ret;
+
+	if (hwirq + nr_irqs >= INTC_IRQS)
+		return -EINVAL;
+
+	for (unsigned int i = 0; i < nr_irqs; i++) {
+		ret = xr17032_intc_domain_map(domain, virq + i, hwirq + i);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct irq_domain_ops xr17032_intc_domain_ops = {
+	.map	= xr17032_intc_domain_map,
+	.xlate	= irq_domain_xlate_onecell,
+	.alloc	= xr17032_intc_domain_alloc,
+};
+
+static int __init xr17032_intc_init(struct device_node *node,
+				    struct device_node *parent)
+{
+	struct irq_chip *chip = &xr17032_intc_chip;
+
+	unsigned long cpu_hwid = of_get_cpu_hwid(node, 0);
+	if (cpu_hwid == ~0UL) {
+		pr_warn("unable to find cpu hwid for %pOF\n", node);
+		return 0;
+	}
+
+	struct fwnode_handle *fn = of_fwnode_handle(node);
+
+	if (xr17032_cpu_hwid_to_cpuid(cpu_hwid) != smp_processor_id()) {
+		fwnode_dev_initialized(fn, true);
+		return 0;
+	}
+
+	xr17032_intc_domain = irq_domain_create_linear(fn, INTC_IRQS,
+						       &xr17032_intc_domain_ops,
+						       chip);
+	if (!xr17032_intc_domain) {
+		pr_err("failed to create irq domain\n");
+		return -ENOMEM;
+	}
+
+	int rc = set_handle_irq(&xr17032_intc_irq);
+	if (rc) {
+		pr_err("failed to set irq handler\n");
+		return rc;
+	}
+
+	return 0;
+}
+
+IRQCHIP_DECLARE(xr17032_intc, "xrarch,xr17032", xr17032_intc_init);
diff -urN --no-dereference linux-clean/drivers/irqchip/irq-xrarch-lsic.c linux-workdir/drivers/irqchip/irq-xrarch-lsic.c
--- linux-clean/drivers/irqchip/irq-xrarch-lsic.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/irqchip/irq-xrarch-lsic.c
@@ -0,0 +1,292 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#define pr_fmt(fmt) "xrarch-lsic: " fmt
+#include <asm/smp.h>
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#define LSIC_PARENT_IRQ 1
+#define LSIC_IRQS 64
+
+#define LSIC_STRIDE 0x20
+
+#define LSIC_DISA 0x00
+#define LSIC_PEND 0x08
+#define LSIC_COMPL 0x10
+#define LSIC_CLAIM 0x10
+#define LSIC_IPL 0x14
+
+struct lsic_priv {
+	struct fwnode_handle *fwnode;
+	struct irq_domain *domain;
+	struct cpumask lmask;
+};
+
+struct lsic_handler {
+	struct lsic_priv *priv;
+	void __iomem *regs;
+	raw_spinlock_t mask_lock;
+};
+
+static DEFINE_PER_CPU(struct lsic_handler, lsic_handlers);
+
+static void lsic_handle_irq(struct irq_desc *desc)
+{
+	struct lsic_handler *handler = this_cpu_ptr(&lsic_handlers);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+
+	chained_irq_enter(chip, desc);
+
+	irq_hw_number_t hwirq;
+	while ((hwirq = readl(handler->regs + LSIC_CLAIM)) != 0) {
+		int err = generic_handle_domain_irq(handler->priv->domain,
+						    hwirq);
+
+		if (unlikely(err)) {
+			pr_warn_ratelimited("%pfwP: can't find mapping for hwirq %lu",
+					    handler->priv->fwnode, hwirq);
+		}
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static void lsic_irq_set_masked(struct irq_data *d, bool masked)
+{
+	int cpu;
+	unsigned long flags;
+	unsigned int hwirq = d->hwirq;
+	unsigned int offset = hwirq / 32 * 4;
+	unsigned int mask = 1U << (hwirq % 32);
+
+	for_each_cpu(cpu, irq_data_get_effective_affinity_mask(d)) {
+		struct lsic_handler *handler = per_cpu_ptr(&lsic_handlers, cpu);
+		raw_spin_lock_irqsave(&handler->mask_lock, flags);
+
+		void __iomem *reg = handler->regs + LSIC_DISA + offset;
+		unsigned int value = readl(reg);
+
+		if (masked)
+			writel(value | mask, reg);
+		else
+			writel(value & ~mask, reg);
+
+		raw_spin_unlock_irqrestore(&handler->mask_lock, flags);
+	}
+}
+
+static void lsic_irq_mask(struct irq_data *d)
+{
+	lsic_irq_set_masked(d, true);
+}
+
+static void lsic_irq_unmask(struct irq_data *d)
+{
+	lsic_irq_set_masked(d, false);
+}
+
+static void lsic_irq_eoi(struct irq_data *d)
+{
+	struct lsic_handler *handler = this_cpu_ptr(&lsic_handlers);
+	writel(d->hwirq, handler->regs + LSIC_COMPL);
+}
+
+static int lsic_set_affinity(struct irq_data *d,
+			     const struct cpumask *mask_val, bool force)
+{
+	struct lsic_priv *priv = irq_data_get_irq_chip_data(d);
+	unsigned int cpu;
+
+	if (force)
+		cpu = cpumask_first_and(&priv->lmask, mask_val);
+	else
+		cpu = cpumask_first_and_and(&priv->lmask, mask_val,
+					    cpu_online_mask);
+
+	if (cpu >= nr_cpu_ids)
+		return -EINVAL;
+
+	lsic_irq_mask(d);
+	irq_data_update_effective_affinity(d, cpumask_of(cpu));
+	if (!irqd_irq_masked(d))
+		lsic_irq_unmask(d);
+
+	return IRQ_SET_MASK_OK_DONE;
+}
+
+static struct irq_chip lsic_chip = {
+	.name			= "XR/arch LSIC",
+	.irq_mask		= lsic_irq_mask,
+	.irq_unmask		= lsic_irq_unmask,
+	.irq_eoi		= lsic_irq_eoi,
+	.irq_set_affinity	= lsic_set_affinity,
+	.flags			= IRQCHIP_SKIP_SET_WAKE |
+				  IRQCHIP_AFFINITY_PRE_STARTUP,
+};
+
+static int lsic_domain_map(struct irq_domain *d, unsigned int irq,
+			   irq_hw_number_t hwirq)
+{
+	struct lsic_priv *priv = d->host_data;
+
+	irq_domain_set_info(d, irq, hwirq, &lsic_chip, priv, handle_fasteoi_irq,
+			    NULL, NULL);
+	irq_set_noprobe(irq);
+	irq_set_affinity(irq, &priv->lmask);
+
+	return 0;
+}
+
+static int lsic_domain_alloc(struct irq_domain *domain, unsigned int virq,
+			     unsigned int nr_irqs, void *arg)
+{
+	struct irq_fwspec *fwspec = arg;
+	irq_hw_number_t hwirq;
+	unsigned int type;
+
+	int ret = irq_domain_translate_onecell(domain, fwspec, &hwirq, &type);
+	if (ret)
+		return ret;
+
+	if (hwirq + nr_irqs >= LSIC_IRQS)
+		return -EINVAL;
+
+	for (unsigned int i = 0; i < nr_irqs; i++) {
+		ret = lsic_domain_map(domain, virq + i, hwirq + i);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct irq_domain_ops lsic_domain_ops = {
+	.map		= lsic_domain_map,
+	.alloc		= lsic_domain_alloc,
+	.translate	= irq_domain_translate_onecell,
+	.free		= irq_domain_free_irqs_top,
+};
+
+static int lsic_parse_ctx(struct device_node *device, u32 idx, u32 *hwirq,
+			  unsigned long *cpu_hwid, int *cpu)
+{
+	struct of_phandle_args cpu_data;
+	int error = of_irq_parse_one(device, idx, &cpu_data);
+	if (error)
+		return error;
+
+	*cpu_hwid = of_get_cpu_hwid(cpu_data.np, 0);
+	if (*cpu_hwid == ~0UL) {
+		pr_warn("unable to find cpu hwid for %pOF\n", cpu_data.np);
+		return -ENODEV;
+	}
+
+	*hwirq = cpu_data.args[0];
+	*cpu = xr17032_cpu_hwid_to_cpuid(*cpu_hwid);
+	return 0;
+}
+
+static int __init lsic_init(struct device_node *device,
+			    struct device_node *parent)
+{
+	static bool lsic_global_init_done;
+
+	void __iomem *regs = of_iomap(device, 0);
+	if (!regs)
+		return -ENOMEM;
+
+	int error;
+
+	struct fwnode_handle *fwnode = &device->fwnode;
+
+	u32 nr_contexts = of_irq_count(device);
+	if (WARN_ON(!nr_contexts)) {
+		pr_err("%pfwP: no upstream contexts available\n", fwnode);
+		error = -EINVAL;
+		goto fail_free_regs;
+	}
+
+	struct lsic_priv *priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		error = -ENOMEM;
+		goto fail_free_regs;
+	}
+
+	priv->fwnode = fwnode;
+	priv->domain = irq_domain_create_linear(fwnode, LSIC_IRQS,
+						&lsic_domain_ops, priv);
+	if (!priv->domain) {
+		error = -ENOMEM;
+		goto fail_free_priv;
+	}
+
+	for (u32 idx = 0; idx < nr_contexts; idx++) {
+		u32 hwirq;
+		int cpu;
+		unsigned long cpu_hwid;
+
+		error = lsic_parse_ctx(device, idx, &hwirq, &cpu_hwid, &cpu);
+		if (error) {
+			pr_warn("%pfwP: hwirq for context %u not found\n",
+				fwnode, idx);
+			continue;
+		}
+
+		void __iomem *ctx_regs = regs + cpu_hwid * LSIC_STRIDE;
+
+		writel(~0UL, ctx_regs + LSIC_DISA);
+		writel(~0UL, ctx_regs + LSIC_DISA + 4);
+		writel(0, ctx_regs + LSIC_PEND);
+		writel(0, ctx_regs + LSIC_PEND + 4);
+		writel(LSIC_IRQS - 1, ctx_regs + LSIC_IPL);
+
+		if (cpu < 0) {
+			pr_warn("%pfwP: invalid cpuid for context %u\n",
+				fwnode, idx);
+			continue;
+		}
+
+		if (hwirq != LSIC_PARENT_IRQ)
+			continue;
+
+		cpumask_set_cpu(cpu, &priv->lmask);
+
+		struct lsic_handler *handler = per_cpu_ptr(&lsic_handlers, cpu);
+
+		handler->priv = priv;
+		handler->regs = ctx_regs;
+		raw_spin_lock_init(&handler->mask_lock);
+	}
+
+	if (!lsic_global_init_done) {
+		int parent_irq = irq_create_mapping(xr17032_intc_domain,
+						    LSIC_PARENT_IRQ);
+		if (parent_irq)
+			irq_set_chained_handler(parent_irq, lsic_handle_irq);
+
+		lsic_global_init_done = true;
+	}
+
+	pr_info("%pfwP: mapped %u contexts\n", fwnode, nr_contexts);
+	return 0;
+
+fail_free_priv:
+	kfree(priv);
+fail_free_regs:
+	iounmap(regs);
+	return error;
+}
+
+IRQCHIP_DECLARE(xrarch_lsic, "xrarch,lsic", lsic_init);
diff -urN --no-dereference linux-clean/drivers/tty/serial/Kconfig linux-workdir/drivers/tty/serial/Kconfig
--- linux-clean/drivers/tty/serial/Kconfig
+++ linux-workdir/drivers/tty/serial/Kconfig
@@ -1604,6 +1604,15 @@
 	  snippet may be used:
 	    earlycon=esp32s3acm,mmio32,0x60038000
 
+config SERIAL_XRARCH_UART
+	tristate "XR/arch UART support"
+	depends on OF
+	select SERIAL_CORE
+	select SERIAL_CORE_CONSOLE
+	select SERIAL_EARLYCON
+	help
+	  Driver for the UART controllers found in XR/computer systems.
+
 endmenu
 
 config SERIAL_MCTRL_GPIO
diff -urN --no-dereference linux-clean/drivers/tty/serial/Makefile linux-workdir/drivers/tty/serial/Makefile
--- linux-clean/drivers/tty/serial/Makefile
+++ linux-workdir/drivers/tty/serial/Makefile
@@ -92,6 +92,7 @@
 obj-$(CONFIG_SERIAL_UARTLITE)		+= uartlite.o
 obj-$(CONFIG_SERIAL_VT8500)		+= vt8500_serial.o
 obj-$(CONFIG_SERIAL_XILINX_PS_UART)	+= xilinx_uartps.o
+obj-$(CONFIG_SERIAL_XRARCH_UART)	+= xrarch_uart.o
 obj-$(CONFIG_SERIAL_ZS)			+= zs.o
 
 # GPIOLIB helpers for modem control lines
diff -urN --no-dereference linux-clean/drivers/tty/serial/xrarch_uart.c linux-workdir/drivers/tty/serial/xrarch_uart.c
--- linux-clean/drivers/tty/serial/xrarch_uart.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/tty/serial/xrarch_uart.c
@@ -0,0 +1,436 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * XR/arch UART driver
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/console.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/tty_flip.h>
+
+#define DRIVER_NAME	"xrarch-serial"
+#define DEV_NAME	"ttyS"
+#define UART_NR		2
+
+#define UART_CMD_REG	0x00
+#define UART_DATA_REG	0x04
+
+#define UART_IRQ_ON	0x03
+#define UART_IRQ_OFF	0x04
+
+#define UART_TX_FIFO_SIZE	16
+
+struct xrarch_port {
+	struct uart_port port;
+	u32 default_speed;
+};
+
+static struct xrarch_port *xrarch_serial_ports[UART_NR];
+
+static void xrarch_serial_write(struct uart_port *port, unsigned long reg,
+				u32 v)
+{
+	writel(v, port->membase + reg);
+}
+
+static u32 xrarch_serial_read(struct uart_port *port, unsigned long reg)
+{
+	return readl(port->membase + reg);
+}
+
+static bool xrarch_serial_tx_full(struct uart_port *port)
+{
+	return xrarch_serial_read(port, UART_CMD_REG) != 0;
+}
+
+static void xrarch_serial_put_char(struct uart_port *port, u8 c)
+{
+	xrarch_serial_write(port, UART_DATA_REG, c);
+}
+
+static void xrarch_serial_put_char_sync(struct uart_port *port, u8 c)
+{
+	unsigned long timeout = jiffies + HZ;
+
+	while (xrarch_serial_tx_full(port)) {
+		if (time_after(jiffies, timeout)) {
+			dev_warn(port->dev, "timeout waiting for TX\n");
+			return;
+		}
+
+		cpu_relax();
+	}
+
+	xrarch_serial_put_char(port, c);
+}
+
+static void xrarch_serial_do_rx(struct uart_port *port)
+{
+	struct tty_port *tty_port = &port->state->port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	u32 value;
+	u32 count = 0;
+
+	while ((value = xrarch_serial_read(port, UART_DATA_REG)) != 0xFFFF) {
+		count += 1;
+
+		if (uart_handle_sysrq_char(port, value))
+			continue;
+
+		tty_insert_flip_char(tty_port, value, TTY_NORMAL);
+		port->icount.rx += 1;
+	}
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	if (count)
+		tty_flip_buffer_push(tty_port);
+}
+
+static void xrarch_serial_do_tx(struct uart_port *port)
+{
+	u8 ch;
+	uart_port_tx(port, ch, !xrarch_serial_tx_full(port),
+		     xrarch_serial_put_char(port, ch));
+}
+
+static irqreturn_t xrarch_serial_int(int irq, void *dev_id)
+{
+	struct uart_port *port = dev_id;
+
+	xrarch_serial_do_rx(port);
+	xrarch_serial_do_tx(port);
+
+	return IRQ_HANDLED;
+}
+
+static void xrarch_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static unsigned int xrarch_serial_get_mctrl(struct uart_port *port)
+{
+	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+}
+
+static void xrarch_serial_stop_tx(struct uart_port *port)
+{
+}
+
+static void xrarch_serial_start_tx(struct uart_port *port)
+{
+	xrarch_serial_do_tx(port);
+}
+
+static void xrarch_serial_stop_rx(struct uart_port *port)
+{
+}
+
+static int xrarch_serial_startup(struct uart_port *port)
+{
+	int ret = request_irq(port->irq, xrarch_serial_int, 0, DRIVER_NAME,
+			      port);
+	if (ret)
+		return ret;
+
+	xrarch_serial_write(port, UART_CMD_REG, UART_IRQ_ON);
+
+	return ret;
+}
+
+static void xrarch_serial_shutdown(struct uart_port *port)
+{
+	xrarch_serial_write(port, UART_CMD_REG, UART_IRQ_OFF);
+	free_irq(port->irq, port);
+}
+
+static void xrarch_serial_set_termios(struct uart_port *port,
+				      struct ktermios *termios,
+				      const struct ktermios *old)
+{
+}
+
+static const char *xrarch_serial_type(struct uart_port *port)
+{
+	return "XR/arch UART";
+}
+
+static void xrarch_serial_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE)
+		port->type = PORT_GENERIC;
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+static void xrarch_serial_poll_put_char(struct uart_port *port, unsigned char c)
+{
+	xrarch_serial_put_char_sync(port, c);
+}
+
+static int xrarch_serial_poll_get_char(struct uart_port *port)
+{
+	u32 value = xrarch_serial_read(port, UART_DATA_REG);
+
+	if (value != 0xFFFF)
+		return value;
+	else
+		return NO_POLL_CHAR;
+
+}
+#endif
+
+static const struct uart_ops xrarch_serial_pops = {
+	.set_mctrl	= xrarch_serial_set_mctrl,
+	.get_mctrl	= xrarch_serial_get_mctrl,
+	.stop_tx	= xrarch_serial_stop_tx,
+	.start_tx	= xrarch_serial_start_tx,
+	.stop_rx	= xrarch_serial_stop_rx,
+	.startup	= xrarch_serial_startup,
+	.shutdown	= xrarch_serial_shutdown,
+	.set_termios	= xrarch_serial_set_termios,
+	.type		= xrarch_serial_type,
+	.config_port	= xrarch_serial_config_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_put_char	= xrarch_serial_poll_put_char,
+	.poll_get_char	= xrarch_serial_poll_get_char,
+#endif
+};
+
+static void xrarch_serial_console_putchar(struct uart_port *port, u8 c)
+{
+	xrarch_serial_put_char_sync(port, c);
+}
+
+static void xrarch_serial_string_write(struct uart_port *port, const char *s,
+				       unsigned int count)
+{
+	uart_console_write(port, s, count, xrarch_serial_console_putchar);
+}
+
+static void xrarch_serial_console_write(struct console *co, const char *s,
+					unsigned int count)
+{
+	struct xrarch_port *sport = xrarch_serial_ports[co->index];
+	struct uart_port *port = &sport->port;
+	bool locked = true;
+	unsigned long flags;
+
+	if (port->sysrq)
+		locked = false;
+	else if (oops_in_progress)
+		locked = spin_trylock_irqsave(&port->lock, flags);
+	else
+		spin_lock_irqsave(&port->lock, flags);
+
+	xrarch_serial_string_write(port, s, count);
+
+	if (locked)
+		spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int xrarch_serial_console_setup(struct console *co, char *options)
+{
+	if (co->index == -1 || co->index >= ARRAY_SIZE(xrarch_serial_ports))
+		co->index = 0;
+
+	struct xrarch_port *sport = xrarch_serial_ports[co->index];
+	if (!sport)
+		return -ENODEV;
+
+	int baud = sport->default_speed;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(&sport->port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver xrarch_serial_reg;
+static struct console xrarch_serial_console = {
+	.name	= DEV_NAME,
+	.write	= xrarch_serial_console_write,
+	.device	= uart_console_device,
+	.setup	= xrarch_serial_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
+	.data	= &xrarch_serial_reg,
+};
+
+static struct uart_driver xrarch_serial_reg = {
+	.owner		= THIS_MODULE,
+	.driver_name	= DRIVER_NAME,
+	.dev_name	= DEV_NAME,
+	.nr		= ARRAY_SIZE(xrarch_serial_ports),
+	.cons		= &xrarch_serial_console,
+};
+
+static int xrarch_serial_probe(struct platform_device *pdev)
+{
+	struct xrarch_port *sport = devm_kzalloc(&pdev->dev, sizeof(*sport),
+						 GFP_KERNEL);
+	if (!sport)
+		return -ENOMEM;
+
+	struct uart_port *port = &sport->port;
+	struct device_node *np = pdev->dev.of_node;
+
+	int ret = of_alias_get_id(np, "serial");
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to get alias id, errno %d\n", ret);
+		goto fail_free_port;
+	}
+	if (ret >= UART_NR) {
+		dev_err(&pdev->dev, "driver limited to %d ports\n", UART_NR);
+		ret = -ENOMEM;
+		goto fail_free_port;
+	}
+
+	port->line = ret;
+
+	ret = of_property_read_u32_index(np, "current-speed", 0,
+					 &sport->default_speed);
+	if (ret)
+		goto fail_free_port;
+
+	port->uartclk = sport->default_speed * 16;
+
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENOMEM;
+		goto fail_free_port;
+	}
+
+	port->mapbase = res->start;
+	port->membase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(port->membase)) {
+		ret = PTR_ERR(port->membase);
+		goto fail_free_port;
+	}
+
+	port->dev = &pdev->dev;
+	port->type = PORT_GENERIC;
+	port->iotype = UPIO_MEM;
+	port->irq = platform_get_irq(pdev, 0);
+	port->ops = &xrarch_serial_pops;
+	port->flags = UPF_BOOT_AUTOCONF;
+	port->has_sysrq = 1;
+	port->fifosize = UART_TX_FIFO_SIZE;
+
+	xrarch_serial_ports[port->line] = sport;
+
+	platform_set_drvdata(pdev, port);
+
+	return uart_add_one_port(&xrarch_serial_reg, port);
+fail_free_port:
+	devm_kfree(&pdev->dev, sport);
+	return ret;
+}
+
+static void xrarch_serial_remove(struct platform_device *pdev)
+{
+	struct uart_port *port = platform_get_drvdata(pdev);
+
+	uart_remove_one_port(&xrarch_serial_reg, port);
+}
+
+static const struct of_device_id xrarch_serial_dt_ids[] = {
+	{ .compatible = "xrarch,serial" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, xrarch_serial_dt_ids);
+
+static struct platform_driver xrarch_serial_driver = {
+	.probe	= xrarch_serial_probe,
+	.remove	= xrarch_serial_remove,
+	.driver	= {
+		.name		= DRIVER_NAME,
+		.of_match_table	= xrarch_serial_dt_ids,
+	},
+};
+
+static int __init xrarch_serial_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&xrarch_serial_reg);
+	if (ret)
+		return ret;
+
+	ret = platform_driver_register(&xrarch_serial_driver);
+	if (ret)
+		uart_unregister_driver(&xrarch_serial_reg);
+
+	return ret;
+}
+
+static void __exit xrarch_serial_exit(void)
+{
+	platform_driver_unregister(&xrarch_serial_driver);
+	uart_unregister_driver(&xrarch_serial_reg);
+}
+
+module_init(xrarch_serial_init);
+module_exit(xrarch_serial_exit);
+
+static void xrarch_serial_earlycon_putchar(struct uart_port *port, u8 c)
+{
+	xrarch_serial_put_char_sync(port, c);
+}
+
+static void xrarch_serial_earlycon_write(struct console *con, const char *s,
+				         unsigned int n)
+{
+	struct earlycon_device *dev = con->data;
+
+	uart_console_write(&dev->port, s, n, xrarch_serial_earlycon_putchar);
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+static int xrarch_serial_earlycon_read(struct console *con, char *s,
+				       unsigned int n)
+{
+	struct earlycon_device *dev = con->data;
+	unsigned int num_read = 0;
+
+	while (num_read < n) {
+		int c = xrarch_serial_poll_get_char(&dev->port);
+
+		if (c == NO_POLL_CHAR)
+			break;
+
+		s[num_read++] = c;
+	}
+
+	return num_read;
+}
+#endif
+
+static int __init xrarch_serial_earlycon_setup(struct earlycon_device *device,
+					       const char *options)
+{
+	if (!device->port.membase)
+		return -ENODEV;
+
+	device->con->write = xrarch_serial_earlycon_write;
+#ifdef CONFIG_CONSOLE_POLL
+	device->con->read = xrarch_serial_earlycon_read;
+#endif
+
+	return 0;
+}
+
+OF_EARLYCON_DECLARE(xrarch_serial, "xrarch,serial",
+		    xrarch_serial_earlycon_setup);
+
+MODULE_AUTHOR("monkuous");
+MODULE_DESCRIPTION("XR/arch UART support");
+MODULE_LICENSE("GPL");
diff -urN --no-dereference linux-clean/drivers/video/fbdev/Kconfig linux-workdir/drivers/video/fbdev/Kconfig
--- linux-clean/drivers/video/fbdev/Kconfig
+++ linux-workdir/drivers/video/fbdev/Kconfig
@@ -1819,6 +1819,13 @@
 	  called sm712fb. If you want to compile it as a module, say M
 	  here and read <file:Documentation/kbuild/modules.rst>.
 
+config FB_KINNOW
+	tristate "XR/arch Kinnow framebuffer support"
+	depends on FB && OF
+	select FB_IOMEM_HELPERS
+	help
+	  Frame buffer driver for the XR/arch Kinnow framebuffer device.
+
 source "drivers/video/fbdev/omap/Kconfig"
 source "drivers/video/fbdev/omap2/Kconfig"
 source "drivers/video/fbdev/mmp/Kconfig"
diff -urN --no-dereference linux-clean/drivers/video/fbdev/Makefile linux-workdir/drivers/video/fbdev/Makefile
--- linux-clean/drivers/video/fbdev/Makefile
+++ linux-workdir/drivers/video/fbdev/Makefile
@@ -114,6 +114,7 @@
 obj-$(CONFIG_FB_HYPERV)		  += hyperv_fb.o
 obj-$(CONFIG_FB_OPENCORES)	  += ocfb.o
 obj-$(CONFIG_FB_SM712)		  += sm712fb.o
+obj-$(CONFIG_FB_KINNOW)		  += kinnow.o
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
diff -urN --no-dereference linux-clean/drivers/video/fbdev/kinnow.c linux-workdir/drivers/video/fbdev/kinnow.c
--- linux-clean/drivers/video/fbdev/kinnow.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/video/fbdev/kinnow.c
@@ -0,0 +1,300 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/io.h>
+#include <linux/aperture.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#define KINNOW_REGS_OFFSET	0x3000
+#define KINNOW_REGS_SIZE	8
+
+#define KINNOW_DISPLAY_SIZE	0x00
+#define KINNOW_FEATURES		0x20
+
+#define KINNOW_FEATURE_PALETTE	0x01
+
+#define KINNOW_PALETTE_OFFSET	0x4000
+
+#define KINNOW_MEM_OFFSET	0x100000
+
+struct kinnowfb_par {
+	void __iomem *palette;
+};
+
+static const struct fb_fix_screeninfo kinnowfb_fix = {
+	.id	= "kinnow",
+	.type	= FB_TYPE_PACKED_PIXELS,
+	.visual	= FB_VISUAL_STATIC_PSEUDOCOLOR,
+	.accel	= FB_ACCEL_NONE,
+};
+
+static const struct fb_var_screeninfo kinnowfb_var = {
+	.height		= -1,
+	.width		= -1,
+	.activate	= FB_ACTIVATE_NOW,
+	.vmode		= FB_VMODE_NONINTERLACED,
+	.bits_per_pixel	= 8,
+	.red		= { 0, 8, 0 },
+	.green		= { 0, 8, 0 },
+	.blue		= { 0, 8, 0 },
+};
+
+static const u32 kinnowfb_palette[] = {
+	0x000000, 0x220022, 0x000044, 0x220066, 0x000088, 0x2200aa, 0x0000cc,
+	0x2200ee, 0x440000, 0x660022, 0x440044, 0x660066, 0x440088, 0x6600aa,
+	0x4400cc, 0x6600ee, 0x880000, 0xaa0022, 0x880044, 0xaa0066, 0x880088,
+	0xaa00aa, 0x8800cc, 0xaa00ee, 0xcc0000, 0xee0022, 0xcc0044, 0xee0066,
+	0xcc0088, 0xee00aa, 0xcc00cc, 0xee00ee, 0x002200, 0x222222, 0x002244,
+	0x222266, 0x002288, 0x2222aa, 0x0022cc, 0x2222ee, 0x442200, 0x662222,
+	0x442244, 0x662266, 0x442288, 0x6622aa, 0x4422cc, 0x6622ee, 0x882200,
+	0xaa2222, 0x882244, 0xaa2266, 0x882288, 0xaa22aa, 0x8822cc, 0xaa22ee,
+	0xcc2200, 0xee2222, 0xcc2244, 0xee2266, 0xcc2288, 0xee22aa, 0xcc22cc,
+	0xee22ee, 0x004400, 0x224422, 0x004444, 0x224466, 0x004488, 0x2244aa,
+	0x0044cc, 0x2244ee, 0x444400, 0x664422, 0x444444, 0x664466, 0x444488,
+	0x6644aa, 0x4444cc, 0x6644ee, 0x884400, 0xaa4422, 0x884444, 0xaa4466,
+	0x884488, 0xaa44aa, 0x8844cc, 0xaa44ee, 0xcc4400, 0xee4422, 0xcc4444,
+	0xee4466, 0xcc4488, 0xee44aa, 0xcc44cc, 0xee44ee, 0x006600, 0x226622,
+	0x006644, 0x226666, 0x006688, 0x2266aa, 0x0066cc, 0x2266ee, 0x446600,
+	0x666622, 0x446644, 0x666666, 0x446688, 0x6666aa, 0x4466cc, 0x6666ee,
+	0x886600, 0xaa6622, 0x886644, 0xaa6666, 0x886688, 0xaa66aa, 0x8866cc,
+	0xaa66ee, 0xcc6600, 0xee6622, 0xcc6644, 0xee6666, 0xcc6688, 0xee66aa,
+	0xcc66cc, 0xee66ee, 0x008800, 0x228822, 0x008844, 0x228866, 0x008888,
+	0x2288aa, 0x0088cc, 0x2288ee, 0x448800, 0x668822, 0x448844, 0x668866,
+	0x448888, 0x6688aa, 0x4488cc, 0x6688ee, 0x888800, 0xaa8822, 0x888844,
+	0xaa8866, 0x888888, 0xaa88aa, 0x8888cc, 0xaa88ee, 0xcc8800, 0xee8822,
+	0xcc8844, 0xee8866, 0xcc8888, 0xee88aa, 0xcc88cc, 0xee88ee, 0x00aa00,
+	0x22aa22, 0x00aa44, 0x22aa66, 0x00aa88, 0x22aaaa, 0x00aacc, 0x22aaee,
+	0x44aa00, 0x66aa22, 0x44aa44, 0x66aa66, 0x44aa88, 0x66aaaa, 0x44aacc,
+	0x66aaee, 0x88aa00, 0xaaaa22, 0x88aa44, 0xaaaa66, 0x88aa88, 0xaaaaaa,
+	0x88aacc, 0xaaaaee, 0xccaa00, 0xeeaa22, 0xccaa44, 0xeeaa66, 0xccaa88,
+	0xeeaaaa, 0xccaacc, 0xeeaaee, 0x00cc00, 0x22cc22, 0x00cc44, 0x22cc66,
+	0x00cc88, 0x22ccaa, 0x00cccc, 0x22ccee, 0x44cc00, 0x66cc22, 0x44cc44,
+	0x66cc66, 0x44cc88, 0x66ccaa, 0x44cccc, 0x66ccee, 0x88cc00, 0xaacc22,
+	0x88cc44, 0xaacc66, 0x88cc88, 0xaaccaa, 0x88cccc, 0xaaccee, 0xcccc00,
+	0xeecc22, 0xcccc44, 0xeecc66, 0xcccc88, 0xeeccaa, 0xcccccc, 0xeeccee,
+	0x00ee00, 0x22ee22, 0x00ee44, 0x22ee66, 0x00ee88, 0x22eeaa, 0x00eecc,
+	0x22eeee, 0x44ee00, 0x66ee22, 0x44ee44, 0x66ee66, 0x44ee88, 0x66eeaa,
+	0x44eecc, 0x66eeee, 0x88ee00, 0xaaee22, 0x88ee44, 0xaaee66, 0x88ee88,
+	0xaaeeaa, 0x88eecc, 0xaaeeee, 0xccee00, 0xeeee22, 0xccee44, 0xeeee66,
+	0xccee88, 0xeeeeaa, 0xcceecc, 0xffffff
+};
+
+static int kinnowfb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			      unsigned blue, unsigned transp,
+			      struct fb_info *info)
+{
+	struct kinnowfb_par *par = info->par;
+
+	if (!par->palette)
+		return 0;
+
+	if (regno >= ARRAY_SIZE(kinnowfb_palette))
+		return -EINVAL;
+
+	red >>= 8;
+	red &= 0xff;
+
+	green >>= 8;
+	green &= 0xff;
+
+	blue >>= 8;
+	blue &= 0xff;
+
+	unsigned value = (red << 16) | (green << 8) | blue;
+	writel(value, par->palette + regno * 4);
+
+	return 0;
+}
+
+static int kinnowfb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
+{
+	struct kinnowfb_par *par = info->par;
+
+	if (!par->palette)
+		return 0;
+
+	if (cmap->start + cmap->len < cmap->start
+	    || cmap->start + cmap->len >= ARRAY_SIZE(kinnowfb_palette))
+		return -EINVAL;
+
+	for (u32 i = 0; i < cmap->len; i++) {
+		u32 red = (cmap->red[i] >> 8) & 0xff;
+		u32 green = (cmap->green[i] >> 8) & 0xff;
+		u32 blue = (cmap->blue[i] >> 8) & 0xff;
+
+		u32 value = (red << 16) | (green << 8) | blue;
+		writel(value, par->palette + (cmap->start + i) * 4);
+	}
+
+	return 0;
+}
+
+static void kinnowfb_destroy(struct fb_info *info)
+{
+	struct kinnowfb_par *par = info->par;
+
+	fb_dealloc_cmap(&info->cmap);
+
+	if (par->palette)
+		iounmap(par->palette);
+
+	if (info->screen_base)
+		iounmap(info->screen_base);
+
+	framebuffer_release(info);
+}
+
+static const struct fb_ops kinnowfb_ops = {
+	.owner		= THIS_MODULE,
+	FB_DEFAULT_IOMEM_OPS,
+	.fb_setcolreg	= kinnowfb_setcolreg,
+	.fb_setcmap	= kinnowfb_setcmap,
+	.fb_destroy	= kinnowfb_destroy,
+};
+
+static u16 kinnowfb_translate_color(u8 color)
+{
+	return ((u16)color << 8) | color;
+}
+
+static int kinnowfb_probe(struct platform_device *pdev)
+{
+	if (fb_get_options("kinnowfb", NULL))
+		return -ENODEV;
+
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource\n");
+		return -EINVAL;
+	}
+
+	void __iomem *regs = ioremap(res->start + KINNOW_REGS_OFFSET,
+				     KINNOW_REGS_SIZE);
+	if (!regs) {
+		dev_err(&pdev->dev, "failed to map registers\n");
+		return -ENOMEM;
+	}
+
+	u32 display_size = readl(regs + KINNOW_DISPLAY_SIZE);
+	u32 width = display_size & 0xfff;
+	u32 height = (display_size >> 12) & 0xfff;
+	u32 features = readl(regs + KINNOW_FEATURES);
+
+	iounmap(regs);
+
+	int ret;
+	struct fb_info *info = framebuffer_alloc(sizeof(struct kinnowfb_par),
+						 &pdev->dev);
+	if (!info)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, info);
+
+	struct kinnowfb_par *par = info->par;
+
+	info->fix = kinnowfb_fix;
+	info->fix.smem_start = res->start + KINNOW_MEM_OFFSET;
+	info->fix.smem_len = width * height;
+	info->fix.line_length = width;
+
+	info->var = kinnowfb_var;
+	info->var.xres = width;
+	info->var.yres = height;
+	info->var.xres_virtual = width;
+	info->var.yres_virtual = height;
+
+	info->fbops = &kinnowfb_ops;
+	info->screen_base = ioremap_wc(info->fix.smem_start,
+				       info->fix.smem_len);
+	if (!info->screen_base) {
+		ret = -ENOMEM;
+		goto fail_free_info;
+	}
+
+	if (features & KINNOW_FEATURE_PALETTE) {
+		par->palette = ioremap(res->start + KINNOW_PALETTE_OFFSET,
+				       sizeof(kinnowfb_palette));
+
+		if (par->palette) {
+			for (int i = 0; i < ARRAY_SIZE(kinnowfb_palette); i++) {
+				writel(kinnowfb_palette[i],
+				       par->palette + i * 4);
+			}
+		} else {
+			// ioremap failure is not critical, it'll just make
+			// console colors incorrect
+			dev_warn(&pdev->dev, "failed to map palette");
+		}
+	}
+
+	if (!par->palette)
+		dev_warn(&pdev->dev,
+			 "palette is read-only, colors may be incorrect");
+
+	ret = fb_alloc_cmap(&info->cmap, ARRAY_SIZE(kinnowfb_palette), 0);
+	if (ret)
+		goto fail_free_info;
+
+	for (int i = 0; i < ARRAY_SIZE(kinnowfb_palette); i++) {
+		u32 color = kinnowfb_palette[i];
+		info->cmap.red[i] = kinnowfb_translate_color(color >> 16);
+		info->cmap.green[i] = kinnowfb_translate_color(color >> 8);
+		info->cmap.blue[i] = kinnowfb_translate_color(color);
+	}
+
+	dev_info(&pdev->dev, "%ux%u framebuffer at 0x%lx, 0x%x bytes\n",
+		 width, height, info->fix.smem_start, info->fix.smem_len);
+
+	ret = devm_aperture_acquire_for_platform_device(pdev,
+							info->fix.smem_start,
+							info->fix.smem_len);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to acquire aperture (%d)\n", ret);
+		goto fail_free_info;
+	}
+
+	ret = register_framebuffer(info);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "unable to register framebuffer (%d)\n",
+			ret);
+		goto fail_free_info;
+	}
+
+	return 0;
+
+fail_free_info:
+	framebuffer_release(info);
+	return ret;
+}
+
+static void kinnowfb_remove(struct platform_device *pdev)
+{
+	struct fb_info *info = platform_get_drvdata(pdev);
+
+	/* kinnowfb_destroy takes care of info cleanup */
+	unregister_framebuffer(info);
+}
+
+static const struct of_device_id kinnowfb_of_match[] = {
+	{ .compatible = "xrarch,expansion-4b494e36" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, kinnowfb_of_match);
+
+static struct platform_driver kinnowfb_driver = {
+	.driver	= {
+		.name		= "kinnow-framebuffer",
+		.of_match_table	= kinnowfb_of_match,
+	},
+	.probe	= kinnowfb_probe,
+	.remove	= kinnowfb_remove,
+};
+
+module_platform_driver(kinnowfb_driver);
+
+MODULE_AUTHOR("monkuous");
+MODULE_DESCRIPTION("XR/arch Kinnow framebuffer driver");
+MODULE_LICENSE("GPL");
diff -urN --no-dereference linux-clean/include/linux/amtsu.h linux-workdir/include/linux/amtsu.h
--- linux-clean/include/linux/amtsu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/include/linux/amtsu.h
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _LINUX_AMTSU_H
+#define _LINUX_AMTSU_H
+
+#include <linux/device.h>
+#include <linux/mod_devicetable.h>
+
+#define AMTSU_CMD_WRITE_A	0x1 /* write A before command */
+#define AMTSU_CMD_WRITE_B	0x2 /* write B before command */
+#define AMTSU_CMD_READ_A	0x4 /* read A after command */
+#define AMTSU_CMD_READ_B	0x8 /* read B after command */
+
+struct amtsu_device;
+
+/**
+ * struct amtsu_bus_ops - bus operations for an amtsu device
+ * @enable_irq: enable the irq of this device
+ * @disable_irq: disable the irq of this device
+ * @command: issue a command to this device
+ * 	dev: the amtsu_device
+ * 	cmd: the command to issue
+ * 	flags: bitset for operations to perform before and after the command
+ * 	a: location of the value of the A register
+ * 	b: location of the value of the B register
+ */
+struct amtsu_bus_ops {
+	void (*enable_irq)(struct amtsu_device *);
+	void (*disable_irq)(struct amtsu_device *);
+	void (*command)(struct amtsu_device *dev, u32 cmd, u32 flags, u32 *a,
+			u32 *b);
+};
+
+struct amtsu_device {
+	struct device dev;
+	struct amtsu_device_id id;
+	unsigned int idx;
+	int irq;
+	const struct amtsu_bus_ops *bus;
+	void *priv;
+};
+
+#define dev_to_amtsu(_dev)	container_of_const(_dev, struct amtsu_device, dev)
+
+struct amtsu_driver {
+	struct device_driver driver;
+	const struct amtsu_device_id *id_table;
+	int (*probe)(struct amtsu_device *);
+	void (*remove)(struct amtsu_device *);
+	void (*shutdown)(struct amtsu_device *);
+};
+
+#define drv_to_amtsu(_drv)	container_of_const(_drv, struct amtsu_driver, driver)
+
+#define amtsu_driver_register(drv) __amtsu_driver_register(drv, THIS_MODULE)
+int __amtsu_driver_register(struct amtsu_driver *driver, struct module *owner);
+void amtsu_driver_unregister(struct amtsu_driver *driver);
+
+#endif /* _LINUX_AMTSU_H */
diff -urN --no-dereference linux-clean/include/linux/mod_devicetable.h linux-workdir/include/linux/mod_devicetable.h
--- linux-clean/include/linux/mod_devicetable.h
+++ linux-workdir/include/linux/mod_devicetable.h
@@ -976,4 +976,14 @@
 	kernel_ulong_t driver_data;
 };
 
+/**
+ * struct amtsu_device_id - Amtsu device identifier
+ * @model_id: model ID
+ * @driver_id: driver specific data
+ */
+struct amtsu_device_id {
+	__u32 model_id;
+	kernel_ulong_t driver_data;
+};
+
 #endif /* LINUX_MOD_DEVICETABLE_H */
diff -urN --no-dereference linux-clean/include/uapi/linux/audit.h linux-workdir/include/uapi/linux/audit.h
--- linux-clean/include/uapi/linux/audit.h
+++ linux-workdir/include/uapi/linux/audit.h
@@ -444,6 +444,7 @@
 #define AUDIT_ARCH_TILEPRO	(EM_TILEPRO|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_UNICORE	(EM_UNICORE|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_XR17032	(EM_XR17032|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_XTENSA	(EM_XTENSA)
 #define AUDIT_ARCH_LOONGARCH32	(EM_LOONGARCH|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_LOONGARCH64	(EM_LOONGARCH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
diff -urN --no-dereference linux-clean/include/uapi/linux/elf-em.h linux-workdir/include/uapi/linux/elf-em.h
--- linux-clean/include/uapi/linux/elf-em.h
+++ linux-workdir/include/uapi/linux/elf-em.h
@@ -67,5 +67,8 @@
 /* Also Panasonic/MEI MN10300, AM33 */
 #define EM_CYGNUS_MN10300 0xbeef
 
+/* XR/17032 */
+#define EM_XR17032	0xb5f0
+
 
 #endif /* _LINUX_ELF_EM_H */
diff -urN --no-dereference linux-clean/include/uapi/linux/input.h linux-workdir/include/uapi/linux/input.h
--- linux-clean/include/uapi/linux/input.h
+++ linux-workdir/include/uapi/linux/input.h
@@ -275,6 +275,7 @@
 #define BUS_CEC			0x1E
 #define BUS_INTEL_ISHTP		0x1F
 #define BUS_AMD_SFH		0x20
+#define BUS_AMTSU		0x21
 
 /*
  * MT_TOOL types
