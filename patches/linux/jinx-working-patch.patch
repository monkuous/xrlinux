diff -urN --no-dereference linux-clean/arch/xr17032/Kbuild linux-workdir/arch/xr17032/Kbuild
--- linux-clean/arch/xr17032/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kbuild
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+obj-y += kernel/ mm/
+
+subdir- += boot/
diff -urN --no-dereference linux-clean/arch/xr17032/Kconfig linux-workdir/arch/xr17032/Kconfig
--- linux-clean/arch/xr17032/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kconfig
@@ -0,0 +1,35 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config XR17032
+	def_bool y
+	select GENERIC_ATOMIC64
+	select THREAD_INFO_IN_TASK
+	select HAVE_PAGE_SIZE_4KB
+	select ARCH_SPARSEMEM_ENABLE
+	select GENERIC_IOREMAP
+	select FUNCTION_ALIGNMENT_4B
+	select GENERIC_IRQ_SHOW
+	select GENERIC_LIB_ASHLDI3
+	select GENERIC_LIB_LSHRDI3
+	select GENERIC_LIB_MULDI3
+	select OF
+	select OF_EARLY_FLATTREE
+	select GENERIC_EARLY_IOREMAP
+
+config MMU
+	def_bool y
+
+config GENERIC_CALIBRATE_DELAY
+	def_bool y
+
+config GENERIC_HWEIGHT
+	def_bool y
+
+config FIX_EARLYCON_MEM
+	def_bool MMU
+
+menu "Kernel features"
+
+source "kernel/Kconfig.hz"
+
+endmenu
diff -urN --no-dereference linux-clean/arch/xr17032/Kconfig.debug linux-workdir/arch/xr17032/Kconfig.debug
--- linux-clean/arch/xr17032/Kconfig.debug	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kconfig.debug
@@ -0,0 +1 @@
+# SPDX-License-Identifier: GPL-2.0-only
diff -urN --no-dereference linux-clean/arch/xr17032/Makefile linux-workdir/arch/xr17032/Makefile
--- linux-clean/arch/xr17032/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Makefile
@@ -0,0 +1,36 @@
+# This file is included by the global makefile so that you can add your own
+# architecture-specific flags and dependencies.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+
+KBUILD_DEFCONFIG	:= xr17032_defconfig
+
+UTS_MACHINE	:= xr17032
+
+KBUILD_CFLAGS	+= -fno-pic
+
+libs-y		+= arch/xr17032/lib/
+
+boot		:= arch/xr17032/boot
+KBUILD_IMAGE	:= $(boot)/Image
+
+BOOT_TARGETS	:= Image
+
+$(BOOT_TARGETS): vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
+	@$(kecho) '  Kernel: $(boot)/$@ is ready'
+
+all: $(notdir $(KBUILD_IMAGE))
+
+install:
+	$(call cmd,install)
+
+define archhelp
+  echo  '  Image	- Uncompressed kernel image (arch/xr17032/boot/Image)'
+  echo  '  install	- Install kernel using (your) ~/bin/$(INSTALLKERNEL) or'
+  echo  '		  (distribution) /sbin/$(INSTALLKERNEL) or install to '
+  echo  '		  $$(INSTALL_PATH)'
+endef
diff -urN --no-dereference linux-clean/arch/xr17032/boot/Makefile linux-workdir/arch/xr17032/boot/Makefile
--- linux-clean/arch/xr17032/boot/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/boot/Makefile
@@ -0,0 +1,24 @@
+#
+# arch/riscv/boot/Makefile
+#
+# This file is included by the global makefile so that you can add your own
+# architecture-specific flags and dependencies.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 2025, monkuous.
+# Author: monkuous
+#
+
+OBJCOPYFLAGS_Image := -O binary -R .note -R .note.gnu.build-id -R .comment -S
+
+targets := Image
+
+ifdef CONFIG_RELOCATABLE
+$(obj)/Image: vmlinux.unstripped FORCE
+else
+$(obj)/Image: vmlinux FORCE
+endif
+	$(call if_changed,objcopy)
diff -urN --no-dereference linux-clean/arch/xr17032/configs/xr17032_defconfig linux-workdir/arch/xr17032/configs/xr17032_defconfig
--- linux-clean/arch/xr17032/configs/xr17032_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/configs/xr17032_defconfig
@@ -0,0 +1 @@
+CONFIG_SERIAL_XRCOMPUTER=y
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/Kbuild linux-workdir/arch/xr17032/include/asm/Kbuild
--- linux-clean/arch/xr17032/include/asm/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/Kbuild
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+generic-y += string.h
+generic-y += user.h
+generic-y += kvm_para.h
+generic-y += vmlinux.lds.h
+generic-y += early_ioremap.h
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/asm-extable.h linux-workdir/arch/xr17032/include/asm/asm-extable.h
--- linux-clean/arch/xr17032/include/asm/asm-extable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/asm-extable.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ASM_EXTABLE_H
+#define _ASM_XR17032_ASM_EXTABLE_H
+
+#define EX_TYPE_NONE			0
+#define EX_TYPE_FIXUP			1
+#define EX_TYPE_UACCESS_ERR_ZERO	2
+
+#include <linux/bits.h>
+#include <linux/stringify.h>
+#include <asm/gpr-num.h>
+
+#define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
+	".pushsection	__ex_table, \"a\"\n"		\
+	".balign	4\n"				\
+	".long		(" insn ")\n"		\
+	".long		(" fixup ")\n"		\
+	".short		(" type ")\n"			\
+	".short		(" data ")\n"			\
+	".popsection\n"
+
+#define _ASM_EXTABLE(insn, fixup)	\
+	__ASM_EXTABLE_RAW(#insn, #fixup, __stringify(EX_TYPE_FIXUP), "0")
+
+#define EX_DATA_REG_ERR_SHIFT	0
+#define EX_DATA_REG_ERR		GENMASK(4, 0)
+#define EX_DATA_REG_ZERO_SHIFT	5
+#define EX_DATA_REG_ZERO	GENMASK(9, 5)
+
+#define EX_DATA_REG_DATA_SHIFT	0
+#define EX_DATA_REG_DATA	GENMASK(4, 0)
+#define EX_DATA_REG_ADDR_SHIFT	5
+#define EX_DATA_REG_ADDR	GENMASK(9, 5)
+
+#define EX_DATA_REG(reg, gpr)						\
+	"((.L__gpr_num_" #gpr ") << " __stringify(EX_DATA_REG_##reg##_SHIFT) ")"
+
+#define _ASM_EXTABLE_UACCESS_ERR_ZERO(insn, fixup, err, zero)		\
+	__DEFINE_ASM_GPR_NUMS						\
+	__ASM_EXTABLE_RAW(#insn, #fixup, 				\
+			  __stringify(EX_TYPE_UACCESS_ERR_ZERO),	\
+			  "("						\
+			    EX_DATA_REG(ERR, err) " | "			\
+			    EX_DATA_REG(ZERO, zero)			\
+			  ")")
+
+#define _ASM_EXTABLE_UACCESS_ERR(insn, fixup, err)			\
+	_ASM_EXTABLE_UACCESS_ERR_ZERO(insn, fixup, err, zero)
+
+#endif /* _ASM_XR17032_ASM_EXTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/atomic.h linux-workdir/arch/xr17032/include/asm/atomic.h
--- linux-clean/arch/xr17032/include/asm/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/atomic.h
@@ -0,0 +1,111 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ATOMIC_H
+#define _ASM_XR17032_ATOMIC_H
+
+#ifndef CONFIG_GENERIC_ATOMIC64
+#error "xr17032 does not support 64-bit atomics"
+#endif
+
+#include <asm/cmpxchg.h>
+#include <asm-generic/atomic64.h>
+
+static inline int arch_atomic_read(const atomic_t *v)
+{
+	return READ_ONCE(v->counter);
+}
+
+static inline void arch_atomic_set(atomic_t *v, int i)
+{
+	WRITE_ONCE(v->counter, i);
+}
+
+#define __ATOMIC_OP(op, asm_op)						\
+static inline void arch_atomic_##op(int i, atomic_t *v)			\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %0, %0, %z3\n"			\
+		"	sc  %1, %2, %0\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+}
+
+#define __ATOMIC_OP_RETURN(op, asm_op)					\
+static inline int arch_atomic_##op##_return_relaxed(int i, atomic_t *v)	\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %0, %0, %z3\n"			\
+		"	sc  %1, %2, %0\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+									\
+	return ret;							\
+}
+
+#define __ATOMIC_FETCH_OP(op, asm_op)					\
+static inline int arch_atomic_fetch_##op##_relaxed(int i, atomic_t *v)	\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %1, %0, %z3\n"			\
+		"	sc  %1, %2, %1\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+									\
+	return ret;							\
+}
+
+__ATOMIC_OP_RETURN(add, "add")
+__ATOMIC_OP_RETURN(sub, "sub")
+
+__ATOMIC_FETCH_OP(add, "add")
+__ATOMIC_FETCH_OP(sub, "sub")
+__ATOMIC_FETCH_OP(and, "and")
+__ATOMIC_FETCH_OP(or, "or")
+__ATOMIC_FETCH_OP(xor, "xor")
+
+__ATOMIC_OP(add, "add")
+__ATOMIC_OP(sub, "sub")
+__ATOMIC_OP(and, "and")
+__ATOMIC_OP(or, "or")
+__ATOMIC_OP(xor, "xor")
+
+#define arch_atomic_add_return_relaxed arch_atomic_add_return_relaxed
+#define arch_atomic_sub_return_relaxed arch_atomic_sub_return_relaxed
+
+#define arch_atomic_fetch_add_relaxed arch_atomic_fetch_add_relaxed
+#define arch_atomic_fetch_sub_relaxed arch_atomic_fetch_sub_relaxed
+#define arch_atomic_fetch_and_relaxed arch_atomic_fetch_and_relaxed
+#define arch_atomic_fetch_or_relaxed  arch_atomic_fetch_or_relaxed
+#define arch_atomic_fetch_xor_relaxed arch_atomic_fetch_xor_relaxed
+
+#define arch_atomic_add arch_atomic_add
+#define arch_atomic_sub arch_atomic_sub
+#define arch_atomic_and arch_atomic_and
+#define arch_atomic_or  arch_atomic_or
+#define arch_atomic_xor arch_atomic_xor
+
+#endif /* _ASM_XR17032_ATOMIC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/barrier.h linux-workdir/arch/xr17032/include/asm/barrier.h
--- linux-clean/arch/xr17032/include/asm/barrier.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/barrier.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_BARRIER_H
+#define _ASM_XR17032_BARRIER_H
+
+#define nop()	({asm volatile("addi zero, zero, 0");})
+
+#define __mb()	({asm volatile("mb");})
+#define __wmb()	({asm volatile("wmb");})
+#define __rmb()	({asm volatile("mb");})
+
+#include <asm-generic/barrier.h>
+
+#endif /* _ASM_XR17032_BARRIER_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cache.h linux-workdir/arch/xr17032/include/asm/cache.h
--- linux-clean/arch/xr17032/include/asm/cache.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cache.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CACHE_H
+#define _ASM_XR17032_CACHE_H
+
+#define L1_CACHE_SHIFT 4
+#define L1_CACHE_BYTES (1 << L1_CACHE_SHIFT)
+
+#endif /* _ASM_XR17032_CACHE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cmpxchg.h linux-workdir/arch/xr17032/include/asm/cmpxchg.h
--- linux-clean/arch/xr17032/include/asm/cmpxchg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cmpxchg.h
@@ -0,0 +1,137 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CMPXCHG_H
+#define _ASM_XR17032_CMPXCHG_H
+
+#include <linux/bug.h>
+
+#define __arch_xchg_masked(mask, ret, scratch, ptr, new)		\
+({									\
+	unsigned long __address = (unsigned long)ptr;			\
+	unsigned long __offset = __address & 3;				\
+	unsigned long __shift = __offset * 8;				\
+	unsigned long __mask = mask << __shift;				\
+	unsigned long __new_shift = (unsigned long)new << __shift;	\
+	unsigned long __ret_shift;					\
+	__address -= __offset;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	and %1, %0, %z3\n"				\
+		"	or  %1, %1, %z4\n"				\
+		"	sc  %1, %2, %1\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (__ret_shift), "=&r" (scratch)			\
+		: "r" (__address), "rO" (~__mask), "rO" (__new_shift)	\
+		: "memory"						\
+	);								\
+									\
+	ret = (typeof(ret))((__ret_shift & __mask) >> __shift);		\
+})
+
+#define arch_xchg_relaxed(ptr, new)					\
+({									\
+	typeof(ptr) __ptr = (ptr);					\
+	typeof(*__ptr) __new = (new);					\
+	typeof(*__ptr) __ret;						\
+	unsigned long __scratch;					\
+									\
+	switch (sizeof(*__ptr)) {					\
+	case 1:								\
+		__arch_xchg_masked(0xff, __ret, __scratch, __ptr,	\
+				   __new); 				\
+		break;							\
+	case 2:								\
+		__arch_xchg_masked(0xffff, __ret, __scratch, __ptr,	\
+				   __new); 				\
+		break;							\
+	case 4:								\
+		asm volatile(						\
+			"1:	ll  %0, %2\n"				\
+			"	sc  %1, %2, %z3\n"			\
+			"	beq %1, 1b"				\
+			: "=&r" (__ret), "=&r" (__scratch)		\
+			: "r" (__ptr), "rO" (__new)			\
+			: "memory"					\
+		);							\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+									\
+	__ret;								\
+})
+
+#define __arch_cmpxchg_masked(mask, ret, scratch, ptr, old, new)	\
+({									\
+	unsigned long __address = (unsigned long)ptr;			\
+	unsigned long __offset = __address & 3;				\
+	unsigned long __shift = __offset * 8;				\
+	unsigned long __mask = mask << __shift;				\
+	unsigned long __old_shift = (unsigned long)old << __shift;	\
+	unsigned long __new_shift = (unsigned long)new << __shift;	\
+	unsigned long __ret_shift;					\
+	unsigned long __scratch2;					\
+	__address -= __offset;						\
+									\
+	asm volatile(							\
+		"1:	ll  %1, %3\n"					\
+		"	and %0, %1, %z4\n"				\
+		"	sub %2, %0, %z5\n"				\
+		"	bne %2, 1f\n"					\
+		"	and %1, %1, %z6\n"				\
+		"	or  %1, %1, %z7\n"				\
+		"	sc  %1, %3, %1\n"				\
+		"	beq %1, 1b\n"					\
+		"1:"							\
+		: "=&r" (__ret_shift), "=&r" (scratch),			\
+		  "=&r" (__scratch2)					\
+		: "r" (__address), "rO" (__mask), "rO" (__old_shift),	\
+		  "rO" (~__mask), "rO" (__new_shift)			\
+		: "memory"						\
+	);								\
+									\
+	ret = (typeof(ret))(__ret_shift >> __shift);			\
+})
+
+#define arch_cmpxchg_relaxed(ptr, old, new)				\
+({									\
+	typeof(ptr) __ptr = (ptr);					\
+	typeof(*__ptr) __old = (old);					\
+	typeof(*__ptr) __new = (new);					\
+	typeof(*__ptr) __ret;						\
+	unsigned long __scratch;					\
+									\
+	switch (sizeof(*__ptr)) {					\
+	case 1:								\
+		__arch_cmpxchg_masked(0xff, __ret, __scratch, __ptr,	\
+				      __old, __new);			\
+		break;							\
+	case 2:								\
+		__arch_cmpxchg_masked(0xffff, __ret, __scratch, __ptr,	\
+				      __old, __new);			\
+		break;							\
+	case 4:								\
+		asm volatile(						\
+			"1:	ll  %0, %2\n"				\
+			"	sub %1, %0, %z3\n"			\
+			"	bne %1, 1f\n"				\
+			"	sc  %1, %2, %z4\n"			\
+			"	beq %1, 1b\n"				\
+			"1:"						\
+			: "=&r" (__ret), "=&r" (__scratch)		\
+			: "r" (__ptr), "rO" (__old), "rO" (__new)	\
+			: "memory"					\
+		);							\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+									\
+	__ret;								\
+})
+
+#endif /* _ASM_XR17032_CMPXCHG_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cr.h linux-workdir/arch/xr17032/include/asm/cr.h
--- linux-clean/arch/xr17032/include/asm/cr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cr.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CR_H
+#define _ASM_XR17032_CR_H
+
+#define RS_U 0x00000001UL
+#define RS_I 0x00000002UL
+#define RS_M 0x00000004UL
+#define RS_T 0x00000008UL
+
+#define cr_read(cr) 			\
+({ 					\
+	unsigned long __v; 		\
+	asm volatile("mfcr %0, " #cr	\
+		     : "=r" (__v) :	\
+		     : "memory"); 	\
+	__v;				\
+})
+
+#define cr_write(cr, val)				\
+({							\
+	unsigned long __v = (unsigned long)(val);	\
+	asm volatile("mtcr " #cr ", %z0"		\
+		     : : "rO" (__v)			\
+		     : "memory");			\
+})
+
+#endif /* _ASM_XR17032_CR_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/current.h linux-workdir/arch/xr17032/include/asm/current.h
--- linux-clean/arch/xr17032/include/asm/current.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/current.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CURRENT_H
+#define _ASM_XR17032_CURRENT_H
+
+struct task_struct;
+
+register struct task_struct *current asm("tp");
+
+#endif /* _ASM_XR17032_CURRENT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/elf.h linux-workdir/arch/xr17032/include/asm/elf.h
--- linux-clean/arch/xr17032/include/asm/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/elf.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ELF_H
+#define _ASM_XR17032_ELF_H
+
+#include <uapi/asm/elf.h>
+
+#define ELF_ARCH	EM_XR17032
+
+#ifndef ELF_CLASS
+#define ELF_CLASS	ELFCLASS32
+#endif
+
+#define ELF_DATA	ELFDATA2LSB
+
+#define ELF_EXEC_PAGESIZE	PAGE_SIZE
+#define ELF_PLATFORM		NULL
+#define ELF_HWCAP		0
+
+#define elf_check_arch(x) (((x)->e_machine == ELF_ARCH) &&		\
+			   ((x)->e_ident[EI_CLASS] == ELF_CLASS))
+
+#define ELF_ET_DYN_BASE		((DEFAULT_MAP_WINDOW / 3) * 2)
+
+#endif /* _ASM_XR17032_ELF_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/extable.h linux-workdir/arch/xr17032/include/asm/extable.h
--- linux-clean/arch/xr17032/include/asm/extable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/extable.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_EXTABLE_H
+#define _ASM_XR17032_EXTABLE_H
+
+struct exception_table_entry {
+	unsigned long insn, fixup;
+	short type, data;
+};
+
+#endif /* _ASM_XR17032_EXTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/fixmap.h linux-workdir/arch/xr17032/include/asm/fixmap.h
--- linux-clean/arch/xr17032/include/asm/fixmap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/fixmap.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_FIXMAP_H
+#define _ASM_XR17032_FIXMAP_H
+
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <linux/sizes.h>
+
+enum fixed_addresses {
+	FIX_HOLE,
+
+	FIX_EARLYCON_MEM_BASE,
+	FIX_PTE,
+
+	__end_of_permanent_fixed_addresses,
+	/*
+	 * Temporary boot-time mappings, used by early_ioremap(),
+	 * before ioremap() is functional.
+	 */
+	#define NR_FIX_BTMAPS		(SZ_256K / PAGE_SIZE)
+	#define FIX_BTMAPS_SLOTS	7
+	#define TOTAL_FIX_BTMAPS	(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)
+
+	FIX_BTMAP_END = __end_of_permanent_fixed_addresses,
+	FIX_BTMAP_BEGIN = FIX_BTMAP_END + TOTAL_FIX_BTMAPS - 1,
+
+	__end_of_fixed_addresses
+};
+
+#define __early_set_fixmap	__set_fixmap
+
+extern void __set_fixmap(enum fixed_addresses idx,
+			 phys_addr_t phys, pgprot_t prot);
+
+#include <asm-generic/fixmap.h>
+
+#endif /* _ASM_XR17032_FIXMAP_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/gpr-num.h linux-workdir/arch/xr17032/include/asm/gpr-num.h
--- linux-clean/arch/xr17032/include/asm/gpr-num.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/gpr-num.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_GPR_NUM_H
+#define _ASM_XR17032_GPR_NUM_H
+
+#define __DEFINE_ASM_GPR_NUMS					\
+"	.equ	.L__gpr_num_zero,	0\n"			\
+"	.equ	.L__gpr_num_t0,		1\n"			\
+"	.equ	.L__gpr_num_t1,		2\n"			\
+"	.equ	.L__gpr_num_t2,		3\n"			\
+"	.equ	.L__gpr_num_t3,		4\n"			\
+"	.equ	.L__gpr_num_t4,		5\n"			\
+"	.equ	.L__gpr_num_t5,		6\n"			\
+"	.equ	.L__gpr_num_a0,		7\n"			\
+"	.equ	.L__gpr_num_a1,		8\n"			\
+"	.equ	.L__gpr_num_a2,		9\n"			\
+"	.equ	.L__gpr_num_a3,		10\n"			\
+"	.equ	.L__gpr_num_s0,		11\n"			\
+"	.equ	.L__gpr_num_s1,		12\n"			\
+"	.equ	.L__gpr_num_s2,		13\n"			\
+"	.equ	.L__gpr_num_s3,		14\n"			\
+"	.equ	.L__gpr_num_s4,		15\n"			\
+"	.equ	.L__gpr_num_s5,		16\n"			\
+"	.equ	.L__gpr_num_s6,		17\n"			\
+"	.equ	.L__gpr_num_s7,		18\n"			\
+"	.equ	.L__gpr_num_s8,		19\n"			\
+"	.equ	.L__gpr_num_s9,		20\n"			\
+"	.equ	.L__gpr_num_s10,	21\n"			\
+"	.equ	.L__gpr_num_s11,	22\n"			\
+"	.equ	.L__gpr_num_s12,	23\n"			\
+"	.equ	.L__gpr_num_s13,	24\n"			\
+"	.equ	.L__gpr_num_s14,	25\n"			\
+"	.equ	.L__gpr_num_s15,	26\n"			\
+"	.equ	.L__gpr_num_s16,	27\n"			\
+"	.equ	.L__gpr_num_t17,	28\n"			\
+"	.equ	.L__gpr_num_tp,		29\n"			\
+"	.equ	.L__gpr_num_sp,		30\n"			\
+"	.equ	.L__gpr_num_lr,		31\n"
+
+#endif /* _ASM_XR17032_GPR_NUM_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/irqflags.h linux-workdir/arch/xr17032/include/asm/irqflags.h
--- linux-clean/arch/xr17032/include/asm/irqflags.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/irqflags.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_IRQFLAGS_H
+#define _ASM_XR17032_IRQFLAGS_H
+
+#include <asm/cr.h>
+
+static inline unsigned long arch_local_save_flags(void)
+{
+	return cr_read(rs);
+}
+
+static inline void arch_local_irq_restore(unsigned long flags)
+{
+	cr_write(rs, cr_read(rs) | (flags & RS_I));
+}
+
+static inline void arch_local_irq_enable(void)
+{
+	arch_local_irq_restore(RS_I);
+}
+
+static inline void arch_local_irq_disable(void)
+{
+	arch_local_irq_restore(0);
+}
+
+static inline unsigned long arch_local_irq_save(void)
+{
+	unsigned long flags = cr_read(rs);
+	cr_write(rs, flags & ~RS_I);
+	return flags;
+}
+
+static inline int arch_irqs_disabled_flags(unsigned long flags)
+{
+	return !(flags & RS_I);
+}
+
+static inline int arch_irqs_disabled(void)
+{
+	return arch_irqs_disabled_flags(arch_local_save_flags());
+}
+
+#endif /* _ASM_XR17032_IRQFLAGS_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/mmu_context.h linux-workdir/arch/xr17032/include/asm/mmu_context.h
--- linux-clean/arch/xr17032/include/asm/mmu_context.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/mmu_context.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_MMU_CONTEXT_H
+#define _ASM_XR17032_MMU_CONTEXT_H
+
+#include <linux/mm_types.h>
+#include <asm-generic/mm_hooks.h>
+
+#include <linux/mm.h>
+#include <linux/sched.h>
+
+void switch_mm(struct mm_struct *prev, struct mm_struct *next,
+	       struct task_struct *task);
+
+#include <asm-generic/mmu_context.h>
+
+#endif /* _ASM_XR17032_MMU_CONTEXT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/page.h linux-workdir/arch/xr17032/include/asm/page.h
--- linux-clean/arch/xr17032/include/asm/page.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/page.h
@@ -0,0 +1,84 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PAGE_H
+#define _ASM_XR17032_PAGE_H
+
+#include <linux/pfn.h>
+#include <vdso/page.h>
+
+#define PAGE_OFFSET		_AC(0xc0000000, UL)
+#define TASK_SIZE		_AC(0x80000000, UL)
+#define _PGTABLE_ADDR		TASK_SIZE
+
+#ifndef __ASSEMBLER__
+
+#define clear_page(pgaddr)			memset((pgaddr), 0, PAGE_SIZE)
+#define clear_user_page(pgaddr, vaddr, page)	clear_page(pgaddr)
+
+#define copy_page(to, from)			memcpy((to), (from), PAGE_SIZE)
+#define copy_user_page(vto, vfrom, vaddr, topg)	\
+			memcpy((vto), (vfrom), PAGE_SIZE)
+
+typedef struct {
+	unsigned long pgd;
+} pgd_t;
+
+typedef struct {
+	unsigned long pte;
+} pte_t;
+
+typedef struct {
+	unsigned long pgprot;
+} pgprot_t;
+
+typedef struct page *pgtable_t;
+
+#define pte_val(x)	((x).pte)
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x)	((pte_t) { (x) })
+#define __pgd(x)	((pgd_t) { (x) })
+#define __pgprot(x)	((pgprot_t) { (x) })
+
+#define is_linear_mapping(x)	((x) >= PAGE_OFFSET)
+
+#define linear_mapping_va_to_pa(x)	((unsigned long)(x) - PAGE_OFFSET)
+#define kernel_mapping_va_to_pa(x)					\
+({									\
+	unsigned long _y = ((unsigned long)(x) >> 10) & ~3UL;		\
+	_y |= _PGTABLE_ADDR;						\
+	_y = *(unsigned long *)_y;					\
+	(_y & ~0x1fUL) << 7;						\
+})
+
+#define __pa(x)								\
+({									\
+	unsigned long _x = (unsigned long)(x);				\
+	is_linear_mapping(_x) ? linear_mapping_va_to_pa(_x) 		\
+			      : kernel_mapping_va_to_pa(_x);		\
+})
+#define __va(x)	((void *)((unsigned long)(x) + PAGE_OFFSET))
+
+#define phys_to_pfn(phys)	(PFN_DOWN(phys))
+
+#define virt_to_pfn(vaddr)	(phys_to_pfn(__pa(vaddr)))
+
+#define virt_to_page(vaddr)	(pfn_to_page(virt_to_pfn(vaddr)))
+
+#define virt_addr_valid(vaddr)	({						\
+	unsigned long _addr = (unsigned long)vaddr;				\
+	(unsigned long)(_addr) >= PAGE_OFFSET && pfn_valid(virt_to_pfn(_addr));	\
+})
+
+#define PTE_FMT	"%08lx"
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#include <asm-generic/memory_model.h>
+#include <asm-generic/getorder.h>
+
+#endif /* _ASM_XR17032_PAGE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/pgalloc.h linux-workdir/arch/xr17032/include/asm/pgalloc.h
--- linux-clean/arch/xr17032/include/asm/pgalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/pgalloc.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PGALLOC_H
+#define _ASM_XR17032_PGALLOC_H
+
+#include <linux/mm.h>
+#include <asm/tlb.h>
+#include <asm-generic/pgalloc.h>
+
+static inline void sync_kernel_mappings(pgd_t *pgd)
+{
+	memcpy(pgd + USER_PTRS_PER_PGD,
+	       init_mm.pgd + USER_PTRS_PER_PGD,
+	       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
+}
+
+static inline pgd_t *pgd_alloc(struct mm_struct *mm)
+{
+	pgd_t *pgd;
+
+	pgd = __pgd_alloc(mm, 0);
+	if (likely(pgd != NULL)) {
+		/* Copy kernel mappings */
+		sync_kernel_mappings(pgd);
+	}
+	return pgd;
+}
+
+static inline void __pte_free_tlb(struct mmu_gather *tlb, pgtable_t pte,
+				  unsigned long addr)
+{
+	tlb_remove_ptdesc(tlb, page_ptdesc(pte));
+}
+
+static inline void pmd_populate_kernel(struct mm_struct *mm,
+				       pmd_t *pmd, pte_t *pte)
+{
+	unsigned long pfn = virt_to_pfn(pte);
+
+	set_pmd(pmd, __pmd((pfn << PFN_PTE_SHIFT) | _PAGE_TABLE));
+}
+
+static inline void pmd_populate(struct mm_struct *mm,
+				pmd_t *pmd, pgtable_t pte)
+{
+	unsigned long pfn = virt_to_pfn(page_address(pte));
+
+	set_pmd(pmd, __pmd((pfn << PFN_PTE_SHIFT) | _PAGE_TABLE));
+}
+
+#endif /* _ASM_XR17032_PGALLOC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/pgtable.h linux-workdir/arch/xr17032/include/asm/pgtable.h
--- linux-clean/arch/xr17032/include/asm/pgtable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/pgtable.h
@@ -0,0 +1,304 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PGTABLE_H
+#define _ASM_XR17032_PGTABLE_H
+
+#include <asm/page.h>
+#include <linux/const.h>
+
+#define PGDIR_SHIFT	22
+#define PGDIR_SIZE	(_AC(1, UL) << PGDIR_SHIFT)
+#define PGDIR_MASK	(~(PGDIR_SIZE - 1))
+
+#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
+#define _PGD_ADDR		(_PGTABLE_ADDR | (_PGTABLE_ADDR >> 10))
+#define _SWAPPER_PGD_ADDR	(_PGTABLE_ADDR + PGDIR_SIZE)
+#define KERNEL_LINK_ADDR	(_SWAPPER_PGD_ADDR + PAGE_SIZE)
+
+#define PTRS_PER_PGD	(PAGE_SIZE / 4)
+#define PTRS_PER_PTE	(PAGE_SIZE / 4)
+
+#define KERN_VIRT_SIZE	((PTRS_PER_PGD / 2 * PGDIR_SIZE) / 2)
+
+#define VMALLOC_SIZE	(KERN_VIRT_SIZE >> 1)
+#define VMALLOC_END	PAGE_OFFSET
+#define VMALLOC_START	(PAGE_OFFSET - VMALLOC_SIZE)
+
+#define FIXADDR_TOP	VMALLOC_START
+#define FIXADDR_SIZE	PGDIR_SIZE
+#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
+
+#ifndef __ASSEMBLER__
+
+#include <asm/tlbflush.h>
+#include <asm-generic/pgtable-nopmd.h>
+#include <linux/mmzone.h>
+
+#define PFN_PTE_SHIFT	5
+
+#define _PAGE_PRESENT	(1 << 0)
+#define _PAGE_WRITE	(1 << 1)
+#define _PAGE_KERNEL	(1 << 2)
+#define _PAGE_NO_CACHE	(1 << 3)
+#define _PAGE_GLOBAL	(1 << 4)
+#define _PAGE_ACCESSED	(1 << 25)
+#define _PAGE_DIRTY	(1 << 26)
+
+#define _PAGE_CHG_MASK  (~(unsigned long)(_PAGE_PRESENT | _PAGE_WRITE |	\
+					  _PAGE_KERNEL | _PAGE_GLOBAL))
+
+#define _PAGE_PROT_NONE	_PAGE_GLOBAL
+
+#define _PAGE_BASE	(_PAGE_PRESENT | _PAGE_ACCESSED)
+
+#define PAGE_NONE	__pgprot(_PAGE_PROT_NONE)
+#define PAGE_READ	__pgprot(_PAGE_BASE)
+#define PAGE_WRITE	__pgprot(_PAGE_BASE | _PAGE_WRITE)
+#define PAGE_EXEC	__pgprot(_PAGE_BASE)
+#define PAGE_READ_EXEC	__pgprot(_PAGE_BASE)
+#define PAGE_WRITE_EXEC	__pgprot(_PAGE_BASE | _PAGE_WRITE)
+
+#define PAGE_COPY		PAGE_READ
+#define PAGE_COPY_EXEC		PAGE_READ_EXEC
+#define PAGE_SHARED		PAGE_WRITE
+#define PAGE_SHARED_EXEC	PAGE_WRITE_EXEC
+
+#define _PAGE_SWP_EXCLUSIVE (1 << 5)
+
+#define _PAGE_KERNEL_BASE	(_PAGE_PRESENT \
+				| _PAGE_WRITE \
+				| _PAGE_KERNEL \
+				| _PAGE_GLOBAL \
+				| _PAGE_ACCESSED \
+				| _PAGE_DIRTY)
+
+#define _PAGE_TABLE		_PAGE_KERNEL_BASE
+#define _PAGE_IOREMAP		(_PAGE_KERNEL_BASE | _PAGE_NO_CACHE)
+
+#define PAGE_KERNEL		__pgprot(_PAGE_KERNEL_BASE)
+#define PAGE_KERNEL_READ	__pgprot(_PAGE_KERNEL_BASE & ~_PAGE_WRITE)
+#define PAGE_KERNEL_EXEC	__pgprot(_PAGE_KERNEL_BASE)
+#define PAGE_KERNEL_READ_EXEC	__pgprot(_PAGE_KERNEL_BASE & ~_PAGE_WRITE)
+#define PAGE_KERNEL_IO		__pgprot(_PAGE_IOREMAP)
+#define PAGE_TABLE		__pgprot(_PAGE_TABLE)
+
+#define __page_val_to_pfn(_val)  (((_val) & GENMASK(24, 5)) >> PFN_PTE_SHIFT)
+
+#define swapper_pg_dir ((pgd_t *)_SWAPPER_PGD_ADDR)
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero,
+ * used for zero-mapped memory areas, etc.
+ */
+extern unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)];
+#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
+
+#define pgd_ERROR(e) \
+	pr_err("%s:%d: bad pgd " PTE_FMT ".\n", __FILE__, __LINE__, pgd_val(e))
+
+static inline pte_t pfn_pte(unsigned long pfn, pgprot_t prot)
+{
+	return __pte((pfn << PFN_PTE_SHIFT) | pgprot_val(prot));
+}
+
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{
+	return __pte((pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot));
+}
+
+static inline int pte_present(pte_t pte)
+{
+	return pte_val(pte) & (_PAGE_PRESENT | _PAGE_PROT_NONE);
+}
+
+static inline int pte_none(pte_t pte)
+{
+	return pte_val(pte) == 0;
+}
+
+static inline int pte_write(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_WRITE;
+}
+
+static inline int pte_young(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_ACCESSED;
+}
+
+static inline int pte_dirty(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_DIRTY;
+}
+
+static inline unsigned long pte_pfn(pte_t pte)
+{
+	return __page_val_to_pfn(pte_val(pte));
+}
+
+#define pte_page(x)	pfn_to_page(pte_pfn(x))
+
+static inline pte_t pte_mkold(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_ACCESSED);
+}
+
+static inline pte_t pte_mkyoung(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_ACCESSED);
+}
+
+static inline pte_t pte_mkclean(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_DIRTY);
+}
+
+static inline pte_t pte_mkdirty(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_DIRTY);
+}
+
+static inline pte_t pte_mkwrite_novma(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_WRITE);
+}
+
+static inline pte_t pte_wrprotect(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_WRITE);
+}
+
+static inline void set_pte(pte_t *ptep, pte_t pteval)
+{
+	WRITE_ONCE(*ptep, pteval);
+}
+
+void flush_icache_pte(struct mm_struct *mm, pte_t pte);
+
+static inline void __set_pte_at(struct mm_struct *mm, pte_t *ptep, pte_t pteval)
+{
+	if (pte_present(pteval))
+		flush_icache_pte(mm, pteval);
+
+	set_pte(ptep, pteval);
+}
+
+static inline void pte_clear(struct mm_struct *mm,
+			     unsigned long addr, pte_t *ptep)
+{
+	__set_pte_at(mm, ptep, __pte(0));
+}
+
+/*
+ * Encode/decode swap entries and swap PTEs. Swap PTEs are all PTEs that
+ * are !pte_none() && !pte_present().
+ *
+ * Format of swap PTE:
+ *	bit            0:	_PAGE_PRESENT (zero)
+ *	bit            1:	_PAGE_WRITE (zero)
+ *	bit            2:	_PAGE_KERNEL (zero)
+ *	bit            3:	_PAGE_NO_CACHE (zero)
+ *	bit            4:	_PAGE_PROT_NONE (zero)
+ *	bit            5:	exclusive marker
+ *	bits      6 to 11:	swap type
+ *	bits     12 to 31:	swap offset
+ */
+#define __SWP_TYPE_SHIFT	5
+#define __SWP_TYPE_BITS		6
+#define __SWP_TYPE_MASK		((1UL << __SWP_TYPE_BITS) - 1)
+#define __SWP_OFFSET_SHIFT	(__SWP_TYPE_BITS + __SWP_TYPE_SHIFT)
+
+#define MAX_SWAPFILES_CHECK()	\
+	BUILD_BUG_ON(MAX_SWAPFILES_SHIFT > __SWP_TYPE_BITS)
+
+#define __swp_type(x)	(((x).val >> __SWP_TYPE_SHIFT) & __SWP_TYPE_MASK)
+#define __swp_offset(x)	((x).val >> __SWP_OFFSET_SHIFT)
+#define __swp_entry(type, offset) ((swp_entry_t) \
+	{ (((type) & __SWP_TYPE_MASK) << __SWP_TYPE_SHIFT) | \
+	  ((offset) << __SWP_OFFSET_SHIFT) })
+
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })
+
+static inline bool pte_swp_exclusive(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_SWP_EXCLUSIVE;
+}
+
+static inline pte_t pte_swp_clear_exclusive(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_SWP_EXCLUSIVE);
+}
+
+static inline pte_t pte_swp_mkexclusive(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_SWP_EXCLUSIVE);
+}
+
+static inline pgd_t pfn_pgd(unsigned long pfn, pgprot_t prot)
+{
+	return __pgd((pfn << PFN_PTE_SHIFT) | pgprot_val(prot));
+}
+
+static inline void set_pmd(pmd_t *pmdp, pmd_t pmd)
+{
+	WRITE_ONCE(*pmdp, pmd);
+}
+
+static inline void pmd_clear(pmd_t *pmdp)
+{
+	set_pmd(pmdp, __pmd(0));
+}
+
+static inline int pmd_none(pmd_t pmd)
+{
+	return pmd_val(pmd) == 0;
+}
+
+static inline int pmd_bad(pmd_t pmd)
+{
+	return 0;
+}
+
+static inline int pmd_present(pmd_t pmd)
+{
+	return (pmd_val(pmd) & (_PAGE_PRESENT | _PAGE_PROT_NONE));
+}
+
+static inline struct page *pmd_page(pmd_t pmd)
+{
+	return pfn_to_page(__page_val_to_pfn(pmd_val(pmd)));
+}
+
+#define __pmd_to_phys(pmd)  (__page_val_to_pfn(pmd_val(pmd)) << PAGE_SHIFT)
+
+static inline unsigned long pmd_pfn(pmd_t pmd)
+{
+	return ((__pmd_to_phys(pmd) & PMD_MASK) >> PAGE_SHIFT);
+}
+
+#define pmd_page_vaddr(pmd)	pmd_val(pmd)
+
+static inline void update_mmu_cache_range(struct vm_fault *vmf,
+					  struct vm_area_struct *vma, unsigned long address,
+					  pte_t *ptep, unsigned int nr)
+{
+	while (nr--)
+		local_flush_tlb_page(address + nr * PAGE_SIZE);
+}
+
+#define update_mmu_cache(vma, addr, ptep)	\
+	update_mmu_cache_range(NULL, vma, addr, ptep, 1)
+
+extern void *_dtb_early_va;
+extern uintptr_t _dtb_early_pa;
+
+void paging_init(void);
+void misc_mem_init(void);
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#endif /* _ASM_XR17032_PGTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/processor.h linux-workdir/arch/xr17032/include/asm/processor.h
--- linux-clean/arch/xr17032/include/asm/processor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/processor.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PROCESSOR_H
+#define _ASM_XR17032_PROCESSOR_H
+
+#define DEFAULT_MAP_WINDOW	TASK_SIZE
+#define STACK_TOP_MAX		TASK_SIZE
+
+#define STACK_ALIGN		4
+#define STACK_TOP		DEFAULT_MAP_WINDOW
+#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
+
+struct pt_regs;
+
+static inline void cpu_relax(void)
+{
+	asm volatile("pause" ::: "memory");
+}
+
+struct thread_struct {
+	/* Callee-saved registers */
+	unsigned long s[18];
+	unsigned long sp;
+	unsigned long lr;
+};
+
+#define INIT_THREAD					\
+{							\
+	.sp = sizeof(init_stack) + (long)&init_stack,	\
+}
+
+#define task_pt_regs(tsk)						\
+	((struct pt_regs *)(task_stack_page(tsk) + THREAD_SIZE		\
+			    - ALIGN(sizeof(struct pt_regs), STACK_ALIGN)))
+
+#define KSTK_EIP(tsk)	(task_pt_regs(tsk)->pc)
+#define KSTK_ESP(tsk)	(task_pt_regs(tsk)->sp)
+
+extern unsigned long __get_wchan(struct task_struct *p);
+
+extern void start_thread(struct pt_regs *regs,
+			 unsigned long pc, unsigned long sp);
+
+#endif /* _ASM_XR17032_PROCESSOR_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/ptrace.h linux-workdir/arch/xr17032/include/asm/ptrace.h
--- linux-clean/arch/xr17032/include/asm/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/ptrace.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PTRACE_H
+#define _ASM_XR17032_PTRACE_H
+
+#include <uapi/asm/ptrace.h>
+#include <asm/cr.h>
+
+struct pt_regs {
+	unsigned long pc;
+	unsigned long t0;
+	unsigned long t1;
+	unsigned long t2;
+	unsigned long t3;
+	unsigned long t4;
+	unsigned long t5;
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long s0;
+	unsigned long s1;
+	unsigned long s2;
+	unsigned long s3;
+	unsigned long s4;
+	unsigned long s5;
+	unsigned long s6;
+	unsigned long s7;
+	unsigned long s8;
+	unsigned long s9;
+	unsigned long s10;
+	unsigned long s11;
+	unsigned long s12;
+	unsigned long s13;
+	unsigned long s14;
+	unsigned long s15;
+	unsigned long s16;
+	unsigned long s17;
+	unsigned long tp;
+	unsigned long sp;
+	unsigned long lr;
+	unsigned long rs;
+};
+
+#define user_mode(regs) (((regs)->rs & RS_U) != 0)
+
+static inline unsigned long user_stack_pointer(struct pt_regs *regs)
+{
+	return regs->sp;
+}
+
+static inline unsigned long instruction_pointer(struct pt_regs *regs)
+{
+	return regs->pc;
+}
+
+#endif /* _ASM_XR17032_PTRACE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/set_memory.h linux-workdir/arch/xr17032/include/asm/set_memory.h
--- linux-clean/arch/xr17032/include/asm/set_memory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/set_memory.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SET_MEMORY_H
+#define _ASM_XR17032_SET_MEMORY_H
+
+#define SECTION_ALIGN L1_CACHE_BYTES
+
+#endif /* _ASM_XR17032_SET_MEMORY_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/sparsemem.h linux-workdir/arch/xr17032/include/asm/sparsemem.h
--- linux-clean/arch/xr17032/include/asm/sparsemem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/sparsemem.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SPARSEMEM_H
+#define _ASM_XR17032_SPARSEMEM_H
+
+#ifdef CONFIG_SPARSEMEM
+#define MAX_PHYSMEM_BITS	32
+#define SECTION_SIZE_BITS	25
+#endif
+
+#endif /* _ASM_XR17032_SPARSEMEM_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/syscall.h linux-workdir/arch/xr17032/include/asm/syscall.h
--- linux-clean/arch/xr17032/include/asm/syscall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/syscall.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SYSCALL_H
+#define _ASM_XR17032_SYSCALL_H
+
+#include <uapi/linux/audit.h>
+
+static inline int syscall_get_arch(struct task_struct *task)
+{
+	return AUDIT_ARCH_XR17032;
+}
+
+#endif /* _ASM_XR17032_SYSCALL_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/thread_info.h linux-workdir/arch/xr17032/include/asm/thread_info.h
--- linux-clean/arch/xr17032/include/asm/thread_info.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/thread_info.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_THREAD_INFO_H
+#define _ASM_XR17032_THREAD_INFO_H
+
+#include <asm/page.h>
+
+#define THREAD_SIZE_ORDER 	0
+#define THREAD_SIZE		(PAGE_SIZE << THREAD_SIZE_ORDER)
+#define THREAD_ALIGN		THREAD_SIZE
+
+#ifndef __ASSEMBLER__
+
+struct thread_info {
+	unsigned long 	flags;
+	int		preempt_count;
+};
+
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.flags		= 0,			\
+	.preempt_count	= INIT_PREEMPT_COUNT,	\
+}
+
+#define TIF_NEED_RESCHED 0
+#define TIF_NOTIFY_SIGNAL 1
+#define TIF_SIGPENDING 2
+#define TIF_SYSCALL_TRACE 3
+#define TIF_MEMDIE 4
+#define TIF_NOTIFY_RESUME 5
+
+#define _TIF_NEED_RESCHED (1 << TIF_NEED_RESCHED)
+#define _TIF_NOTIFY_SIGNAL (1 << TIF_NOTIFY_SIGNAL)
+#define _TIF_SIGPENDING (1 << TIF_SIGPENDING)
+#define _TIF_SYSCALL_TRACE (1 << TIF_SYSCALL_TRACE)
+#define _TIF_MEMDIE (1 << TIF_MEMDIE)
+#define _TIF_NOTIFY_RESUME (1 << TIF_NOTIFY_RESUME)
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#endif /* _ASM_XR17032_THREAD_INFO_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/tlb.h linux-workdir/arch/xr17032/include/asm/tlb.h
--- linux-clean/arch/xr17032/include/asm/tlb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/tlb.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_TLB_H
+#define _ASM_XR17032_TLB_H
+
+struct mmu_gather;
+
+static void tlb_flush(struct mmu_gather *tlb);
+
+#define tlb_flush tlb_flush
+#include <asm-generic/tlb.h>
+
+static inline void tlb_flush(struct mmu_gather *tlb)
+{
+	if (tlb->fullmm || tlb->need_flush_all || tlb->freed_tables)
+		flush_tlb_mm(tlb->mm);
+	else
+		flush_tlb_mm_range(tlb->mm, tlb->start, tlb->end,
+				   tlb_get_unmap_size(tlb));
+}
+
+#endif /* _ASM_XR17032_TLB_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/tlbflush.h linux-workdir/arch/xr17032/include/asm/tlbflush.h
--- linux-clean/arch/xr17032/include/asm/tlbflush.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/tlbflush.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_TLBFLUSH_H
+#define _ASM_XR17032_TLBFLUSH_H
+
+#include <asm/pgtable.h>
+#include <linux/mm_types.h>
+
+void flush_tlb_mm(struct mm_struct *mm);
+void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
+			unsigned long end, unsigned int page_size);
+void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr);
+void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+		     unsigned long end);
+void flush_tlb_kernel_range(unsigned long start, unsigned long end);
+
+static inline void local_flush_tlb_all(void)
+{
+	asm volatile("mtcr itbctrl, %0" :: "r" (1UL) : "memory");
+	asm volatile("mtcr dtbctrl, %0" :: "r" (1UL) : "memory");
+}
+
+static inline void local_flush_tlb_page(unsigned long addr)
+{
+	addr &= ~0xfffUL;
+	asm volatile("mtcr itbctrl, %0" :: "r" (addr) : "memory");
+	asm volatile("mtcr dtbctrl, %0" :: "r" (addr) : "memory");
+	asm volatile(
+		"mtcr dtbctrl, %0"
+		:
+		: "r" (_PGTABLE_ADDR | (addr >> 10))
+		: "memory"
+	);
+}
+
+#endif /* _ASM_XR17032_TLBFLUSH_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/uaccess.h linux-workdir/arch/xr17032/include/asm/uaccess.h
--- linux-clean/arch/xr17032/include/asm/uaccess.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/uaccess.h
@@ -0,0 +1,251 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_UACCESS_H
+#define _ASM_XR17032_UACCESS_H
+
+#include <asm/asm-extable.h>
+#include <asm/extable.h>
+#include <asm/pgtable.h>
+#include <asm-generic/access_ok.h>
+#include <linux/compiler.h>
+#include <linux/errno.h>
+
+unsigned long __must_check __asm_copy_to_user(void __user *to,
+					      const void *from,
+					      unsigned long n);
+unsigned long __must_check __asm_copy_from_user(void *to,
+						const void __user *from,
+						unsigned long n);
+
+#ifdef CONFIG_CC_HAS_ASM_GOTO_OUTPUT
+#define __get_user_asm(x, ptr, label)				\
+	asm_goto_output(					\
+		"1:\n"						\
+		"	mov %0, %1\n"				\
+		_ASM_EXTABLE_UACCESS_ERR(1b, %l2, %0)		\
+		: "=&r" (x)					\
+		: "m" (*(ptr)) : : label			\
+	)
+#define __get_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u32 __lo, __hi;						\
+	asm_goto_output(					\
+		"1:\n"						\
+		"	mov %0, %2\n"				\
+		"2:\n"						\
+		"	mov %1, %3\n"				\
+		_ASM_EXTABLE_UACCESS_ERR(1b, %l4, %0)		\
+		_ASM_EXTABLE_UACCESS_ERR(2b, %l4, %0)		\
+		: "=&r" (__lo), "=r" (__hi)			\
+		: "m" (__ptr[0]), "m" (__ptr[1])		\
+		: : label);                                     \
+	(x) = (typeof(x))((typeof((x) - (x)))(			\
+		(((u64)__hi << 32) | __lo)));			\
+} while (0)
+#else /* !CONFIG_CC_HAS_ASM_GOTO_OUTPUT */
+#define __get_user_asm(x, ptr, label)				\
+do {								\
+	long __gua_err = 0;					\
+	asm volatile(						\
+		"1:\n"						\
+		"	mov %1, %2\n"				\
+		"2:\n"						\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(1b, 2b, %0, %1)	\
+		: "+r" (__gua_err), "=&r" (x)			\
+		: "m" (*(ptr))					\
+	);							\
+	if (__gua_err)						\
+		goto label;					\
+} while (0)
+#define __get_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u32 __lo, __hi;						\
+	long __gu8_err = 0;					\
+	__asm__ __volatile__ (					\
+		"1:\n"						\
+		"	mov %1, %3\n"				\
+		"2:\n"						\
+		"	mov %2, %4\n"				\
+		"3:\n"						\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(1b, 3b, %0, %1)	\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(2b, 3b, %0, %1)	\
+		: "+r" (__gu8_err), "=&r" (__lo), "=r" (__hi)	\
+		: "m" (__ptr[0]), "m" (__ptr[1]));		\
+	if (__gu8_err) {					\
+		__hi = 0;					\
+		goto label;					\
+	}							\
+	(x) = (typeof(x))((typeof((x) - (x)))(			\
+		(((u64)__hi << 32) | __lo)));			\
+} while (0)
+#endif /* CONFIG_CC_HAS_ASM_GOTO_OUTPUT */
+
+#define __get_user_nocheck(x, __gu_ptr, label)				\
+do {									\
+	if (!IS_ALIGNED((uintptr_t)__gu_ptr, sizeof(*__gu_ptr))) {	\
+		if (__asm_copy_from_user((void *)&(x),			\
+					 (const void *)__gu_ptr,	\
+			                 sizeof(*__gu_ptr))) 		\
+			goto label;					\
+		break;							\
+	}								\
+	switch (sizeof(*__gu_ptr)) {					\
+	case 1:								\
+	case 2:								\
+	case 4:								\
+		__get_user_asm((x), __gu_ptr, label);			\
+		break;							\
+	case 8:								\
+		__get_user_8((x), __gu_ptr, label);			\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+} while (0)
+
+#define __get_user_error(x, ptr, err)					\
+do {									\
+	__label__ __gu_failed;						\
+									\
+	__get_user_nocheck(x, ptr, __gu_failed);			\
+		err = 0;						\
+		break;							\
+__gu_failed:								\
+		x = 0;							\
+		err = -EFAULT;						\
+} while (0)
+
+#define __get_user(x, ptr)					\
+({								\
+	const typeof(*(ptr)) __user *__gu_ptr = (ptr);		\
+	long __gu_err = 0;					\
+	typeof(x) __gu_val;					\
+								\
+	__chk_user_ptr(__gu_ptr);				\
+								\
+	__get_user_error(__gu_val, __gu_ptr, __gu_err);		\
+								\
+	(x) = __gu_val;						\
+								\
+	__gu_err;						\
+})
+
+#define get_user(x, ptr)					\
+({								\
+	const typeof(*(ptr)) __user *__p = (ptr);		\
+	might_fault();						\
+	access_ok(__p, sizeof(*__p)) ?				\
+		__get_user((x), __p) :				\
+		((x) = (__force typeof(x))0, -EFAULT);		\
+})
+
+#define __put_user_asm(x, ptr, label)				\
+do {								\
+	typeof(*(ptr)) __x = x;					\
+	asm goto(						\
+		"1:\n"						\
+		"	mov %1, %z0\n"				\
+		_ASM_EXTABLE(1b, %l2)				\
+		: : "rO" (__x), "m"(*(ptr)) : : label);		\
+} while (0)
+#define __put_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u64 __x = (typeof((x)-(x)))(x);				\
+	asm goto(						\
+		"1:\n"						\
+		"	mov %2, %z0\n"				\
+		"2:\n"						\
+		"	mov %3, %z1\n"				\
+		_ASM_EXTABLE(1b, %l4)				\
+		_ASM_EXTABLE(2b, %l4)				\
+		: : "rO" ((u32)__x), "rO" ((u32)(__x >> 32)),	\
+			"m" (__ptr[0]),				\
+			"m" (__ptr[1]) : : label);		\
+} while (0)
+
+#define __put_user_nocheck(x, __gu_ptr, label)				\
+do {									\
+	if (!IS_ALIGNED((uintptr_t)__gu_ptr, sizeof(*__gu_ptr))) {	\
+		if (__asm_copy_to_user((void *)__gu_ptr,		\
+				       (const void *)&((x)),		\
+				       sizeof(*__gu_ptr)))		\
+			goto label;					\
+		break;							\
+	}								\
+	switch (sizeof(*__gu_ptr)) {					\
+	case 1:								\
+	case 2:								\
+	case 4:								\
+		__put_user_asm((x), __gu_ptr, label);			\
+		break;							\
+	case 8:								\
+		__put_user_8((x), __gu_ptr, label);			\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+} while (0)
+
+#define __put_user_error(x, ptr, err)				\
+do {								\
+	__label__ err_label;					\
+	__put_user_nocheck(x, ptr, err_label);			\
+	break;							\
+err_label:							\
+	(err) = -EFAULT;					\
+} while (0)
+
+#define __put_user(x, ptr)					\
+({								\
+	typeof(*(ptr)) __user *__gu_ptr = (ptr); 		\
+	typeof(*__gu_ptr) __val = (x);				\
+	long __pu_err = 0;					\
+								\
+	__chk_user_ptr(__gu_ptr);				\
+								\
+	__put_user_error(__val, __gu_ptr, __pu_err);		\
+								\
+	__pu_err;						\
+})
+
+#define put_user(x, ptr)					\
+({								\
+	typeof(*(ptr)) __user *__p = (ptr);			\
+	might_fault();						\
+	access_ok(__p, sizeof(*__p)) ? __put_user((x), __p)	\
+				     : -EFAULT;			\
+})
+
+static inline unsigned long
+raw_copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	return __asm_copy_from_user(to, from, n);
+}
+
+static inline unsigned long
+raw_copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	return __asm_copy_to_user(to, from, n);
+}
+
+extern unsigned long __must_check __clear_user(void __user *addr,
+					       unsigned long n);
+
+static inline unsigned long __must_check clear_user(void __user *to,
+						    unsigned long n)
+{
+	might_fault();
+	return access_ok(to, n) ? __clear_user(to, n) : n;
+}
+
+extern long strncpy_from_user(char *dest, const char __user *src, long count);
+
+extern long __must_check strnlen_user(const char __user *str, long n);
+
+#endif /* _ASM_XR17032_UACCESS_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/vmalloc.h linux-workdir/arch/xr17032/include/asm/vmalloc.h
--- linux-clean/arch/xr17032/include/asm/vmalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/vmalloc.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_VMALLOC_H
+#define _ASM_XR17032_VMALLOC_H
+
+#endif /* _ASM_XR17032_VMALLOC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/byteorder.h linux-workdir/arch/xr17032/include/uapi/asm/byteorder.h
--- linux-clean/arch/xr17032/include/uapi/asm/byteorder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/byteorder.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_BYTEORDER_H
+#define _UAPI_ASM_XR17032_BYTEORDER_H
+
+#include <linux/byteorder/little_endian.h>
+
+#endif /* _UAPI_ASM_XR17032_BYTEORDER_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/elf.h linux-workdir/arch/xr17032/include/uapi/asm/elf.h
--- linux-clean/arch/xr17032/include/uapi/asm/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/elf.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_ELF_H
+#define _UAPI_ASM_XR17032_ELF_H
+
+#include <asm/ptrace.h>
+
+typedef struct user_regs_struct elf_gregset_t;
+typedef unsigned int elf_fpregset_t;
+
+#endif /* _UAPI_ASM_XR17032_ELF_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/posix_types.h linux-workdir/arch/xr17032/include/uapi/asm/posix_types.h
--- linux-clean/arch/xr17032/include/uapi/asm/posix_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/posix_types.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_POSIX_TYPES_H
+#define _UAPI_ASM_XR17032_POSIX_TYPES_H
+
+typedef unsigned long	__kernel_size_t;
+typedef long		__kernel_ssize_t;
+typedef long		__kernel_ptrdiff_t;
+#define __kernel_size_t __kernel_size_t
+
+#include <asm-generic/posix_types.h>
+
+#endif /* _UAPI_ASM_XR17032_POSIX_TYPES_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/ptrace.h linux-workdir/arch/xr17032/include/uapi/asm/ptrace.h
--- linux-clean/arch/xr17032/include/uapi/asm/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/ptrace.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_PTRACE_H
+#define _UAPI_ASM_XR17032_PTRACE_H
+
+/* must be a prefix of struct pt_regs */
+struct user_regs_struct {
+	unsigned long pc;
+	unsigned long t0;
+	unsigned long t1;
+	unsigned long t2;
+	unsigned long t3;
+	unsigned long t4;
+	unsigned long t5;
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long s0;
+	unsigned long s1;
+	unsigned long s2;
+	unsigned long s3;
+	unsigned long s4;
+	unsigned long s5;
+	unsigned long s6;
+	unsigned long s7;
+	unsigned long s8;
+	unsigned long s9;
+	unsigned long s10;
+	unsigned long s11;
+	unsigned long s12;
+	unsigned long s13;
+	unsigned long s14;
+	unsigned long s15;
+	unsigned long s16;
+	unsigned long s17;
+	unsigned long tp;
+	unsigned long sp;
+	unsigned long lr;
+};
+
+#endif /* _UAPI_ASM_XR17032_PTRACE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/sigcontext.h linux-workdir/arch/xr17032/include/uapi/asm/sigcontext.h
--- linux-clean/arch/xr17032/include/uapi/asm/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/sigcontext.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_SIGCONTEXT_H
+#define _UAPI_ASM_XR17032_SIGCONTEXT_H
+
+#endif /* _UAPI_ASM_XR17032_SIGCONTEXT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/Makefile linux-workdir/arch/xr17032/kernel/Makefile
--- linux-clean/arch/xr17032/kernel/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/Makefile
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the XR/17032 Linux kernel
+#
+
+always-$(KBUILD_BUILTIN)	+= vmlinux.lds
+
+obj-y	+= head.o
+obj-y	+= setup.o
+
+obj-y	+= asm-stubs.o
+obj-y	+= stubs.o
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/asm-offsets.c linux-workdir/arch/xr17032/kernel/asm-offsets.c
--- linux-clean/arch/xr17032/kernel/asm-offsets.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/asm-offsets.c
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/ptrace.h>
+#include <linux/kbuild.h>
+#include <linux/sched.h>
+
+void asm_offsets(void);
+
+void asm_offsets(void)
+{
+	DEFINE(PT_SIZE_ON_STACK, ALIGN(sizeof(struct pt_regs), STACK_ALIGN));
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/asm-stubs.S linux-workdir/arch/xr17032/kernel/asm-stubs.S
--- linux-clean/arch/xr17032/kernel/asm-stubs.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/asm-stubs.S
@@ -0,0 +1,19 @@
+#include <linux/linkage.h>
+
+.text
+
+SYM_FUNC_START(__asm_copy_from_user)
+	brk
+SYM_FUNC_END(__asm_copy_from_user)
+
+SYM_FUNC_START(__asm_copy_to_user)
+	brk
+SYM_FUNC_END(__asm_copy_to_user)
+
+SYM_FUNC_START(__clear_user)
+	brk
+SYM_FUNC_END(__clear_user)
+
+SYM_FUNC_START(__switch_to)
+	brk
+SYM_FUNC_END(__switch_to)
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/head.S linux-workdir/arch/xr17032/kernel/head.S
--- linux-clean/arch/xr17032/kernel/head.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/head.S
@@ -0,0 +1,241 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/thread_info.h>
+#include <generated/asm-offsets.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+
+__HEAD
+.Lexception_block:
+
+SYM_DATA_START_LOCAL(xrlinux_header)
+	.long 0x584c5258		# magic
+	.word 0				# minor version
+	.word 2				# major version
+	.long xrlinux_header		# virtual address
+	.long _end - xrlinux_header	# size in memory
+	.long _start			# entrypoint
+	.long 1				# flags: map dtb
+	.long _end			# dtb address
+	.long FIXADDR_START - 1		# max dtb end
+SYM_DATA_END(xrlinux_header)
+
+SYM_CODE_START(_start)
+	# set up everything in advance so that in the region where nmi masking
+	# is necessary (from first rs write to mmu enable) we only execute mtcr
+	# (and one jump)
+
+	# value to write to *itbctrl to clear the tb
+	addi t0, zero, 3
+
+	# virtual address of exception block
+	lui t1, zero, .Lexception_block
+	ori t1, t1, .Lexception_block
+
+	# itbtag value for exception block
+	add t2, zero, t1 RSH 12
+
+	# itbpte value for exception block
+	add t3, zero, a0 RSH 7
+	ori t3, t3, 0x17 # global, kernel, writable, valid
+
+	# dtbtag value for page table
+	lui t4, zero, (_PGD_ADDR >> 12)
+	ori t4, t4, (_PGD_ADDR >> 12)
+
+	# dtbpte value for page table
+	add t5, zero, s0 RSH 7
+	ori t5, t5, 0x17 # global, kernel, writable, valid
+
+	# create entry for recursive paging
+	# all cpus will do this, but they'll all be writing the same value to
+	# the same address, so it doesn't matter
+	mov long [s0 + ((_PGTABLE_ADDR >> 22) * 4)], t5
+
+	# value to write to *tbaddr
+	lui s0, zero, _PGTABLE_ADDR
+	ori s0, s0, _PGTABLE_ADDR
+
+	# initial value for *tbindex and value to write to rs to enable paging
+	addi s1, zero, 4
+
+	# itbtag value for temporary identity map of exception block
+	add s2, zero, a0 RSH 12
+
+	# canonicalize rs to T=0, M=0, I=0, U=0
+	mtcr rs, zero
+
+	# fully clear the tbs
+	mtcr itbctrl, t0
+	mtcr dtbctrl, t0
+
+	# set up exception block (incl. wired itb entry)
+	mtcr eb, t1
+	mtcr itbindex, zero
+	mtcr itbtag, t2
+	mtcr itbpte, t3
+
+	# set up wired dtb entry for page table
+	mtcr dtbindex, zero
+	mtcr dtbtag, t4
+	mtcr dtbpte, t5
+
+	# prepare for enabling paging
+	mtcr itbaddr, s0
+	mtcr dtbaddr, s0
+	mtcr itbindex, s1
+	mtcr dtbindex, s1
+
+	# create non-wired tb entry for identity map of exception block
+	mtcr itbtag, s2
+	mtcr itbpte, t3
+
+	# enable paging
+	mtcr rs, s1
+
+	# jump to virtual addressing (and out of exception block)
+	jalr zero, t1, _start_kernel - .Lexception_block
+SYM_CODE_END(_start)
+
+.org 0x100
+SYM_CODE_START_LOCAL(interrupt_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(interrupt_entry)
+
+.org 0x200
+SYM_CODE_START_LOCAL(syscall_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(syscall_entry)
+
+.org 0x400
+SYM_CODE_START_LOCAL(bus_error_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(bus_error_entry)
+
+.org 0x500
+SYM_CODE_START_LOCAL(nmi_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(nmi_entry)
+
+.org 0x600
+SYM_CODE_START_LOCAL(breakpoint_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(breakpoint_entry)
+
+.org 0x700
+SYM_CODE_START_LOCAL(invalid_instruction_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(invalid_instruction_entry)
+
+.org 0x800
+SYM_CODE_START_LOCAL(privileged_instruction_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(privileged_instruction_entry)
+
+.org 0x900
+SYM_CODE_START_LOCAL(unaligned_access_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(unaligned_access_entry)
+
+.org 0xc00
+SYM_CODE_START_LOCAL(read_page_fault_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(read_page_fault_entry)
+
+.org 0xd00
+SYM_CODE_START_LOCAL(write_page_fault_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(write_page_fault_entry)
+
+.org 0xe00
+SYM_CODE_START_LOCAL(handle_itb_miss)
+	mfcr zero, itbaddr
+	mov zero, long [zero]
+	mtcr itbpte, zero
+	rfe
+SYM_CODE_END(handle_itb_miss)
+
+.org 0xf00
+SYM_CODE_START_LOCAL(handle_dtb_miss)
+	mfcr zero, dtbaddr
+	mov zero, long [zero]
+	mtcr dtbpte, zero
+	rfe
+SYM_CODE_END(handle_dtb_miss)
+
+# skip over exception block
+.org 0x1000
+
+SYM_CODE_START_LOCAL(_start_kernel)
+	# remove temporary identity map itb entry
+	addi t0, zero, 1
+	mtcr itbctrl, t0
+
+	# get a logical cpu id
+	lui t0, zero, num_started_cpus
+	ori t0, t0, num_started_cpus
+1:	ll a0, t0
+	addi t1, a0, 1
+	sc t1, t0, t1
+	beq t1, 1b
+
+	# make sure we don't have more cpus than we know how to deal with
+#ifdef CONFIG_SMP
+	slti t1, a0, CONFIG_NR_CPUS
+	bne t1, .Lpark_cpu
+#else
+	bne a0, .Lpark_cpu
+#endif
+
+	# only continue on cpu0
+	bne a0, .Lpark_cpu
+
+	# set up c environment
+	lui tp, zero, init_task
+	ori tp, tp, init_task
+
+	lui sp, zero, init_thread_union + THREAD_SIZE - PT_SIZE_ON_STACK
+	ori sp, sp, init_thread_union + THREAD_SIZE - PT_SIZE_ON_STACK
+
+	addi s0, zero, 0
+
+	# wait until all cpus have entered the kernel
+	lui t0, zero, num_started_cpus
+	ori t0, t0, num_started_cpus
+1:	mov t1, long [t0]
+	slt t1, t1, a2
+	bne t1, 1b
+	mb
+
+	# call c entry point
+	add a0, a1, zero
+	jal setup_vm
+	jal start_kernel
+	brk
+
+.Lpark_cpu:
+	hlt
+	beq zero, .Lpark_cpu
+SYM_CODE_END(_start_kernel)
+
+.bss
+
+.balign 4
+SYM_DATA_START_LOCAL(num_started_cpus)
+	.space 4
+SYM_DATA_END(num_started_cpus)
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/setup.c linux-workdir/arch/xr17032/kernel/setup.c
--- linux-clean/arch/xr17032/kernel/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/setup.c
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/early_ioremap.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/sections.h>
+#include <linux/console.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/jump_label.h>
+#include <linux/of_fdt.h>
+#include <linux/panic.h>
+#include <linux/printk.h>
+
+static void __init parse_dtb(void)
+{
+	if (early_init_dt_scan(_dtb_early_va, _dtb_early_pa)) {
+		const char *name = of_flat_dt_get_machine_name();
+
+		if (name) {
+			pr_info("Machine model: %s\n", name);
+			dump_stack_set_arch_desc("%s", name);
+		}
+	} else {
+		pr_err("Invalid DTB");
+	}
+}
+
+void __init setup_arch(char **cmdline_p)
+{
+	parse_dtb();
+	setup_initial_init_mm(_stext, _etext, _edata, _end);
+
+	*cmdline_p = boot_command_line;
+
+	early_ioremap_setup();
+	jump_label_init();
+	parse_early_param();
+
+	paging_init();
+
+	unflatten_device_tree();
+	misc_mem_init();
+
+	panic("TODO setup_arch");
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/stubs.c linux-workdir/arch/xr17032/kernel/stubs.c
--- linux-clean/arch/xr17032/kernel/stubs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/stubs.c
@@ -0,0 +1,115 @@
+#include <asm/mmu_context.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/tlbflush.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/panic.h>
+#include <linux/ptrace.h>
+#include <linux/reboot.h>
+#include <linux/sched.h>
+#include <linux/sched/debug.h>
+#include <linux/seq_file.h>
+
+const struct seq_operations cpuinfo_op;
+
+long arch_ptrace(struct task_struct *child, long request,
+		 unsigned long addr, unsigned long data)
+{
+	panic("TODO arch_ptrace");
+}
+
+int copy_thread(struct task_struct *p, const struct kernel_clone_args *args)
+{
+	panic("TODO copy_thread");
+}
+
+void flush_thread(void)
+{
+	panic("TODO flush_thread");
+}
+
+void flush_tlb_kernel_range(unsigned long start, unsigned long end)
+{
+	panic("TODO flush_tlb_kernel_range");
+}
+
+void flush_tlb_mm(struct mm_struct *mm)
+{
+	panic("TODO flush_tlb_mm");
+}
+
+void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
+			unsigned long end, unsigned int page_size)
+{
+	panic("TODO flush_tlb_mm_range");
+}
+
+void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)
+{
+	panic("TODO flush_tlb_page");
+}
+
+void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+		     unsigned long end)
+{
+	panic("TODO flush_tlb_range");
+}
+
+unsigned long __get_wchan(struct task_struct *task)
+{
+	panic("TODO __get_wchan");
+}
+
+void __init init_IRQ(void)
+{
+	panic("TODO init_IRQ");
+}
+
+void machine_halt(void)
+{
+	panic("TODO machine_halt");
+}
+
+void machine_power_off(void)
+{
+	panic("TODO machine_power_off");
+}
+
+void machine_restart(char *cmd)
+{
+	panic("TODO machine_restart");
+}
+
+void ptrace_disable(struct task_struct *child)
+{
+	panic("TODO ptrace_disable");
+}
+
+void show_regs(struct pt_regs *regs)
+{
+	panic("TODO show_regs");
+}
+
+void show_stack(struct task_struct *task, unsigned long *sp, const char *loglvl)
+{
+	pr_cont("TODO show_stack\n");
+}
+
+void start_thread(struct pt_regs *regs, unsigned long pc, unsigned long sp)
+{
+	panic("TODO start_thread");
+}
+
+void switch_mm(struct mm_struct *prev, struct mm_struct *next,
+	       struct task_struct *task)
+{
+	panic("TODO switch_mm");
+}
+
+void __init time_init(void)
+{
+	panic("TODO time_init");
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/vmlinux.lds.S linux-workdir/arch/xr17032/kernel/vmlinux.lds.S
--- linux-clean/arch/xr17032/kernel/vmlinux.lds.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/vmlinux.lds.S
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/pgtable.h>
+#define LOAD_OFFSET KERNEL_LINK_ADDR
+
+#include <asm/vmlinux.lds.h>
+#include <asm/page.h>
+#include <asm/cache.h>
+#include <asm/thread_info.h>
+#include <asm/set_memory.h>
+
+#include <linux/sizes.h>
+
+OUTPUT_ARCH(xr17032)
+ENTRY(_start)
+
+jiffies = jiffies_64;
+
+SECTIONS
+{
+	. = LOAD_OFFSET;
+	HEAD_TEXT_SECTION
+	. = ALIGN(PAGE_SIZE);
+
+	.text : {
+		_text = .;
+		_stext = .;
+		TEXT_TEXT
+		SCHED_TEXT
+		LOCK_TEXT
+		KPROBES_TEXT
+		ENTRY_TEXT
+		IRQENTRY_TEXT
+		SOFTIRQENTRY_TEXT
+		_etext = .;
+	}
+
+	. = ALIGN(SECTION_ALIGN);
+	__init_begin = .;
+	__init_text_begin = .;
+	.init.text : AT(ADDR(.init.text) - LOAD_OFFSET) ALIGN(SECTION_ALIGN) { \
+		_sinittext = .;						\
+		INIT_TEXT						\
+		_einittext = .;						\
+	}
+
+	/* we have to discard exit text and such at runtime, not link time */
+	__exittext_begin = .;
+	.exit.text :
+	{
+		EXIT_TEXT
+	}
+	__exittext_end = .;
+
+	__init_text_end = .;
+	. = ALIGN(SECTION_ALIGN);
+	/* Start of init data section */
+	__init_data_begin = .;
+	INIT_DATA_SECTION(16)
+
+	.init.pi : {
+		KEEP(*(.init.pi*))
+	}
+
+	.init.bss : {
+		KEEP(*(.init.bss*))
+	}
+	.exit.data :
+	{
+		EXIT_DATA
+	}
+
+	RUNTIME_CONST_VARIABLES
+
+	PERCPU_SECTION(L1_CACHE_BYTES)
+
+	.rel.dyn : {
+		*(.rel.dyn*)
+	}
+
+	.rela.dyn : ALIGN(8) {
+		__rela_dyn_start = .;
+		*(.rela .rela*)
+		__rela_dyn_end = .;
+	}
+
+	__init_data_end = .;
+
+	. = ALIGN(8);
+	.alternative : {
+		__alt_start = .;
+		KEEP(*(.alternative))
+		__alt_end = .;
+	}
+	__init_end = .;
+
+	/* Start of data section */
+	_sdata = .;
+	RO_DATA(SECTION_ALIGN)
+	.srodata : {
+		*(.srodata*)
+	}
+
+	. = ALIGN(SECTION_ALIGN);
+	_data = .;
+
+	RW_DATA(L1_CACHE_BYTES, PAGE_SIZE, THREAD_ALIGN)
+
+	.got : { *(.got*) }
+
+#ifdef CONFIG_RELOCATABLE
+	.data.rel : { *(.data.rel*) }
+	.plt : { *(.plt) }
+	.dynamic : { *(.dynamic) }
+	.dynsym : { *(.dynsym) }
+	.dynstr : { *(.dynstr) }
+	.hash : { *(.hash) }
+	.gnu.hash : { *(.gnu.hash) }
+#endif
+
+	/* End of data section */
+	_edata = .;
+
+	BSS_SECTION(PAGE_SIZE, PAGE_SIZE, 0)
+
+	_end = .;
+
+	STABS_DEBUG
+	DWARF_DEBUG
+	ELF_DETAILS
+
+	DISCARDS
+}
diff -urN --no-dereference linux-clean/arch/xr17032/lib/Makefile linux-workdir/arch/xr17032/lib/Makefile
--- linux-clean/arch/xr17032/lib/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0-only
+lib-y += delay.o
+lib-y += memset.o
diff -urN --no-dereference linux-clean/arch/xr17032/lib/delay.c linux-workdir/arch/xr17032/lib/delay.c
--- linux-clean/arch/xr17032/lib/delay.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/delay.c
@@ -0,0 +1,28 @@
+#include <linux/compiler.h>
+#include <linux/delay.h>
+
+noinline void __delay(unsigned long loops)
+{
+	asm volatile(
+		"	beq %0, 2f\n"
+		"	beq zero, 1f\n"
+		".balign 16\n"
+		"1:	subi %0, %0, 1\n"
+		"	bne %0, 1b\n"
+		"2:"
+		: "+r" (loops)
+	);
+}
+
+void __const_udelay(unsigned long xloops)
+{
+	xloops *= 4;
+	xloops = ((uint64_t)xloops * (loops_per_jiffy * (HZ / 4))) >> 32;
+
+	__delay(++xloops);
+}
+
+void __udelay(unsigned long loops)
+{
+	__const_udelay(loops * UDELAY_CONST_MULT);
+}
diff -urN --no-dereference linux-clean/arch/xr17032/lib/memset.S linux-workdir/arch/xr17032/lib/memset.S
--- linux-clean/arch/xr17032/lib/memset.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/memset.S
@@ -0,0 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/linkage.h>
diff -urN --no-dereference linux-clean/arch/xr17032/mm/Makefile linux-workdir/arch/xr17032/mm/Makefile
--- linux-clean/arch/xr17032/mm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+obj-y += init.o
diff -urN --no-dereference linux-clean/arch/xr17032/mm/init.c linux-workdir/arch/xr17032/mm/init.c
--- linux-clean/arch/xr17032/mm/init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/init.c
@@ -0,0 +1,235 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/fixmap.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <linux/align.h>
+#include <linux/dma-map-ops.h>
+#include <linux/initrd.h>
+#include <linux/linkage.h>
+#include <linux/memblock.h>
+#include <linux/minmax.h>
+#include <linux/mm.h>
+#include <linux/mmzone.h>
+#include <linux/of_fdt.h>
+
+void *_dtb_early_va;
+uintptr_t _dtb_early_pa;
+
+unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)]
+__page_aligned_bss;
+
+static pte_t fixmap_pte[PTRS_PER_PTE] __page_aligned_bss;
+
+static const pgprot_t protection_map[] = {
+	[VM_NONE]					= PAGE_NONE,
+	[VM_READ]					= PAGE_READ,
+	[VM_WRITE]					= PAGE_COPY,
+	[VM_WRITE | VM_READ]				= PAGE_COPY,
+	[VM_EXEC]					= PAGE_EXEC,
+	[VM_EXEC | VM_READ]				= PAGE_READ_EXEC,
+	[VM_EXEC | VM_WRITE]				= PAGE_COPY_EXEC,
+	[VM_EXEC | VM_WRITE | VM_READ]			= PAGE_COPY_EXEC,
+	[VM_SHARED]					= PAGE_NONE,
+	[VM_SHARED | VM_READ]				= PAGE_READ,
+	[VM_SHARED | VM_WRITE]				= PAGE_SHARED,
+	[VM_SHARED | VM_WRITE | VM_READ]		= PAGE_SHARED,
+	[VM_SHARED | VM_EXEC]				= PAGE_EXEC,
+	[VM_SHARED | VM_EXEC | VM_READ]			= PAGE_READ_EXEC,
+	[VM_SHARED | VM_EXEC | VM_WRITE]		= PAGE_SHARED_EXEC,
+	[VM_SHARED | VM_EXEC | VM_WRITE | VM_READ]	= PAGE_SHARED_EXEC
+};
+
+DECLARE_VM_GET_PAGE_PROT
+
+phys_addr_t dma32_phys_limit;
+
+void __set_fixmap(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot)
+{
+	unsigned long addr = __fix_to_virt(idx);
+	pte_t *ptep;
+
+	BUG_ON(idx <= FIX_HOLE || idx >= __end_of_fixed_addresses);
+
+	ptep = &fixmap_pte[pte_index(addr)];
+
+	if (pgprot_val(prot))
+		set_pte(ptep, pfn_pte(phys >> PAGE_SHIFT, prot));
+	else
+		pte_clear(&init_mm, addr, ptep);
+	local_flush_tlb_page(addr);
+}
+
+static void __meminit create_pgd_mapping(pgd_t *pgdp, uintptr_t va, phys_addr_t pa)
+{
+	uintptr_t pgd_idx = pgd_index(va);
+
+	BUG_ON(pgd_val(pgdp[pgd_idx]));
+
+	pgdp[pgd_idx] = pfn_pgd(PFN_DOWN(pa), PAGE_TABLE);
+}
+
+static void __init reserve_mapped_memory(void)
+{
+	pte_t *cur_pte = (pte_t *)_PGTABLE_ADDR;
+	pgd_t *cur_pgd = swapper_pg_dir;
+
+	for (unsigned i = 0; i < PTRS_PER_PGD; i++) {
+		pgd_t pgd_entry = *cur_pgd++;
+
+		if (pgd_val(pgd_entry)) {
+			for (unsigned j = 0; j < PTRS_PER_PTE; j++) {
+				pte_t pte_entry = *cur_pte++;
+
+				if (pte_val(pte_entry)) {
+					unsigned long pfn = pte_pfn(pte_entry);
+					memblock_reserve(pfn << PAGE_SHIFT,
+							 PAGE_SIZE);
+				}
+			}
+		} else {
+			cur_pte += PTRS_PER_PTE;
+		}
+	}
+}
+
+asmlinkage void __init setup_vm(uintptr_t dtb_pa);
+
+asmlinkage void __init setup_vm(uintptr_t dtb_pa)
+{
+	extern char _end[];
+
+	_dtb_early_va = (void *)ALIGN((uintptr_t)_end, PAGE_SIZE);
+	_dtb_early_pa = dtb_pa;
+
+	pgd_t *early_pg_dir = (pgd_t *)_PGD_ADDR;
+
+	*(pte_t *)(_PGTABLE_ADDR | (_SWAPPER_PGD_ADDR >> 10))
+		= pfn_pte(__pa(early_pg_dir) >> PAGE_SHIFT, PAGE_KERNEL);
+	create_pgd_mapping(early_pg_dir, FIXADDR_START, __pa(fixmap_pte));
+
+	local_flush_tlb_all();
+
+	reserve_mapped_memory();
+}
+
+static void __init setup_bootmem(void)
+{
+	phys_addr_t max_mapped_addr = __pa(-PAGE_SIZE);
+	memblock_reserve(max_mapped_addr, (phys_addr_t)-max_mapped_addr);
+
+	phys_addr_t phys_ram_base = memblock_start_of_DRAM();
+	phys_addr_t phys_ram_end = memblock_end_of_DRAM();
+
+	min_low_pfn = PFN_UP(phys_ram_base);
+	max_low_pfn = max_pfn = PFN_DOWN(phys_ram_end);
+
+	reserve_initrd_mem();
+	early_init_fdt_scan_reserved_mem();
+
+	dma32_phys_limit = max(4UL * SZ_1G,
+			       (unsigned long)PFN_PHYS(max_low_pfn));
+
+	dma_contiguous_reserve(dma32_phys_limit);
+}
+
+static void __meminit create_linear_mapping_range(phys_addr_t start,
+						  phys_addr_t end)
+{
+	pgd_t *pgdp = swapper_pg_dir;
+
+	uintptr_t vhead = (uintptr_t)__va(start);
+	uintptr_t vtail = (uintptr_t)__va(end - 1);
+
+	uintptr_t pgd_head = pgd_index(vhead);
+	uintptr_t pte_head = pte_index(vhead);
+
+	uintptr_t pgd_tail = pgd_index(vtail);
+	uintptr_t pte_tail = pte_index(vtail);
+
+	for (uintptr_t pgd_idx = pgd_head; pgd_idx <= pgd_tail; pgd_idx++) {
+		uintptr_t cur_pte_tail;
+
+		if (pgd_idx != pgd_tail)
+			cur_pte_tail = PTRS_PER_PTE - 1;
+		else
+			cur_pte_tail = pte_tail;
+
+		clear_fixmap(FIX_PTE);
+
+		phys_addr_t pte_phys;
+		pte_t *ptep;
+
+		if (pgd_val(pgdp[pgd_idx]) == 0) {
+			pte_phys = memblock_phys_alloc(PAGE_SIZE, PAGE_SIZE);
+			pgdp[pgd_idx] = pfn_pgd(PFN_DOWN(pte_phys), PAGE_TABLE);
+			ptep = (pte_t *)set_fixmap_offset(FIX_PTE, pte_phys);
+			memset(ptep, 0, PAGE_SIZE);
+		} else {
+			ptep = (pte_t *)set_fixmap_offset(FIX_PTE, pte_phys);
+		}
+
+		for (uintptr_t pte_idx = pte_head; pte_idx <= cur_pte_tail;
+		     pte_idx++) {
+			unsigned long pfn = PFN_DOWN(start);
+			ptep[pte_idx] = pfn_pte(pfn, PAGE_KERNEL_EXEC);
+			start += PAGE_SIZE;
+		}
+
+		pte_head = 0;
+	}
+}
+
+static void __init create_linear_mapping_page_table(void)
+{
+	phys_addr_t start, end;
+	u64 i;
+
+	for_each_mem_range(i, &start, &end) {
+		if (start >= end)
+			break;
+		if (start <= __pa(PAGE_OFFSET) && __pa(PAGE_OFFSET) < end)
+			start = __pa(PAGE_OFFSET);
+
+		create_linear_mapping_range(start, end);
+	}
+}
+
+static void __init setup_vm_final(void)
+{
+	create_linear_mapping_page_table();
+
+	clear_fixmap(FIX_PTE);
+
+	local_flush_tlb_all();
+}
+
+void __init paging_init(void)
+{
+	setup_bootmem();
+	setup_vm_final();
+	memblock_allow_resize();
+}
+
+static void __init zone_sizes_init(void)
+{
+	unsigned long max_zone_pfns[MAX_NR_ZONES] = { 0, };
+
+#ifdef CONFIG_ZONE_DMA32
+	max_zone_pfns[ZONE_DMA32] = PFN_DOWN(dma32_phys_limit);
+#endif
+	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
+
+	free_area_init(max_zone_pfns);
+}
+
+void __init misc_mem_init(void)
+{
+	early_memtest(min_low_pfn << PAGE_SHIFT, max_low_pfn << PAGE_SHIFT);
+	sparse_init();
+	zone_sizes_init();
+	memblock_dump_all();
+}
diff -urN --no-dereference linux-clean/drivers/tty/serial/Kconfig linux-workdir/drivers/tty/serial/Kconfig
--- linux-clean/drivers/tty/serial/Kconfig
+++ linux-workdir/drivers/tty/serial/Kconfig
@@ -1604,6 +1604,15 @@
 	  snippet may be used:
 	    earlycon=esp32s3acm,mmio32,0x60038000
 
+config SERIAL_XRCOMPUTER
+	tristate "XR/computer UART support"
+	depends on OF
+	select SERIAL_CORE
+	select SERIAL_CORE_CONSOLE
+	select SERIAL_EARLYCON
+	help
+	  Driver for the UART controller of the XR/computer platform.
+
 endmenu
 
 config SERIAL_MCTRL_GPIO
diff -urN --no-dereference linux-clean/drivers/tty/serial/Makefile linux-workdir/drivers/tty/serial/Makefile
--- linux-clean/drivers/tty/serial/Makefile
+++ linux-workdir/drivers/tty/serial/Makefile
@@ -92,6 +92,7 @@
 obj-$(CONFIG_SERIAL_UARTLITE)		+= uartlite.o
 obj-$(CONFIG_SERIAL_VT8500)		+= vt8500_serial.o
 obj-$(CONFIG_SERIAL_XILINX_PS_UART)	+= xilinx_uartps.o
+obj-$(CONFIG_SERIAL_XRCOMPUTER)		+= xrcomputer.o
 obj-$(CONFIG_SERIAL_ZS)			+= zs.o
 
 # GPIOLIB helpers for modem control lines
diff -urN --no-dereference linux-clean/drivers/tty/serial/xrcomputer.c linux-workdir/drivers/tty/serial/xrcomputer.c
--- linux-clean/drivers/tty/serial/xrcomputer.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/tty/serial/xrcomputer.c
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * XR/computer UART driver
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/serial_core.h>
+
+#define UART_CMD_REG	0x00
+#define UART_DATA_REG	0x04
+
+static void xrarch_serial_write(struct uart_port *port, unsigned long reg,
+				u32 v)
+{
+	writel(v, port->membase + reg);
+}
+
+static u32 xrarch_serial_read(struct uart_port *port, unsigned long reg)
+{
+	return readl(port->membase + reg);
+}
+
+static bool xrarch_serial_tx_full(struct uart_port *port)
+{
+	return xrarch_serial_read(port, UART_CMD_REG) != 0;
+}
+
+static void xrarch_serial_put_char(struct uart_port *port, u8 c)
+{
+	xrarch_serial_write(port, UART_DATA_REG, c);
+}
+
+static void xrarch_serial_put_char_sync(struct uart_port *port, u8 c)
+{
+	unsigned long timeout = jiffies + HZ;
+
+	while (xrarch_serial_tx_full(port)) {
+		if (time_after(jiffies, timeout)) {
+			dev_warn(port->dev, "timeout waiting for TX\n");
+			return;
+		}
+
+		cpu_relax();
+	}
+
+	xrarch_serial_put_char(port, c);
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+static int xrarch_serial_poll_get_char(struct uart_port *port)
+{
+	u32 value = xrarch_serial_read(port, UART_DATA_REG);
+
+	if (value != 0xFFFF)
+		return value;
+	else
+		return NO_POLL_CHAR;
+
+}
+#endif
+
+static void xrarch_serial_earlycon_putchar(struct uart_port *port, u8 c)
+{
+	xrarch_serial_put_char_sync(port, c);
+}
+
+static void xrarch_serial_earlycon_write(struct console *con, const char *s,
+				         unsigned int n)
+{
+	struct earlycon_device *dev = con->data;
+
+	uart_console_write(&dev->port, s, n, xrarch_serial_earlycon_putchar);
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+static int xrarch_serial_earlycon_read(struct console *con, char *s,
+				       unsigned int n)
+{
+	struct earlycon_device *dev = con->data;
+	unsigned int num_read = 0;
+
+	while (num_read < n) {
+		int c = xrarch_serial_poll_get_char(&dev->port);
+
+		if (c == NO_POLL_CHAR)
+			break;
+
+		s[num_read++] = c;
+	}
+
+	return num_read;
+}
+#endif
+
+static int __init xrarch_serial_earlycon_setup(struct earlycon_device *device,
+					       const char *options)
+{
+	if (!device->port.membase)
+		return -ENODEV;
+
+	device->con->write = xrarch_serial_earlycon_write;
+#ifdef CONFIG_CONSOLE_POLL
+	device->con->read = xrarch_serial_earlycon_read;
+#endif
+
+	return 0;
+}
+
+OF_EARLYCON_DECLARE(xrarch_serial, "xrarch,serial",
+		    xrarch_serial_earlycon_setup);
+
+MODULE_AUTHOR("monkuous");
+MODULE_DESCRIPTION("XR/computer UART support");
+MODULE_LICENSE("GPL");
diff -urN --no-dereference linux-clean/include/uapi/linux/audit.h linux-workdir/include/uapi/linux/audit.h
--- linux-clean/include/uapi/linux/audit.h
+++ linux-workdir/include/uapi/linux/audit.h
@@ -444,6 +444,7 @@
 #define AUDIT_ARCH_TILEPRO	(EM_TILEPRO|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_UNICORE	(EM_UNICORE|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_XR17032	(EM_XR17032|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_XTENSA	(EM_XTENSA)
 #define AUDIT_ARCH_LOONGARCH32	(EM_LOONGARCH|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_LOONGARCH64	(EM_LOONGARCH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
diff -urN --no-dereference linux-clean/include/uapi/linux/elf-em.h linux-workdir/include/uapi/linux/elf-em.h
--- linux-clean/include/uapi/linux/elf-em.h
+++ linux-workdir/include/uapi/linux/elf-em.h
@@ -67,5 +67,8 @@
 /* Also Panasonic/MEI MN10300, AM33 */
 #define EM_CYGNUS_MN10300 0xbeef
 
+/* XR/17032 */
+#define EM_XR17032	0xb5f0
+
 
 #endif /* _LINUX_ELF_EM_H */
