diff -urN --no-dereference linux-clean/arch/xr17032/Kbuild linux-workdir/arch/xr17032/Kbuild
--- linux-clean/arch/xr17032/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kbuild
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+obj-y += kernel/ mm/
+
+subdir- += boot/
diff -urN --no-dereference linux-clean/arch/xr17032/Kconfig linux-workdir/arch/xr17032/Kconfig
--- linux-clean/arch/xr17032/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kconfig
@@ -0,0 +1,42 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config XR17032
+	def_bool y
+	select GENERIC_ATOMIC64
+	select THREAD_INFO_IN_TASK
+	select HAVE_PAGE_SIZE_4KB
+	select ARCH_SPARSEMEM_ENABLE
+	select GENERIC_IOREMAP
+	select FUNCTION_ALIGNMENT_4B
+	select GENERIC_IRQ_SHOW
+	select GENERIC_LIB_ASHLDI3
+	select GENERIC_LIB_LSHRDI3
+	select GENERIC_LIB_MULDI3
+	select OF
+	select OF_EARLY_FLATTREE
+	select GENERIC_EARLY_IOREMAP
+	select GENERIC_IRQ_MULTI_HANDLER
+	select XR17032_INTC
+	select XRARCH_LSIC
+	select XRARCH_RTC
+	select GENERIC_ENTRY
+	select HAVE_SYSCALL_TRACEPOINTS
+	select GENERIC_CPU_DEVICES
+
+config MMU
+	def_bool y
+
+config GENERIC_CALIBRATE_DELAY
+	def_bool y
+
+config GENERIC_HWEIGHT
+	def_bool y
+
+config FIX_EARLYCON_MEM
+	def_bool MMU
+
+menu "Kernel features"
+
+source "kernel/Kconfig.hz"
+
+endmenu
diff -urN --no-dereference linux-clean/arch/xr17032/Kconfig.debug linux-workdir/arch/xr17032/Kconfig.debug
--- linux-clean/arch/xr17032/Kconfig.debug	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kconfig.debug
@@ -0,0 +1 @@
+# SPDX-License-Identifier: GPL-2.0-only
diff -urN --no-dereference linux-clean/arch/xr17032/Makefile linux-workdir/arch/xr17032/Makefile
--- linux-clean/arch/xr17032/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Makefile
@@ -0,0 +1,36 @@
+# This file is included by the global makefile so that you can add your own
+# architecture-specific flags and dependencies.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+
+KBUILD_DEFCONFIG	:= xr17032_defconfig
+
+UTS_MACHINE	:= xr17032
+
+KBUILD_CFLAGS	+= -fno-pic
+
+libs-y		+= arch/xr17032/lib/
+
+boot		:= arch/xr17032/boot
+KBUILD_IMAGE	:= $(boot)/Image
+
+BOOT_TARGETS	:= Image
+
+$(BOOT_TARGETS): vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
+	@$(kecho) '  Kernel: $(boot)/$@ is ready'
+
+all: $(notdir $(KBUILD_IMAGE))
+
+install:
+	$(call cmd,install)
+
+define archhelp
+  echo  '  Image	- Uncompressed kernel image (arch/xr17032/boot/Image)'
+  echo  '  install	- Install kernel using (your) ~/bin/$(INSTALLKERNEL) or'
+  echo  '		  (distribution) /sbin/$(INSTALLKERNEL) or install to '
+  echo  '		  $$(INSTALL_PATH)'
+endef
diff -urN --no-dereference linux-clean/arch/xr17032/boot/Makefile linux-workdir/arch/xr17032/boot/Makefile
--- linux-clean/arch/xr17032/boot/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/boot/Makefile
@@ -0,0 +1,24 @@
+#
+# arch/riscv/boot/Makefile
+#
+# This file is included by the global makefile so that you can add your own
+# architecture-specific flags and dependencies.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 2025, monkuous.
+# Author: monkuous
+#
+
+OBJCOPYFLAGS_Image := -O binary -R .note -R .note.gnu.build-id -R .comment -S
+
+targets := Image
+
+ifdef CONFIG_RELOCATABLE
+$(obj)/Image: vmlinux.unstripped FORCE
+else
+$(obj)/Image: vmlinux FORCE
+endif
+	$(call if_changed,objcopy)
diff -urN --no-dereference linux-clean/arch/xr17032/configs/xr17032_defconfig linux-workdir/arch/xr17032/configs/xr17032_defconfig
--- linux-clean/arch/xr17032/configs/xr17032_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/configs/xr17032_defconfig
@@ -0,0 +1,2 @@
+CONFIG_SERIAL_XRCOMPUTER=y
+CONFIG_PRINTK_TIME=y
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/Kbuild linux-workdir/arch/xr17032/include/asm/Kbuild
--- linux-clean/arch/xr17032/include/asm/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/Kbuild
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+generic-y += string.h
+generic-y += user.h
+generic-y += kvm_para.h
+generic-y += vmlinux.lds.h
+generic-y += early_ioremap.h
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/asm-extable.h linux-workdir/arch/xr17032/include/asm/asm-extable.h
--- linux-clean/arch/xr17032/include/asm/asm-extable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/asm-extable.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ASM_EXTABLE_H
+#define _ASM_XR17032_ASM_EXTABLE_H
+
+#define EX_TYPE_NONE			0
+#define EX_TYPE_FIXUP			1
+#define EX_TYPE_UACCESS_ERR_ZERO	2
+
+#include <linux/bits.h>
+#include <linux/stringify.h>
+#include <asm/gpr-num.h>
+
+#define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
+	".pushsection	__ex_table, \"a\"\n"		\
+	".balign	4\n"				\
+	".long		(" insn ")\n"		\
+	".long		(" fixup ")\n"		\
+	".short		(" type ")\n"			\
+	".short		(" data ")\n"			\
+	".popsection\n"
+
+#define _ASM_EXTABLE(insn, fixup)	\
+	__ASM_EXTABLE_RAW(#insn, #fixup, __stringify(EX_TYPE_FIXUP), "0")
+
+#define EX_DATA_REG_ERR_SHIFT	0
+#define EX_DATA_REG_ERR		GENMASK(4, 0)
+#define EX_DATA_REG_ZERO_SHIFT	5
+#define EX_DATA_REG_ZERO	GENMASK(9, 5)
+
+#define EX_DATA_REG_DATA_SHIFT	0
+#define EX_DATA_REG_DATA	GENMASK(4, 0)
+#define EX_DATA_REG_ADDR_SHIFT	5
+#define EX_DATA_REG_ADDR	GENMASK(9, 5)
+
+#define EX_DATA_REG(reg, gpr)						\
+	"((.L__gpr_num_" #gpr ") << " __stringify(EX_DATA_REG_##reg##_SHIFT) ")"
+
+#define _ASM_EXTABLE_UACCESS_ERR_ZERO(insn, fixup, err, zero)		\
+	__DEFINE_ASM_GPR_NUMS						\
+	__ASM_EXTABLE_RAW(#insn, #fixup, 				\
+			  __stringify(EX_TYPE_UACCESS_ERR_ZERO),	\
+			  "("						\
+			    EX_DATA_REG(ERR, err) " | "			\
+			    EX_DATA_REG(ZERO, zero)			\
+			  ")")
+
+#define _ASM_EXTABLE_UACCESS_ERR(insn, fixup, err)			\
+	_ASM_EXTABLE_UACCESS_ERR_ZERO(insn, fixup, err, zero)
+
+#endif /* _ASM_XR17032_ASM_EXTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/atomic.h linux-workdir/arch/xr17032/include/asm/atomic.h
--- linux-clean/arch/xr17032/include/asm/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/atomic.h
@@ -0,0 +1,111 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ATOMIC_H
+#define _ASM_XR17032_ATOMIC_H
+
+#ifndef CONFIG_GENERIC_ATOMIC64
+#error "xr17032 does not support 64-bit atomics"
+#endif
+
+#include <asm/cmpxchg.h>
+#include <asm-generic/atomic64.h>
+
+static inline int arch_atomic_read(const atomic_t *v)
+{
+	return READ_ONCE(v->counter);
+}
+
+static inline void arch_atomic_set(atomic_t *v, int i)
+{
+	WRITE_ONCE(v->counter, i);
+}
+
+#define __ATOMIC_OP(op, asm_op)						\
+static inline void arch_atomic_##op(int i, atomic_t *v)			\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %0, %0, %z3\n"			\
+		"	sc  %1, %2, %0\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+}
+
+#define __ATOMIC_OP_RETURN(op, asm_op)					\
+static inline int arch_atomic_##op##_return_relaxed(int i, atomic_t *v)	\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %0, %0, %z3\n"			\
+		"	sc  %1, %2, %0\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+									\
+	return ret;							\
+}
+
+#define __ATOMIC_FETCH_OP(op, asm_op)					\
+static inline int arch_atomic_fetch_##op##_relaxed(int i, atomic_t *v)	\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %1, %0, %z3\n"			\
+		"	sc  %1, %2, %1\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+									\
+	return ret;							\
+}
+
+__ATOMIC_OP_RETURN(add, "add")
+__ATOMIC_OP_RETURN(sub, "sub")
+
+__ATOMIC_FETCH_OP(add, "add")
+__ATOMIC_FETCH_OP(sub, "sub")
+__ATOMIC_FETCH_OP(and, "and")
+__ATOMIC_FETCH_OP(or, "or")
+__ATOMIC_FETCH_OP(xor, "xor")
+
+__ATOMIC_OP(add, "add")
+__ATOMIC_OP(sub, "sub")
+__ATOMIC_OP(and, "and")
+__ATOMIC_OP(or, "or")
+__ATOMIC_OP(xor, "xor")
+
+#define arch_atomic_add_return_relaxed arch_atomic_add_return_relaxed
+#define arch_atomic_sub_return_relaxed arch_atomic_sub_return_relaxed
+
+#define arch_atomic_fetch_add_relaxed arch_atomic_fetch_add_relaxed
+#define arch_atomic_fetch_sub_relaxed arch_atomic_fetch_sub_relaxed
+#define arch_atomic_fetch_and_relaxed arch_atomic_fetch_and_relaxed
+#define arch_atomic_fetch_or_relaxed  arch_atomic_fetch_or_relaxed
+#define arch_atomic_fetch_xor_relaxed arch_atomic_fetch_xor_relaxed
+
+#define arch_atomic_add arch_atomic_add
+#define arch_atomic_sub arch_atomic_sub
+#define arch_atomic_and arch_atomic_and
+#define arch_atomic_or  arch_atomic_or
+#define arch_atomic_xor arch_atomic_xor
+
+#endif /* _ASM_XR17032_ATOMIC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/barrier.h linux-workdir/arch/xr17032/include/asm/barrier.h
--- linux-clean/arch/xr17032/include/asm/barrier.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/barrier.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_BARRIER_H
+#define _ASM_XR17032_BARRIER_H
+
+#define nop()	({asm volatile("addi zero, zero, 0");})
+
+#define __mb()	({asm volatile("mb");})
+#define __wmb()	({asm volatile("wmb");})
+#define __rmb()	({asm volatile("mb");})
+
+#include <asm-generic/barrier.h>
+
+#endif /* _ASM_XR17032_BARRIER_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cache.h linux-workdir/arch/xr17032/include/asm/cache.h
--- linux-clean/arch/xr17032/include/asm/cache.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cache.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CACHE_H
+#define _ASM_XR17032_CACHE_H
+
+#define L1_CACHE_SHIFT 4
+#define L1_CACHE_BYTES (1 << L1_CACHE_SHIFT)
+
+#endif /* _ASM_XR17032_CACHE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cmpxchg.h linux-workdir/arch/xr17032/include/asm/cmpxchg.h
--- linux-clean/arch/xr17032/include/asm/cmpxchg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cmpxchg.h
@@ -0,0 +1,137 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CMPXCHG_H
+#define _ASM_XR17032_CMPXCHG_H
+
+#include <linux/bug.h>
+
+#define __arch_xchg_masked(mask, ret, scratch, ptr, new)		\
+({									\
+	unsigned long __address = (unsigned long)ptr;			\
+	unsigned long __offset = __address & 3;				\
+	unsigned long __shift = __offset * 8;				\
+	unsigned long __mask = mask << __shift;				\
+	unsigned long __new_shift = (unsigned long)new << __shift;	\
+	unsigned long __ret_shift;					\
+	__address -= __offset;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	and %1, %0, %z3\n"				\
+		"	or  %1, %1, %z4\n"				\
+		"	sc  %1, %2, %1\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (__ret_shift), "=&r" (scratch)			\
+		: "r" (__address), "rO" (~__mask), "rO" (__new_shift)	\
+		: "memory"						\
+	);								\
+									\
+	ret = (typeof(ret))((__ret_shift & __mask) >> __shift);		\
+})
+
+#define arch_xchg_relaxed(ptr, new)					\
+({									\
+	typeof(ptr) __ptr = (ptr);					\
+	typeof(*__ptr) __new = (new);					\
+	typeof(*__ptr) __ret;						\
+	unsigned long __scratch;					\
+									\
+	switch (sizeof(*__ptr)) {					\
+	case 1:								\
+		__arch_xchg_masked(0xff, __ret, __scratch, __ptr,	\
+				   __new); 				\
+		break;							\
+	case 2:								\
+		__arch_xchg_masked(0xffff, __ret, __scratch, __ptr,	\
+				   __new); 				\
+		break;							\
+	case 4:								\
+		asm volatile(						\
+			"1:	ll  %0, %2\n"				\
+			"	sc  %1, %2, %z3\n"			\
+			"	beq %1, 1b"				\
+			: "=&r" (__ret), "=&r" (__scratch)		\
+			: "r" (__ptr), "rO" (__new)			\
+			: "memory"					\
+		);							\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+									\
+	__ret;								\
+})
+
+#define __arch_cmpxchg_masked(mask, ret, scratch, ptr, old, new)	\
+({									\
+	unsigned long __address = (unsigned long)ptr;			\
+	unsigned long __offset = __address & 3;				\
+	unsigned long __shift = __offset * 8;				\
+	unsigned long __mask = mask << __shift;				\
+	unsigned long __old_shift = (unsigned long)old << __shift;	\
+	unsigned long __new_shift = (unsigned long)new << __shift;	\
+	unsigned long __ret_shift;					\
+	unsigned long __scratch2;					\
+	__address -= __offset;						\
+									\
+	asm volatile(							\
+		"1:	ll  %1, %3\n"					\
+		"	and %0, %1, %z4\n"				\
+		"	sub %2, %0, %z5\n"				\
+		"	bne %2, 1f\n"					\
+		"	and %1, %1, %z6\n"				\
+		"	or  %1, %1, %z7\n"				\
+		"	sc  %1, %3, %1\n"				\
+		"	beq %1, 1b\n"					\
+		"1:"							\
+		: "=&r" (__ret_shift), "=&r" (scratch),			\
+		  "=&r" (__scratch2)					\
+		: "r" (__address), "rO" (__mask), "rO" (__old_shift),	\
+		  "rO" (~__mask), "rO" (__new_shift)			\
+		: "memory"						\
+	);								\
+									\
+	ret = (typeof(ret))(__ret_shift >> __shift);			\
+})
+
+#define arch_cmpxchg_relaxed(ptr, old, new)				\
+({									\
+	typeof(ptr) __ptr = (ptr);					\
+	typeof(*__ptr) __old = (old);					\
+	typeof(*__ptr) __new = (new);					\
+	typeof(*__ptr) __ret;						\
+	unsigned long __scratch;					\
+									\
+	switch (sizeof(*__ptr)) {					\
+	case 1:								\
+		__arch_cmpxchg_masked(0xff, __ret, __scratch, __ptr,	\
+				      __old, __new);			\
+		break;							\
+	case 2:								\
+		__arch_cmpxchg_masked(0xffff, __ret, __scratch, __ptr,	\
+				      __old, __new);			\
+		break;							\
+	case 4:								\
+		asm volatile(						\
+			"1:	ll  %0, %2\n"				\
+			"	sub %1, %0, %z3\n"			\
+			"	bne %1, 1f\n"				\
+			"	sc  %1, %2, %z4\n"			\
+			"	beq %1, 1b\n"				\
+			"1:"						\
+			: "=&r" (__ret), "=&r" (__scratch)		\
+			: "r" (__ptr), "rO" (__old), "rO" (__new)	\
+			: "memory"					\
+		);							\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+									\
+	__ret;								\
+})
+
+#endif /* _ASM_XR17032_CMPXCHG_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cr.h linux-workdir/arch/xr17032/include/asm/cr.h
--- linux-clean/arch/xr17032/include/asm/cr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cr.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CR_H
+#define _ASM_XR17032_CR_H
+
+#define RS_U		0x00000001UL
+#define RS_I		0x00000002UL
+#define RS_M		0x00000004UL
+#define RS_T		0x00000008UL
+#define RS_OLD_U	0x00000100UL
+#define RS_OLD_I	0x00000200UL
+#define RS_OLD_M	0x00000400UL
+#define RS_OLD_T	0x00000800UL
+
+#ifndef __ASSEMBLER__
+
+#define cr_read(cr) 			\
+({ 					\
+	unsigned long __v; 		\
+	asm volatile("mfcr %0, " #cr	\
+		     : "=r" (__v) :	\
+		     : "memory"); 	\
+	__v;				\
+})
+
+#define cr_write(cr, val)				\
+({							\
+	unsigned long __v = (unsigned long)(val);	\
+	asm volatile("mtcr " #cr ", %z0"		\
+		     : : "rO" (__v)			\
+		     : "memory");			\
+})
+
+#endif
+
+#endif /* _ASM_XR17032_CR_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/current.h linux-workdir/arch/xr17032/include/asm/current.h
--- linux-clean/arch/xr17032/include/asm/current.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/current.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CURRENT_H
+#define _ASM_XR17032_CURRENT_H
+
+struct task_struct;
+
+register struct task_struct *current asm("tp");
+register unsigned long current_stack_pointer asm("sp");
+
+#endif /* _ASM_XR17032_CURRENT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/elf.h linux-workdir/arch/xr17032/include/asm/elf.h
--- linux-clean/arch/xr17032/include/asm/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/elf.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ELF_H
+#define _ASM_XR17032_ELF_H
+
+#include <uapi/asm/elf.h>
+
+#define ELF_ARCH	EM_XR17032
+
+#ifndef ELF_CLASS
+#define ELF_CLASS	ELFCLASS32
+#endif
+
+#define ELF_DATA	ELFDATA2LSB
+
+#define ELF_EXEC_PAGESIZE	PAGE_SIZE
+#define ELF_PLATFORM		NULL
+#define ELF_HWCAP		0
+
+#define elf_check_arch(x) (((x)->e_machine == ELF_ARCH) &&		\
+			   ((x)->e_ident[EI_CLASS] == ELF_CLASS))
+
+#define ELF_ET_DYN_BASE		((DEFAULT_MAP_WINDOW / 3) * 2)
+
+#endif /* _ASM_XR17032_ELF_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/entry-common.h linux-workdir/arch/xr17032/include/asm/entry-common.h
--- linux-clean/arch/xr17032/include/asm/entry-common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/entry-common.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ENTRY_COMMON_H
+#define _ASM_XR17032_ENTRY_COMMON_H
+
+#include <asm/stacktrace.h>
+
+#endif /* _ASM_XR17032_ENTRY_COMMON_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/extable.h linux-workdir/arch/xr17032/include/asm/extable.h
--- linux-clean/arch/xr17032/include/asm/extable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/extable.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_EXTABLE_H
+#define _ASM_XR17032_EXTABLE_H
+
+struct exception_table_entry {
+	unsigned long insn, fixup;
+	short type, data;
+};
+
+#endif /* _ASM_XR17032_EXTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/fixmap.h linux-workdir/arch/xr17032/include/asm/fixmap.h
--- linux-clean/arch/xr17032/include/asm/fixmap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/fixmap.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_FIXMAP_H
+#define _ASM_XR17032_FIXMAP_H
+
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <linux/sizes.h>
+
+enum fixed_addresses {
+	FIX_HOLE,
+
+	FIX_EARLYCON_MEM_BASE,
+	FIX_TEMP,
+
+	__end_of_permanent_fixed_addresses,
+	/*
+	 * Temporary boot-time mappings, used by early_ioremap(),
+	 * before ioremap() is functional.
+	 */
+	#define NR_FIX_BTMAPS		(SZ_256K / PAGE_SIZE)
+	#define FIX_BTMAPS_SLOTS	7
+	#define TOTAL_FIX_BTMAPS	(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)
+
+	FIX_BTMAP_END = __end_of_permanent_fixed_addresses,
+	FIX_BTMAP_BEGIN = FIX_BTMAP_END + TOTAL_FIX_BTMAPS - 1,
+
+	__end_of_fixed_addresses
+};
+
+#define __early_set_fixmap	__set_fixmap
+
+extern void __set_fixmap(enum fixed_addresses idx,
+			 phys_addr_t phys, pgprot_t prot);
+
+#include <asm-generic/fixmap.h>
+
+#endif /* _ASM_XR17032_FIXMAP_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/gpr-num.h linux-workdir/arch/xr17032/include/asm/gpr-num.h
--- linux-clean/arch/xr17032/include/asm/gpr-num.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/gpr-num.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_GPR_NUM_H
+#define _ASM_XR17032_GPR_NUM_H
+
+#define __DEFINE_ASM_GPR_NUMS					\
+"	.equ	.L__gpr_num_zero,	0\n"			\
+"	.equ	.L__gpr_num_t0,		1\n"			\
+"	.equ	.L__gpr_num_t1,		2\n"			\
+"	.equ	.L__gpr_num_t2,		3\n"			\
+"	.equ	.L__gpr_num_t3,		4\n"			\
+"	.equ	.L__gpr_num_t4,		5\n"			\
+"	.equ	.L__gpr_num_t5,		6\n"			\
+"	.equ	.L__gpr_num_a0,		7\n"			\
+"	.equ	.L__gpr_num_a1,		8\n"			\
+"	.equ	.L__gpr_num_a2,		9\n"			\
+"	.equ	.L__gpr_num_a3,		10\n"			\
+"	.equ	.L__gpr_num_s0,		11\n"			\
+"	.equ	.L__gpr_num_s1,		12\n"			\
+"	.equ	.L__gpr_num_s2,		13\n"			\
+"	.equ	.L__gpr_num_s3,		14\n"			\
+"	.equ	.L__gpr_num_s4,		15\n"			\
+"	.equ	.L__gpr_num_s5,		16\n"			\
+"	.equ	.L__gpr_num_s6,		17\n"			\
+"	.equ	.L__gpr_num_s7,		18\n"			\
+"	.equ	.L__gpr_num_s8,		19\n"			\
+"	.equ	.L__gpr_num_s9,		20\n"			\
+"	.equ	.L__gpr_num_s10,	21\n"			\
+"	.equ	.L__gpr_num_s11,	22\n"			\
+"	.equ	.L__gpr_num_s12,	23\n"			\
+"	.equ	.L__gpr_num_s13,	24\n"			\
+"	.equ	.L__gpr_num_s14,	25\n"			\
+"	.equ	.L__gpr_num_s15,	26\n"			\
+"	.equ	.L__gpr_num_s16,	27\n"			\
+"	.equ	.L__gpr_num_t17,	28\n"			\
+"	.equ	.L__gpr_num_tp,		29\n"			\
+"	.equ	.L__gpr_num_sp,		30\n"			\
+"	.equ	.L__gpr_num_lr,		31\n"
+
+#endif /* _ASM_XR17032_GPR_NUM_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/irq.h linux-workdir/arch/xr17032/include/asm/irq.h
--- linux-clean/arch/xr17032/include/asm/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/irq.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_IRQ_H
+#define _ASM_XR17032_IRQ_H
+
+#include <asm-generic/irq.h>
+#include <linux/irqdomain.h>
+
+extern struct irq_domain *xr17032_intc_domain;
+
+#endif /* _ASM_XR17032_IRQ_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/irqflags.h linux-workdir/arch/xr17032/include/asm/irqflags.h
--- linux-clean/arch/xr17032/include/asm/irqflags.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/irqflags.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_IRQFLAGS_H
+#define _ASM_XR17032_IRQFLAGS_H
+
+#include <asm/cr.h>
+
+static inline unsigned long arch_local_save_flags(void)
+{
+	return cr_read(rs);
+}
+
+static inline void arch_local_irq_restore(unsigned long flags)
+{
+	cr_write(rs, cr_read(rs) | (flags & RS_I));
+}
+
+static inline void arch_local_irq_enable(void)
+{
+	arch_local_irq_restore(RS_I);
+}
+
+static inline void arch_local_irq_disable(void)
+{
+	arch_local_irq_restore(0);
+}
+
+static inline unsigned long arch_local_irq_save(void)
+{
+	unsigned long flags = cr_read(rs);
+	cr_write(rs, flags & ~RS_I);
+	return flags;
+}
+
+static inline int arch_irqs_disabled_flags(unsigned long flags)
+{
+	return !(flags & RS_I);
+}
+
+static inline int arch_irqs_disabled(void)
+{
+	return arch_irqs_disabled_flags(arch_local_save_flags());
+}
+
+#endif /* _ASM_XR17032_IRQFLAGS_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/mmu_context.h linux-workdir/arch/xr17032/include/asm/mmu_context.h
--- linux-clean/arch/xr17032/include/asm/mmu_context.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/mmu_context.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_MMU_CONTEXT_H
+#define _ASM_XR17032_MMU_CONTEXT_H
+
+#include <linux/mm_types.h>
+#include <asm-generic/mm_hooks.h>
+
+#include <linux/mm.h>
+#include <linux/sched.h>
+
+void switch_mm(struct mm_struct *prev, struct mm_struct *next,
+	       struct task_struct *task);
+
+#include <asm-generic/mmu_context.h>
+
+#endif /* _ASM_XR17032_MMU_CONTEXT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/page.h linux-workdir/arch/xr17032/include/asm/page.h
--- linux-clean/arch/xr17032/include/asm/page.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/page.h
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PAGE_H
+#define _ASM_XR17032_PAGE_H
+
+#include <linux/pfn.h>
+#include <vdso/page.h>
+
+#define PAGE_OFFSET		_AC(0xc0000000, UL)
+#define TASK_SIZE		_AC(0x80000000, UL)
+#define _PGTABLE_ADDR		TASK_SIZE
+
+#ifndef __ASSEMBLER__
+
+#define clear_page(pgaddr)			memset((pgaddr), 0, PAGE_SIZE)
+#define clear_user_page(pgaddr, vaddr, page)	clear_page(pgaddr)
+
+#define copy_page(to, from)			memcpy((to), (from), PAGE_SIZE)
+#define copy_user_page(vto, vfrom, vaddr, topg)	\
+			memcpy((vto), (vfrom), PAGE_SIZE)
+
+typedef struct {
+	unsigned long pgd;
+} pgd_t;
+
+typedef struct {
+	unsigned long pte;
+} pte_t;
+
+typedef struct {
+	unsigned long pgprot;
+} pgprot_t;
+
+typedef struct page *pgtable_t;
+
+#define pte_val(x)	((x).pte)
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x)	((pte_t) { (x) })
+#define __pgd(x)	((pgd_t) { (x) })
+#define __pgprot(x)	((pgprot_t) { (x) })
+
+#define is_linear_mapping(x)	((x) >= PAGE_OFFSET)
+
+#define linear_mapping_va_to_pa(x)	((unsigned long)(x) - PAGE_OFFSET)
+#define kernel_mapping_va_to_pa(x)					\
+({									\
+	unsigned long _y = ((unsigned long)(x) >> 10) & ~3UL;		\
+	_y |= _PGTABLE_ADDR;						\
+	_y = *(unsigned long *)_y;					\
+	(_y & ~0x1fUL) << 7;						\
+})
+
+#define __pa(x)								\
+({									\
+	unsigned long _x = (unsigned long)(x);				\
+	is_linear_mapping(_x) ? linear_mapping_va_to_pa(_x) 		\
+			      : kernel_mapping_va_to_pa(_x);		\
+})
+#define __va(x)	((void *)((unsigned long)(x) + PAGE_OFFSET))
+
+#define phys_to_pfn(phys)	(PFN_DOWN(phys))
+#define pfn_to_phys(pfn)	(PFN_PHYS(pfn))
+
+#define virt_to_pfn(vaddr)	(phys_to_pfn(__pa(vaddr)))
+#define pfn_to_virt(pfn)	(__va(pfn_to_phys(pfn)))
+
+#define virt_to_page(vaddr)	(pfn_to_page(virt_to_pfn(vaddr)))
+
+#define virt_addr_valid(vaddr)	({						\
+	unsigned long _addr = (unsigned long)vaddr;				\
+	(unsigned long)(_addr) >= PAGE_OFFSET && pfn_valid(virt_to_pfn(_addr));	\
+})
+
+#define PTE_FMT	"%08lx"
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#include <asm-generic/memory_model.h>
+#include <asm-generic/getorder.h>
+
+#endif /* _ASM_XR17032_PAGE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/pgalloc.h linux-workdir/arch/xr17032/include/asm/pgalloc.h
--- linux-clean/arch/xr17032/include/asm/pgalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/pgalloc.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PGALLOC_H
+#define _ASM_XR17032_PGALLOC_H
+
+#include <linux/mm.h>
+#include <asm/tlb.h>
+#include <asm-generic/pgalloc.h>
+
+static inline void sync_kernel_mappings(pgd_t *pgd)
+{
+	memcpy(pgd + USER_PTRS_PER_PGD,
+	       init_mm.pgd + USER_PTRS_PER_PGD,
+	       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
+}
+
+static inline pgd_t *pgd_alloc(struct mm_struct *mm)
+{
+	pgd_t *pgd;
+
+	pgd = __pgd_alloc(mm, 0);
+	if (likely(pgd != NULL)) {
+		/* Copy kernel mappings */
+		sync_kernel_mappings(pgd);
+	}
+	return pgd;
+}
+
+static inline void __pte_free_tlb(struct mmu_gather *tlb, pgtable_t pte,
+				  unsigned long addr)
+{
+	tlb_remove_ptdesc(tlb, page_ptdesc(pte));
+}
+
+static inline void pmd_populate_kernel(struct mm_struct *mm,
+				       pmd_t *pmd, pte_t *pte)
+{
+	unsigned long pfn = virt_to_pfn(pte);
+
+	set_pmd(pmd, __pmd((pfn << PFN_PTE_SHIFT) | _PAGE_TABLE));
+}
+
+static inline void pmd_populate(struct mm_struct *mm,
+				pmd_t *pmd, pgtable_t pte)
+{
+	unsigned long pfn = virt_to_pfn(page_address(pte));
+
+	set_pmd(pmd, __pmd((pfn << PFN_PTE_SHIFT) | _PAGE_TABLE));
+}
+
+#endif /* _ASM_XR17032_PGALLOC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/pgtable.h linux-workdir/arch/xr17032/include/asm/pgtable.h
--- linux-clean/arch/xr17032/include/asm/pgtable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/pgtable.h
@@ -0,0 +1,307 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PGTABLE_H
+#define _ASM_XR17032_PGTABLE_H
+
+#include <asm/page.h>
+#include <linux/const.h>
+
+#define PGDIR_SHIFT	22
+#define PGDIR_SIZE	(_AC(1, UL) << PGDIR_SHIFT)
+#define PGDIR_MASK	(~(PGDIR_SIZE - 1))
+
+#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
+#define _PGD_ADDR		(_PGTABLE_ADDR | (_PGTABLE_ADDR >> 10))
+#define _SWAPPER_PGD_ADDR	(_PGTABLE_ADDR + PGDIR_SIZE)
+#define KERNEL_LINK_ADDR	(_SWAPPER_PGD_ADDR + PAGE_SIZE)
+
+#define PTRS_PER_PGD	(PAGE_SIZE / 4)
+#define PTRS_PER_PTE	(PAGE_SIZE / 4)
+
+#define KERN_VIRT_SIZE	((PTRS_PER_PGD / 2 * PGDIR_SIZE) / 2)
+
+#define VMALLOC_SIZE	(KERN_VIRT_SIZE >> 1)
+#define VMALLOC_END	PAGE_OFFSET
+#define VMALLOC_START	(PAGE_OFFSET - VMALLOC_SIZE)
+
+#define FIXADDR_TOP	VMALLOC_START
+#define FIXADDR_SIZE	PGDIR_SIZE
+#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
+
+#ifndef __ASSEMBLER__
+
+#include <asm/tlbflush.h>
+#include <asm-generic/pgtable-nopmd.h>
+#include <linux/mmzone.h>
+
+#define PFN_PTE_SHIFT	5
+
+#define _PAGE_PRESENT	(1 << 0)
+#define _PAGE_WRITE	(1 << 1)
+#define _PAGE_KERNEL	(1 << 2)
+#define _PAGE_NO_CACHE	(1 << 3)
+#define _PAGE_GLOBAL	(1 << 4)
+#define _PAGE_ACCESSED	(1 << 25)
+#define _PAGE_DIRTY	(1 << 26)
+
+#define _PAGE_CHG_MASK  (~(unsigned long)(_PAGE_PRESENT | _PAGE_WRITE |	\
+					  _PAGE_KERNEL | _PAGE_GLOBAL))
+
+#define _PAGE_PROT_NONE	_PAGE_GLOBAL
+
+#define _PAGE_BASE	(_PAGE_PRESENT | _PAGE_ACCESSED)
+
+#define PAGE_NONE	__pgprot(_PAGE_PROT_NONE)
+#define PAGE_READ	__pgprot(_PAGE_BASE)
+#define PAGE_WRITE	__pgprot(_PAGE_BASE | _PAGE_WRITE)
+#define PAGE_EXEC	__pgprot(_PAGE_BASE)
+#define PAGE_READ_EXEC	__pgprot(_PAGE_BASE)
+#define PAGE_WRITE_EXEC	__pgprot(_PAGE_BASE | _PAGE_WRITE)
+
+#define PAGE_COPY		PAGE_READ
+#define PAGE_COPY_EXEC		PAGE_READ_EXEC
+#define PAGE_SHARED		PAGE_WRITE
+#define PAGE_SHARED_EXEC	PAGE_WRITE_EXEC
+
+#define _PAGE_SWP_EXCLUSIVE (1 << 5)
+
+#define _PAGE_KERNEL_BASE	(_PAGE_PRESENT \
+				| _PAGE_WRITE \
+				| _PAGE_KERNEL \
+				| _PAGE_GLOBAL \
+				| _PAGE_ACCESSED \
+				| _PAGE_DIRTY)
+
+#define _PAGE_TABLE		_PAGE_KERNEL_BASE
+#define _PAGE_IOREMAP		(_PAGE_KERNEL_BASE | _PAGE_NO_CACHE)
+
+#define PAGE_KERNEL		__pgprot(_PAGE_KERNEL_BASE)
+#define PAGE_KERNEL_READ	__pgprot(_PAGE_KERNEL_BASE & ~_PAGE_WRITE)
+#define PAGE_KERNEL_EXEC	__pgprot(_PAGE_KERNEL_BASE)
+#define PAGE_KERNEL_READ_EXEC	__pgprot(_PAGE_KERNEL_BASE & ~_PAGE_WRITE)
+#define PAGE_KERNEL_IO		__pgprot(_PAGE_IOREMAP)
+#define PAGE_TABLE		__pgprot(_PAGE_TABLE)
+
+#define __page_val_to_pfn(_val)  (((_val) & GENMASK(24, 5)) >> PFN_PTE_SHIFT)
+
+#define swapper_pg_dir ((pgd_t *)_SWAPPER_PGD_ADDR)
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero,
+ * used for zero-mapped memory areas, etc.
+ */
+extern unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)];
+#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
+
+#define pgd_ERROR(e) \
+	pr_err("%s:%d: bad pgd " PTE_FMT ".\n", __FILE__, __LINE__, pgd_val(e))
+
+static inline pte_t pfn_pte(unsigned long pfn, pgprot_t prot)
+{
+	return __pte((pfn << PFN_PTE_SHIFT) | pgprot_val(prot));
+}
+
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{
+	return __pte((pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot));
+}
+
+static inline int pte_present(pte_t pte)
+{
+	return pte_val(pte) & (_PAGE_PRESENT | _PAGE_PROT_NONE);
+}
+
+static inline int pte_none(pte_t pte)
+{
+	return pte_val(pte) == 0;
+}
+
+static inline int pte_write(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_WRITE;
+}
+
+static inline int pte_young(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_ACCESSED;
+}
+
+static inline int pte_dirty(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_DIRTY;
+}
+
+static inline unsigned long pte_pfn(pte_t pte)
+{
+	return __page_val_to_pfn(pte_val(pte));
+}
+
+#define pte_page(x)	pfn_to_page(pte_pfn(x))
+
+static inline pte_t pte_mkold(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_ACCESSED);
+}
+
+static inline pte_t pte_mkyoung(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_ACCESSED);
+}
+
+static inline pte_t pte_mkclean(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_DIRTY);
+}
+
+static inline pte_t pte_mkdirty(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_DIRTY);
+}
+
+static inline pte_t pte_mkwrite_novma(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_WRITE);
+}
+
+static inline pte_t pte_wrprotect(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_WRITE);
+}
+
+static inline void set_pte(pte_t *ptep, pte_t pteval)
+{
+	WRITE_ONCE(*ptep, pteval);
+}
+
+void flush_icache_pte(struct mm_struct *mm, pte_t pte);
+
+static inline void __set_pte_at(struct mm_struct *mm, pte_t *ptep, pte_t pteval)
+{
+	if (pte_present(pteval))
+		flush_icache_pte(mm, pteval);
+
+	set_pte(ptep, pteval);
+}
+
+static inline void pte_clear(struct mm_struct *mm,
+			     unsigned long addr, pte_t *ptep)
+{
+	__set_pte_at(mm, ptep, __pte(0));
+}
+
+/*
+ * Encode/decode swap entries and swap PTEs. Swap PTEs are all PTEs that
+ * are !pte_none() && !pte_present().
+ *
+ * Format of swap PTE:
+ *	bit            0:	_PAGE_PRESENT (zero)
+ *	bit            1:	_PAGE_WRITE (zero)
+ *	bit            2:	_PAGE_KERNEL (zero)
+ *	bit            3:	_PAGE_NO_CACHE (zero)
+ *	bit            4:	_PAGE_PROT_NONE (zero)
+ *	bit            5:	exclusive marker
+ *	bits      6 to 11:	swap type
+ *	bits     12 to 31:	swap offset
+ */
+#define __SWP_TYPE_SHIFT	5
+#define __SWP_TYPE_BITS		6
+#define __SWP_TYPE_MASK		((1UL << __SWP_TYPE_BITS) - 1)
+#define __SWP_OFFSET_SHIFT	(__SWP_TYPE_BITS + __SWP_TYPE_SHIFT)
+
+#define MAX_SWAPFILES_CHECK()	\
+	BUILD_BUG_ON(MAX_SWAPFILES_SHIFT > __SWP_TYPE_BITS)
+
+#define __swp_type(x)	(((x).val >> __SWP_TYPE_SHIFT) & __SWP_TYPE_MASK)
+#define __swp_offset(x)	((x).val >> __SWP_OFFSET_SHIFT)
+#define __swp_entry(type, offset) ((swp_entry_t) \
+	{ (((type) & __SWP_TYPE_MASK) << __SWP_TYPE_SHIFT) | \
+	  ((offset) << __SWP_OFFSET_SHIFT) })
+
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })
+
+static inline bool pte_swp_exclusive(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_SWP_EXCLUSIVE;
+}
+
+static inline pte_t pte_swp_clear_exclusive(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_SWP_EXCLUSIVE);
+}
+
+static inline pte_t pte_swp_mkexclusive(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_SWP_EXCLUSIVE);
+}
+
+static inline pgd_t pfn_pgd(unsigned long pfn, pgprot_t prot)
+{
+	return __pgd((pfn << PFN_PTE_SHIFT) | pgprot_val(prot));
+}
+
+static inline void set_pmd(pmd_t *pmdp, pmd_t pmd)
+{
+	WRITE_ONCE(*pmdp, pmd);
+}
+
+static inline void pmd_clear(pmd_t *pmdp)
+{
+	set_pmd(pmdp, __pmd(0));
+}
+
+static inline int pmd_none(pmd_t pmd)
+{
+	return pmd_val(pmd) == 0;
+}
+
+static inline int pmd_bad(pmd_t pmd)
+{
+	return 0;
+}
+
+static inline int pmd_present(pmd_t pmd)
+{
+	return (pmd_val(pmd) & (_PAGE_PRESENT | _PAGE_PROT_NONE));
+}
+
+static inline struct page *pmd_page(pmd_t pmd)
+{
+	return pfn_to_page(__page_val_to_pfn(pmd_val(pmd)));
+}
+
+static inline unsigned long pmd_page_vaddr(pmd_t pmd)
+{
+	return (unsigned long)pfn_to_virt(__page_val_to_pfn(pmd_val(pmd)));
+}
+
+#define __pmd_to_phys(pmd)  (__page_val_to_pfn(pmd_val(pmd)) << PAGE_SHIFT)
+
+static inline unsigned long pmd_pfn(pmd_t pmd)
+{
+	return ((__pmd_to_phys(pmd) & PMD_MASK) >> PAGE_SHIFT);
+}
+
+static inline void update_mmu_cache_range(struct vm_fault *vmf,
+					  struct vm_area_struct *vma, unsigned long address,
+					  pte_t *ptep, unsigned int nr)
+{
+	while (nr--)
+		local_flush_tlb_page(address + nr * PAGE_SIZE);
+}
+
+#define update_mmu_cache(vma, addr, ptep)	\
+	update_mmu_cache_range(NULL, vma, addr, ptep, 1)
+
+extern void *_dtb_early_va;
+extern uintptr_t _dtb_early_pa;
+
+void paging_init(void);
+void misc_mem_init(void);
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#endif /* _ASM_XR17032_PGTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/processor.h linux-workdir/arch/xr17032/include/asm/processor.h
--- linux-clean/arch/xr17032/include/asm/processor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/processor.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PROCESSOR_H
+#define _ASM_XR17032_PROCESSOR_H
+
+#define DEFAULT_MAP_WINDOW	TASK_SIZE
+#define STACK_TOP_MAX		TASK_SIZE
+
+#define STACK_ALIGN		4
+#define STACK_TOP		DEFAULT_MAP_WINDOW
+#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
+
+struct pt_regs;
+
+static inline void cpu_relax(void)
+{
+	asm volatile("pause" ::: "memory");
+}
+
+struct thread_struct {
+	/* Callee-saved registers */
+	unsigned long s[18];
+	unsigned long sp;
+	unsigned long lr;
+};
+
+#define INIT_THREAD					\
+{							\
+	.sp = sizeof(init_stack) + (long)&init_stack,	\
+}
+
+#define task_pt_regs(tsk)						\
+	((struct pt_regs *)(task_stack_page(tsk) + THREAD_SIZE		\
+			    - ALIGN(sizeof(struct pt_regs), STACK_ALIGN)))
+
+#define KSTK_EIP(tsk)	(task_pt_regs(tsk)->pc)
+#define KSTK_ESP(tsk)	(task_pt_regs(tsk)->sp)
+
+extern unsigned long __get_wchan(struct task_struct *p);
+
+extern void start_thread(struct pt_regs *regs,
+			 unsigned long pc, unsigned long sp);
+
+#endif /* _ASM_XR17032_PROCESSOR_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/ptrace.h linux-workdir/arch/xr17032/include/asm/ptrace.h
--- linux-clean/arch/xr17032/include/asm/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/ptrace.h
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PTRACE_H
+#define _ASM_XR17032_PTRACE_H
+
+#include <asm/cr.h>
+#include <linux/compiler.h>
+#include <uapi/asm/ptrace.h>
+
+struct pt_regs {
+	unsigned long t0;
+	unsigned long t1;
+	unsigned long t2;
+	unsigned long t3;
+	unsigned long t4;
+	unsigned long t5;
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long s0;
+	unsigned long s1;
+	unsigned long s2;
+	unsigned long s3;
+	unsigned long s4;
+	unsigned long s5;
+	unsigned long s6;
+	unsigned long s7;
+	unsigned long s8;
+	unsigned long s9;
+	unsigned long s10;
+	unsigned long s11;
+	unsigned long s12;
+	unsigned long s13;
+	unsigned long s14;
+	unsigned long s15;
+	unsigned long s16;
+	unsigned long s17;
+	unsigned long tp;
+	unsigned long sp;
+	unsigned long lr;
+	unsigned long pc;
+	unsigned long rs;
+	unsigned long orig_a3;
+};
+
+#define PTRACE_SYSEMU 0x1f
+#define PTRACE_SYSEMU_SINGLESTEP 0x20
+
+#define user_mode(regs) (((regs)->rs & RS_OLD_U) != 0)
+
+static inline unsigned long user_stack_pointer(struct pt_regs *regs)
+{
+	return regs->sp;
+}
+
+static inline unsigned long instruction_pointer(struct pt_regs *regs)
+{
+	return regs->pc;
+}
+
+static inline bool regs_irqs_disabled(struct pt_regs *regs)
+{
+	return !(regs->rs & RS_OLD_I);
+}
+
+#endif /* _ASM_XR17032_PTRACE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/set_memory.h linux-workdir/arch/xr17032/include/asm/set_memory.h
--- linux-clean/arch/xr17032/include/asm/set_memory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/set_memory.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SET_MEMORY_H
+#define _ASM_XR17032_SET_MEMORY_H
+
+#define SECTION_ALIGN L1_CACHE_BYTES
+
+#endif /* _ASM_XR17032_SET_MEMORY_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/smp.h linux-workdir/arch/xr17032/include/asm/smp.h
--- linux-clean/arch/xr17032/include/asm/smp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/smp.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SMP_H
+#define _ASM_XR17032_SMP_H
+
+#include <asm/errno.h>
+
+extern unsigned long boot_cpu_hwid;
+
+#ifdef CONFIG_SMP
+#error "TODO"
+#else
+
+static inline int xr17032_cpu_hwid_to_cpuid(unsigned long cpu_hwid)
+{
+	if (cpu_hwid == boot_cpu_hwid)
+		return 0;
+
+	return -ENOENT;
+}
+
+#endif /* CONFIG_SMP */
+
+#endif /* _ASM_XR17032_SMP_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/sparsemem.h linux-workdir/arch/xr17032/include/asm/sparsemem.h
--- linux-clean/arch/xr17032/include/asm/sparsemem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/sparsemem.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SPARSEMEM_H
+#define _ASM_XR17032_SPARSEMEM_H
+
+#ifdef CONFIG_SPARSEMEM
+#define MAX_PHYSMEM_BITS	32
+#define SECTION_SIZE_BITS	25
+#endif
+
+#endif /* _ASM_XR17032_SPARSEMEM_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/stacktrace.h linux-workdir/arch/xr17032/include/asm/stacktrace.h
--- linux-clean/arch/xr17032/include/asm/stacktrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/stacktrace.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_STACKTRACE_H
+#define _ASM_XR17032_STACKTRACE_H
+
+#include <linux/sched.h>
+
+static inline bool on_thread_stack(void)
+{
+	return !(((unsigned long)(current->stack) ^ current_stack_pointer)
+		 & ~(THREAD_SIZE - 1));
+}
+
+#endif /* _ASM_XR17032_STACKTRACE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/syscall.h linux-workdir/arch/xr17032/include/asm/syscall.h
--- linux-clean/arch/xr17032/include/asm/syscall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/syscall.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SYSCALL_H
+#define _ASM_XR17032_SYSCALL_H
+
+#include <uapi/linux/audit.h>
+
+static inline int syscall_get_arch(struct task_struct *task)
+{
+	return AUDIT_ARCH_XR17032;
+}
+
+static inline int syscall_get_nr(struct task_struct *task, struct pt_regs *regs)
+{
+	return regs->a0;
+}
+
+static inline void syscall_rollback(struct task_struct *task,
+				    struct pt_regs *regs)
+{
+	regs->a3 = regs->orig_a3;
+}
+
+static inline long syscall_get_return_value(struct task_struct *task,
+					    struct pt_regs *regs)
+{
+	return regs->a3;
+}
+
+static inline void syscall_get_arguments(struct task_struct *task,
+					 struct pt_regs *regs,
+					 unsigned long *args)
+{
+	args[0] = regs->t0;
+	args[1] = regs->t1;
+	args[2] = regs->t2;
+	args[3] = regs->t3;
+	args[4] = regs->t4;
+	args[5] = regs->t5;
+}
+
+static inline bool arch_syscall_is_vdso_sigreturn(struct pt_regs *regs)
+{
+	return false;
+}
+
+#endif /* _ASM_XR17032_SYSCALL_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/thread_info.h linux-workdir/arch/xr17032/include/asm/thread_info.h
--- linux-clean/arch/xr17032/include/asm/thread_info.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/thread_info.h
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_THREAD_INFO_H
+#define _ASM_XR17032_THREAD_INFO_H
+
+#include <asm/page.h>
+
+#define THREAD_SIZE_ORDER 	0
+#define THREAD_SIZE		(PAGE_SIZE << THREAD_SIZE_ORDER)
+#define THREAD_ALIGN		THREAD_SIZE
+
+#ifndef __ASSEMBLER__
+
+struct thread_info {
+	unsigned long 	flags;
+	int		preempt_count;
+	unsigned long	kernel_sp;
+	unsigned long	syscall_work;
+};
+
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.flags		= 0,			\
+	.preempt_count	= INIT_PREEMPT_COUNT,	\
+}
+
+#define TIF_NEED_RESCHED 0
+#define TIF_NOTIFY_SIGNAL 1
+#define TIF_SIGPENDING 2
+#define TIF_SYSCALL_TRACE 3
+#define TIF_MEMDIE 4
+#define TIF_NOTIFY_RESUME 5
+
+#define _TIF_NEED_RESCHED (1 << TIF_NEED_RESCHED)
+#define _TIF_NOTIFY_SIGNAL (1 << TIF_NOTIFY_SIGNAL)
+#define _TIF_SIGPENDING (1 << TIF_SIGPENDING)
+#define _TIF_SYSCALL_TRACE (1 << TIF_SYSCALL_TRACE)
+#define _TIF_MEMDIE (1 << TIF_MEMDIE)
+#define _TIF_NOTIFY_RESUME (1 << TIF_NOTIFY_RESUME)
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#endif /* _ASM_XR17032_THREAD_INFO_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/tlb.h linux-workdir/arch/xr17032/include/asm/tlb.h
--- linux-clean/arch/xr17032/include/asm/tlb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/tlb.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_TLB_H
+#define _ASM_XR17032_TLB_H
+
+struct mmu_gather;
+
+static void tlb_flush(struct mmu_gather *tlb);
+
+#define tlb_flush tlb_flush
+#include <asm-generic/tlb.h>
+
+static inline void tlb_flush(struct mmu_gather *tlb)
+{
+	if (tlb->fullmm || tlb->need_flush_all || tlb->freed_tables)
+		flush_tlb_mm(tlb->mm);
+	else
+		flush_tlb_mm_range(tlb->mm, tlb->start, tlb->end,
+				   tlb_get_unmap_size(tlb));
+}
+
+#endif /* _ASM_XR17032_TLB_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/tlbflush.h linux-workdir/arch/xr17032/include/asm/tlbflush.h
--- linux-clean/arch/xr17032/include/asm/tlbflush.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/tlbflush.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_TLBFLUSH_H
+#define _ASM_XR17032_TLBFLUSH_H
+
+#include <asm/pgtable.h>
+#include <linux/mm_types.h>
+
+void flush_tlb_mm(struct mm_struct *mm);
+void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
+			unsigned long end, unsigned int page_size);
+void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr);
+void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+		     unsigned long end);
+void flush_tlb_kernel_range(unsigned long start, unsigned long end);
+
+static inline void local_flush_tlb_all(void)
+{
+	asm volatile("mtcr itbctrl, %0" :: "r" (1UL) : "memory");
+	asm volatile("mtcr dtbctrl, %0" :: "r" (1UL) : "memory");
+}
+
+static inline void local_flush_tlb_page(unsigned long addr)
+{
+	addr &= ~0xfffUL;
+	asm volatile("mtcr itbctrl, %0" :: "r" (addr) : "memory");
+	asm volatile("mtcr dtbctrl, %0" :: "r" (addr) : "memory");
+	asm volatile(
+		"mtcr dtbctrl, %0"
+		:
+		: "r" (_PGTABLE_ADDR | (addr >> 10))
+		: "memory"
+	);
+}
+
+#endif /* _ASM_XR17032_TLBFLUSH_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/uaccess.h linux-workdir/arch/xr17032/include/asm/uaccess.h
--- linux-clean/arch/xr17032/include/asm/uaccess.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/uaccess.h
@@ -0,0 +1,251 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_UACCESS_H
+#define _ASM_XR17032_UACCESS_H
+
+#include <asm/asm-extable.h>
+#include <asm/extable.h>
+#include <asm/pgtable.h>
+#include <asm-generic/access_ok.h>
+#include <linux/compiler.h>
+#include <linux/errno.h>
+
+unsigned long __must_check __asm_copy_to_user(void __user *to,
+					      const void *from,
+					      unsigned long n);
+unsigned long __must_check __asm_copy_from_user(void *to,
+						const void __user *from,
+						unsigned long n);
+
+#ifdef CONFIG_CC_HAS_ASM_GOTO_OUTPUT
+#define __get_user_asm(x, ptr, label)				\
+	asm_goto_output(					\
+		"1:\n"						\
+		"	mov %0, %1\n"				\
+		_ASM_EXTABLE_UACCESS_ERR(1b, %l2, %0)		\
+		: "=&r" (x)					\
+		: "m" (*(ptr)) : : label			\
+	)
+#define __get_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u32 __lo, __hi;						\
+	asm_goto_output(					\
+		"1:\n"						\
+		"	mov %0, %2\n"				\
+		"2:\n"						\
+		"	mov %1, %3\n"				\
+		_ASM_EXTABLE_UACCESS_ERR(1b, %l4, %0)		\
+		_ASM_EXTABLE_UACCESS_ERR(2b, %l4, %0)		\
+		: "=&r" (__lo), "=r" (__hi)			\
+		: "m" (__ptr[0]), "m" (__ptr[1])		\
+		: : label);                                     \
+	(x) = (typeof(x))((typeof((x) - (x)))(			\
+		(((u64)__hi << 32) | __lo)));			\
+} while (0)
+#else /* !CONFIG_CC_HAS_ASM_GOTO_OUTPUT */
+#define __get_user_asm(x, ptr, label)				\
+do {								\
+	long __gua_err = 0;					\
+	asm volatile(						\
+		"1:\n"						\
+		"	mov %1, %2\n"				\
+		"2:\n"						\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(1b, 2b, %0, %1)	\
+		: "+r" (__gua_err), "=&r" (x)			\
+		: "m" (*(ptr))					\
+	);							\
+	if (__gua_err)						\
+		goto label;					\
+} while (0)
+#define __get_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u32 __lo, __hi;						\
+	long __gu8_err = 0;					\
+	__asm__ __volatile__ (					\
+		"1:\n"						\
+		"	mov %1, %3\n"				\
+		"2:\n"						\
+		"	mov %2, %4\n"				\
+		"3:\n"						\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(1b, 3b, %0, %1)	\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(2b, 3b, %0, %1)	\
+		: "+r" (__gu8_err), "=&r" (__lo), "=r" (__hi)	\
+		: "m" (__ptr[0]), "m" (__ptr[1]));		\
+	if (__gu8_err) {					\
+		__hi = 0;					\
+		goto label;					\
+	}							\
+	(x) = (typeof(x))((typeof((x) - (x)))(			\
+		(((u64)__hi << 32) | __lo)));			\
+} while (0)
+#endif /* CONFIG_CC_HAS_ASM_GOTO_OUTPUT */
+
+#define __get_user_nocheck(x, __gu_ptr, label)				\
+do {									\
+	if (!IS_ALIGNED((uintptr_t)__gu_ptr, sizeof(*__gu_ptr))) {	\
+		if (__asm_copy_from_user((void *)&(x),			\
+					 (const void *)__gu_ptr,	\
+			                 sizeof(*__gu_ptr))) 		\
+			goto label;					\
+		break;							\
+	}								\
+	switch (sizeof(*__gu_ptr)) {					\
+	case 1:								\
+	case 2:								\
+	case 4:								\
+		__get_user_asm((x), __gu_ptr, label);			\
+		break;							\
+	case 8:								\
+		__get_user_8((x), __gu_ptr, label);			\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+} while (0)
+
+#define __get_user_error(x, ptr, err)					\
+do {									\
+	__label__ __gu_failed;						\
+									\
+	__get_user_nocheck(x, ptr, __gu_failed);			\
+		err = 0;						\
+		break;							\
+__gu_failed:								\
+		x = 0;							\
+		err = -EFAULT;						\
+} while (0)
+
+#define __get_user(x, ptr)					\
+({								\
+	const typeof(*(ptr)) __user *__gu_ptr = (ptr);		\
+	long __gu_err = 0;					\
+	typeof(x) __gu_val;					\
+								\
+	__chk_user_ptr(__gu_ptr);				\
+								\
+	__get_user_error(__gu_val, __gu_ptr, __gu_err);		\
+								\
+	(x) = __gu_val;						\
+								\
+	__gu_err;						\
+})
+
+#define get_user(x, ptr)					\
+({								\
+	const typeof(*(ptr)) __user *__p = (ptr);		\
+	might_fault();						\
+	access_ok(__p, sizeof(*__p)) ?				\
+		__get_user((x), __p) :				\
+		((x) = (__force typeof(x))0, -EFAULT);		\
+})
+
+#define __put_user_asm(x, ptr, label)				\
+do {								\
+	typeof(*(ptr)) __x = x;					\
+	asm goto(						\
+		"1:\n"						\
+		"	mov %1, %z0\n"				\
+		_ASM_EXTABLE(1b, %l2)				\
+		: : "rO" (__x), "m"(*(ptr)) : : label);		\
+} while (0)
+#define __put_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u64 __x = (typeof((x)-(x)))(x);				\
+	asm goto(						\
+		"1:\n"						\
+		"	mov %2, %z0\n"				\
+		"2:\n"						\
+		"	mov %3, %z1\n"				\
+		_ASM_EXTABLE(1b, %l4)				\
+		_ASM_EXTABLE(2b, %l4)				\
+		: : "rO" ((u32)__x), "rO" ((u32)(__x >> 32)),	\
+			"m" (__ptr[0]),				\
+			"m" (__ptr[1]) : : label);		\
+} while (0)
+
+#define __put_user_nocheck(x, __gu_ptr, label)				\
+do {									\
+	if (!IS_ALIGNED((uintptr_t)__gu_ptr, sizeof(*__gu_ptr))) {	\
+		if (__asm_copy_to_user((void *)__gu_ptr,		\
+				       (const void *)&((x)),		\
+				       sizeof(*__gu_ptr)))		\
+			goto label;					\
+		break;							\
+	}								\
+	switch (sizeof(*__gu_ptr)) {					\
+	case 1:								\
+	case 2:								\
+	case 4:								\
+		__put_user_asm((x), __gu_ptr, label);			\
+		break;							\
+	case 8:								\
+		__put_user_8((x), __gu_ptr, label);			\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+} while (0)
+
+#define __put_user_error(x, ptr, err)				\
+do {								\
+	__label__ err_label;					\
+	__put_user_nocheck(x, ptr, err_label);			\
+	break;							\
+err_label:							\
+	(err) = -EFAULT;					\
+} while (0)
+
+#define __put_user(x, ptr)					\
+({								\
+	typeof(*(ptr)) __user *__gu_ptr = (ptr); 		\
+	typeof(*__gu_ptr) __val = (x);				\
+	long __pu_err = 0;					\
+								\
+	__chk_user_ptr(__gu_ptr);				\
+								\
+	__put_user_error(__val, __gu_ptr, __pu_err);		\
+								\
+	__pu_err;						\
+})
+
+#define put_user(x, ptr)					\
+({								\
+	typeof(*(ptr)) __user *__p = (ptr);			\
+	might_fault();						\
+	access_ok(__p, sizeof(*__p)) ? __put_user((x), __p)	\
+				     : -EFAULT;			\
+})
+
+static inline unsigned long
+raw_copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	return __asm_copy_from_user(to, from, n);
+}
+
+static inline unsigned long
+raw_copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	return __asm_copy_to_user(to, from, n);
+}
+
+extern unsigned long __must_check __clear_user(void __user *addr,
+					       unsigned long n);
+
+static inline unsigned long __must_check clear_user(void __user *to,
+						    unsigned long n)
+{
+	might_fault();
+	return access_ok(to, n) ? __clear_user(to, n) : n;
+}
+
+extern long strncpy_from_user(char *dest, const char __user *src, long count);
+
+extern long __must_check strnlen_user(const char __user *str, long n);
+
+#endif /* _ASM_XR17032_UACCESS_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/vmalloc.h linux-workdir/arch/xr17032/include/asm/vmalloc.h
--- linux-clean/arch/xr17032/include/asm/vmalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/vmalloc.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_VMALLOC_H
+#define _ASM_XR17032_VMALLOC_H
+
+#endif /* _ASM_XR17032_VMALLOC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/byteorder.h linux-workdir/arch/xr17032/include/uapi/asm/byteorder.h
--- linux-clean/arch/xr17032/include/uapi/asm/byteorder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/byteorder.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_BYTEORDER_H
+#define _UAPI_ASM_XR17032_BYTEORDER_H
+
+#include <linux/byteorder/little_endian.h>
+
+#endif /* _UAPI_ASM_XR17032_BYTEORDER_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/elf.h linux-workdir/arch/xr17032/include/uapi/asm/elf.h
--- linux-clean/arch/xr17032/include/uapi/asm/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/elf.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_ELF_H
+#define _UAPI_ASM_XR17032_ELF_H
+
+#include <asm/ptrace.h>
+
+typedef struct user_regs_struct elf_gregset_t;
+typedef unsigned int elf_fpregset_t;
+
+#endif /* _UAPI_ASM_XR17032_ELF_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/posix_types.h linux-workdir/arch/xr17032/include/uapi/asm/posix_types.h
--- linux-clean/arch/xr17032/include/uapi/asm/posix_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/posix_types.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_POSIX_TYPES_H
+#define _UAPI_ASM_XR17032_POSIX_TYPES_H
+
+typedef unsigned long	__kernel_size_t;
+typedef long		__kernel_ssize_t;
+typedef long		__kernel_ptrdiff_t;
+#define __kernel_size_t __kernel_size_t
+
+#include <asm-generic/posix_types.h>
+
+#endif /* _UAPI_ASM_XR17032_POSIX_TYPES_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/ptrace.h linux-workdir/arch/xr17032/include/uapi/asm/ptrace.h
--- linux-clean/arch/xr17032/include/uapi/asm/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/ptrace.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_PTRACE_H
+#define _UAPI_ASM_XR17032_PTRACE_H
+
+/* must be a prefix of struct pt_regs */
+struct user_regs_struct {
+	unsigned long t0;
+	unsigned long t1;
+	unsigned long t2;
+	unsigned long t3;
+	unsigned long t4;
+	unsigned long t5;
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long s0;
+	unsigned long s1;
+	unsigned long s2;
+	unsigned long s3;
+	unsigned long s4;
+	unsigned long s5;
+	unsigned long s6;
+	unsigned long s7;
+	unsigned long s8;
+	unsigned long s9;
+	unsigned long s10;
+	unsigned long s11;
+	unsigned long s12;
+	unsigned long s13;
+	unsigned long s14;
+	unsigned long s15;
+	unsigned long s16;
+	unsigned long s17;
+	unsigned long tp;
+	unsigned long sp;
+	unsigned long lr;
+	unsigned long pc;
+};
+
+#endif /* _UAPI_ASM_XR17032_PTRACE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/sigcontext.h linux-workdir/arch/xr17032/include/uapi/asm/sigcontext.h
--- linux-clean/arch/xr17032/include/uapi/asm/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/sigcontext.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_SIGCONTEXT_H
+#define _UAPI_ASM_XR17032_SIGCONTEXT_H
+
+#endif /* _UAPI_ASM_XR17032_SIGCONTEXT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/Makefile linux-workdir/arch/xr17032/kernel/Makefile
--- linux-clean/arch/xr17032/kernel/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/Makefile
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the XR/17032 Linux kernel
+#
+
+always-$(KBUILD_BUILTIN)	+= vmlinux.lds
+
+obj-y	+= entry.o
+obj-y	+= head.o
+obj-y	+= irq.o
+obj-y	+= process.o
+obj-y	+= setup.o
+obj-y	+= time.o
+
+obj-y	+= asm-stubs.o
+obj-y	+= stubs.o
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/asm-offsets.c linux-workdir/arch/xr17032/kernel/asm-offsets.c
--- linux-clean/arch/xr17032/kernel/asm-offsets.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/asm-offsets.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/ptrace.h>
+#include <linux/kbuild.h>
+#include <linux/sched.h>
+
+void asm_offsets(void);
+
+void asm_offsets(void)
+{
+	DEFINE(PT_SIZE_ON_STACK, ALIGN(sizeof(struct pt_regs), STACK_ALIGN));
+	OFFSET(PT_T0, pt_regs, t0);
+	OFFSET(PT_T1, pt_regs, t1);
+	OFFSET(PT_T2, pt_regs, t2);
+	OFFSET(PT_T3, pt_regs, t3);
+	OFFSET(PT_T4, pt_regs, t4);
+	OFFSET(PT_T5, pt_regs, t5);
+	OFFSET(PT_A0, pt_regs, a0);
+	OFFSET(PT_A1, pt_regs, a1);
+	OFFSET(PT_A2, pt_regs, a2);
+	OFFSET(PT_A3, pt_regs, a3);
+	OFFSET(PT_S0, pt_regs, s0);
+	OFFSET(PT_S1, pt_regs, s1);
+	OFFSET(PT_S2, pt_regs, s2);
+	OFFSET(PT_S3, pt_regs, s3);
+	OFFSET(PT_S4, pt_regs, s4);
+	OFFSET(PT_S5, pt_regs, s5);
+	OFFSET(PT_S6, pt_regs, s6);
+	OFFSET(PT_S7, pt_regs, s7);
+	OFFSET(PT_S8, pt_regs, s8);
+	OFFSET(PT_S9, pt_regs, s9);
+	OFFSET(PT_S10, pt_regs, s10);
+	OFFSET(PT_S11, pt_regs, s11);
+	OFFSET(PT_S12, pt_regs, s12);
+	OFFSET(PT_S13, pt_regs, s13);
+	OFFSET(PT_S14, pt_regs, s14);
+	OFFSET(PT_S15, pt_regs, s15);
+	OFFSET(PT_S16, pt_regs, s16);
+	OFFSET(PT_S17, pt_regs, s17);
+	OFFSET(PT_TP, pt_regs, tp);
+	OFFSET(PT_SP, pt_regs, sp);
+	OFFSET(PT_LR, pt_regs, lr);
+	OFFSET(PT_PC, pt_regs, pc);
+	OFFSET(PT_RS, pt_regs, rs);
+	OFFSET(TASK_THREAD_S0, task_struct, thread.s[0]);
+	OFFSET(TASK_THREAD_S1, task_struct, thread.s[1]);
+	OFFSET(TASK_THREAD_S2, task_struct, thread.s[2]);
+	OFFSET(TASK_THREAD_S3, task_struct, thread.s[3]);
+	OFFSET(TASK_THREAD_S4, task_struct, thread.s[4]);
+	OFFSET(TASK_THREAD_S5, task_struct, thread.s[5]);
+	OFFSET(TASK_THREAD_S6, task_struct, thread.s[6]);
+	OFFSET(TASK_THREAD_S7, task_struct, thread.s[7]);
+	OFFSET(TASK_THREAD_S8, task_struct, thread.s[8]);
+	OFFSET(TASK_THREAD_S9, task_struct, thread.s[9]);
+	OFFSET(TASK_THREAD_S10, task_struct, thread.s[10]);
+	OFFSET(TASK_THREAD_S11, task_struct, thread.s[11]);
+	OFFSET(TASK_THREAD_S12, task_struct, thread.s[12]);
+	OFFSET(TASK_THREAD_S13, task_struct, thread.s[13]);
+	OFFSET(TASK_THREAD_S14, task_struct, thread.s[14]);
+	OFFSET(TASK_THREAD_S15, task_struct, thread.s[15]);
+	OFFSET(TASK_THREAD_S16, task_struct, thread.s[16]);
+	OFFSET(TASK_THREAD_S17, task_struct, thread.s[17]);
+	OFFSET(TASK_THREAD_SP, task_struct, thread.sp);
+	OFFSET(TASK_THREAD_LR, task_struct, thread.lr);
+	OFFSET(TASK_TI_KERNEL_SP, task_struct, thread_info.kernel_sp);
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/asm-stubs.S linux-workdir/arch/xr17032/kernel/asm-stubs.S
--- linux-clean/arch/xr17032/kernel/asm-stubs.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/asm-stubs.S
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/linkage.h>
+
+.text
+
+SYM_FUNC_START(__asm_copy_from_user)
+	brk
+SYM_FUNC_END(__asm_copy_from_user)
+
+SYM_FUNC_START(__asm_copy_to_user)
+	brk
+SYM_FUNC_END(__asm_copy_to_user)
+
+SYM_FUNC_START(__clear_user)
+	brk
+SYM_FUNC_END(__clear_user)
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/entry.c linux-workdir/arch/xr17032/kernel/entry.c
--- linux-clean/arch/xr17032/kernel/entry.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/entry.c
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/irq_regs.h>
+#include <asm/ptrace.h>
+#include <linux/entry-common.h>
+#include <linux/hardirq.h>
+#include <linux/irq.h>
+#include <linux/linkage.h>
+#include <linux/panic.h>
+
+#define TRAP_FUNC_PROTO(name) asmlinkage void name(struct pt_regs *regs)
+#define TRAP_FUNC(name) TRAP_FUNC_PROTO(name); TRAP_FUNC_PROTO(name)
+
+TRAP_FUNC(xr17032_handle_interrupt)
+{
+	irqentry_state_t state = irqentry_enter(regs);
+
+	irq_enter_rcu();
+	struct pt_regs *old_regs = set_irq_regs(regs);
+	handle_arch_irq(regs);
+	set_irq_regs(old_regs);
+	irq_exit_rcu();
+
+	irqentry_exit(regs, state);
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/head.S linux-workdir/arch/xr17032/kernel/head.S
--- linux-clean/arch/xr17032/kernel/head.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/head.S
@@ -0,0 +1,425 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/cr.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/thread_info.h>
+#include <generated/asm-offsets.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+
+__HEAD
+.Lexception_block:
+
+SYM_DATA_START_LOCAL(xrlinux_header)
+	.long 0x584c5258		# magic
+	.word 0				# minor version
+	.word 2				# major version
+	.long xrlinux_header		# virtual address
+	.long _end - xrlinux_header	# size in memory
+	.long _start			# entrypoint
+	.long 1				# flags: map dtb
+	.long _end			# dtb address
+	.long FIXADDR_START - 1		# max dtb end
+SYM_DATA_END(xrlinux_header)
+
+SYM_CODE_START(_start)
+	# set up everything in advance so that in the region where nmi masking
+	# is necessary (from first rs write to functioning irq entry/exit) we
+	# only execute mtcr (and one jump)
+
+	# value to write to *itbctrl to clear the tb
+	addi t0, zero, 3
+
+	# virtual address of exception block
+	lui t1, zero, .Lexception_block
+	ori t1, t1, .Lexception_block
+
+	# itbtag value for exception block
+	add t2, zero, t1 RSH 12
+
+	# itbpte value for exception block
+	add t3, zero, a0 RSH 7
+	ori t3, t3, 0x17 # global, kernel, writable, valid
+
+	# dtbtag value for page table
+	lui t4, zero, (_PGD_ADDR >> 12)
+	ori t4, t4, (_PGD_ADDR >> 12)
+
+	# dtbpte value for page table
+	add t5, zero, s0 RSH 7
+	ori t5, t5, 0x17 # global, kernel, writable, valid
+
+	# create entry for recursive paging
+	# all cpus will do this, but they'll all be writing the same value to
+	# the same address, so it doesn't matter
+	mov long [s0 + ((_PGTABLE_ADDR >> 22) * 4)], t5
+
+	# value to write to *tbaddr
+	lui s0, zero, _PGTABLE_ADDR
+	ori s0, s0, _PGTABLE_ADDR
+
+	# value to write to scratch2
+	lui tp, zero, init_task
+	ori tp, tp, init_task
+
+	# initial value for *tbindex and value to write to rs to enable paging
+	addi s1, zero, 4
+
+	# itbtag value for temporary identity map of exception block
+	add s2, zero, a0 RSH 12
+
+	# canonicalize rs to T=0, M=0, I=0, U=0
+	mtcr rs, zero
+
+	# fully clear the tbs
+	mtcr itbctrl, t0
+	mtcr dtbctrl, t0
+
+	# set up exception block (incl. wired itb entry)
+	mtcr eb, t1
+	mtcr itbindex, zero
+	mtcr itbtag, t2
+	mtcr itbpte, t3
+
+	# set up wired dtb entry for page table
+	mtcr dtbindex, zero
+	mtcr dtbtag, t4
+	mtcr dtbpte, t5
+
+	# prepare for enabling paging
+	mtcr itbaddr, s0
+	mtcr dtbaddr, s0
+	mtcr itbindex, s1
+	mtcr dtbindex, s1
+
+	# create non-wired tb entry for identity map of exception block
+	mtcr itbtag, s2
+	mtcr itbpte, t3
+
+	# enable paging
+	mtcr rs, s1
+
+	# set up scratch registers for irq entry/exit
+	mtcr scratch1, zero
+	mtcr scratch2, tp
+
+	# jump to virtual addressing (and out of exception block)
+	jalr zero, t1, _start_kernel - .Lexception_block
+SYM_CODE_END(_start)
+
+.macro trap_entry cfunc
+	mtcr scratch0, sp
+	mfcr sp, scratch1
+	bne sp, 1f
+	mfcr sp, scratch0
+1:	mtcr scratch1, zero # make sure nested irqs don't reset the stack
+	# save registers on the newly obtained stack
+	subi sp, sp, PT_SIZE_ON_STACK
+	mov long [sp + PT_T0], t0
+	mfcr t0, scratch0
+	mov long [sp + PT_T1], t1
+	mfcr t1, epc
+	mov long [sp + PT_T2], t2
+	mfcr t2, rs
+	mov long [sp + PT_T3], t3
+	mov long [sp + PT_T4], t4
+	mov long [sp + PT_T5], t5
+	mov long [sp + PT_A0], a0
+	mov long [sp + PT_A1], a1
+	mov long [sp + PT_A2], a2
+	mov long [sp + PT_A3], a3
+	mov long [sp + PT_S0], s0
+	mov long [sp + PT_S1], s1
+	mov long [sp + PT_S2], s2
+	mov long [sp + PT_S3], s3
+	mov long [sp + PT_S4], s4
+	mov long [sp + PT_S5], s5
+	mov long [sp + PT_S6], s6
+	mov long [sp + PT_S7], s7
+	mov long [sp + PT_S8], s8
+	mov long [sp + PT_S9], s9
+	mov long [sp + PT_S10], s10
+	mov long [sp + PT_S11], s11
+	mov long [sp + PT_S12], s12
+
+	mov long [sp + PT_S13], s13
+	mov long [sp + PT_S14], s14
+	mov long [sp + PT_S15], s15
+	mov long [sp + PT_S16], s16
+	mov long [sp + PT_S17], s17
+	mov long [sp + PT_TP], tp
+	mov long [sp + PT_SP], t0
+	mov long [sp + PT_LR], lr
+	mov long [sp + PT_PC], t1
+	mov long [sp + PT_RS], t2
+
+	# set up c environment
+	addi s0, zero, 0
+	mfcr tp, scratch2
+
+	# call c function
+	add a0, sp, zero
+	jal \cfunc
+	j return_from_trap
+.endm
+
+.org 0x100
+SYM_CODE_START_LOCAL(interrupt_entry)
+	trap_entry xr17032_handle_interrupt
+SYM_CODE_END(interrupt_entry)
+
+.org 0x200
+SYM_CODE_START_LOCAL(syscall_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(syscall_entry)
+
+.org 0x400
+SYM_CODE_START_LOCAL(bus_error_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(bus_error_entry)
+
+.org 0x500
+SYM_CODE_START_LOCAL(nmi_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(nmi_entry)
+
+.org 0x600
+SYM_CODE_START_LOCAL(breakpoint_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(breakpoint_entry)
+
+.org 0x700
+SYM_CODE_START_LOCAL(invalid_instruction_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(invalid_instruction_entry)
+
+.org 0x800
+SYM_CODE_START_LOCAL(privileged_instruction_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(privileged_instruction_entry)
+
+.org 0x900
+SYM_CODE_START_LOCAL(unaligned_access_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(unaligned_access_entry)
+
+.org 0xc00
+SYM_CODE_START_LOCAL(read_page_fault_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(read_page_fault_entry)
+
+.org 0xd00
+SYM_CODE_START_LOCAL(write_page_fault_entry)
+1:	hlt
+	beq zero, 1b
+SYM_CODE_END(write_page_fault_entry)
+
+.org 0xe00
+SYM_CODE_START_LOCAL(handle_itb_miss)
+	mfcr zero, itbaddr
+	mov zero, long [zero]
+	mtcr itbpte, zero
+	rfe
+SYM_CODE_END(handle_itb_miss)
+
+.org 0xf00
+SYM_CODE_START_LOCAL(handle_dtb_miss)
+	mfcr zero, dtbaddr
+	mov zero, long [zero]
+	mtcr dtbpte, zero
+	rfe
+SYM_CODE_END(handle_dtb_miss)
+
+# skip over exception block
+.org 0x1000
+
+SYM_CODE_START_LOCAL(_start_kernel)
+	# remove temporary identity map itb entry
+	addi t0, zero, 1
+	mtcr itbctrl, t0
+
+	# get a logical cpu id
+	lui t0, zero, num_started_cpus
+	ori t0, t0, num_started_cpus
+1:	ll a0, t0
+	addi t1, a0, 1
+	sc t1, t0, t1
+	beq t1, 1b
+
+	# make sure we don't have more cpus than we know how to deal with
+#ifdef CONFIG_SMP
+	slti t1, a0, CONFIG_NR_CPUS
+	bne t1, .Lpark_cpu
+#else
+	bne a0, .Lpark_cpu
+#endif
+
+	# only continue on cpu0
+	bne a0, .Lpark_cpu
+
+	# set up boot_cpu_hwid
+	lui t0, zero, boot_cpu_hwid
+	ori t0, t0, boot_cpu_hwid
+	mfcr t1, whami
+	mov long [t0], t1
+
+	# set up c environment
+	lui sp, zero, init_thread_union + THREAD_SIZE - PT_SIZE_ON_STACK
+	ori sp, sp, init_thread_union + THREAD_SIZE - PT_SIZE_ON_STACK
+
+	addi s0, zero, 0
+
+	# wait until all cpus have entered the kernel
+	lui t0, zero, num_started_cpus
+	ori t0, t0, num_started_cpus
+1:	mov t1, long [t0]
+	slt t1, t1, a2
+	bne t1, 1b
+	mb
+
+	# call c entry point
+	add a0, a1, zero
+	jal setup_vm
+	jal start_kernel
+	brk
+
+.Lpark_cpu:
+	hlt
+	beq zero, .Lpark_cpu
+SYM_CODE_END(_start_kernel)
+
+SYM_CODE_START(ret_from_fork_kernel_asm)
+	jal schedule_tail
+	add a0, s2, zero
+	add a1, s1, zero
+	add s2, sp, zero
+	jal ret_from_fork_kernel
+	j return_from_trap
+SYM_CODE_END(ret_from_fork_kernel_asm)
+
+SYM_CODE_START(ret_from_fork_user_asm)
+	jal schedule_tail
+	add a0, sp, zero
+	jal ret_from_fork_user
+	j return_from_trap
+SYM_CODE_END(ret_from_fork_user_asm)
+
+SYM_CODE_START_LOCAL(return_from_trap)
+	# restore most registers
+	mov t1, long [sp + PT_T1]
+	mov t2, long [sp + PT_T2]
+	mov t3, long [sp + PT_T3]
+	mov t4, long [sp + PT_T4]
+	mov t5, long [sp + PT_T5]
+	mov a0, long [sp + PT_A0]
+	mov a1, long [sp + PT_A1]
+	mov a2, long [sp + PT_A2]
+	mov a3, long [sp + PT_A3]
+	mov s0, long [sp + PT_S0]
+	mov s1, long [sp + PT_S1]
+	mov s2, long [sp + PT_S2]
+	mov s3, long [sp + PT_S3]
+	mov s4, long [sp + PT_S4]
+	mov s5, long [sp + PT_S5]
+	mov s6, long [sp + PT_S6]
+	mov s7, long [sp + PT_S7]
+	mov s8, long [sp + PT_S8]
+	mov s9, long [sp + PT_S9]
+	mov s10, long [sp + PT_S10]
+	mov s11, long [sp + PT_S11]
+	mov s12, long [sp + PT_S12]
+	mov s13, long [sp + PT_S13]
+	mov s14, long [sp + PT_S14]
+	mov s15, long [sp + PT_S15]
+	mov s16, long [sp + PT_S16]
+	mov s17, long [sp + PT_S17]
+	mov lr, long [sp + PT_LR]
+
+	# restore rs first since this will also disable irqs
+	mov t0, long [sp + PT_RS]
+	mtcr rs, t0
+	# set up scratch1 if going to user mode
+	andi t0, t0, RS_OLD_U
+	beq t0, 1f
+	mov t0, long [tp + TASK_TI_KERNEL_SP]
+	mtcr scratch1, t0
+1:	# finish register restoration
+	mov tp, long [sp + PT_TP]
+	mov t0, long [sp + PT_PC]
+	mtcr epc, t0
+	mov t0, long [sp + PT_T0]
+	mov sp, long [sp + PT_SP]
+	rfe
+SYM_CODE_END(return_from_trap)
+
+# note: this function must preserve a0 and a1
+SYM_CODE_START(__switch_to)
+	# save registers to old task
+	mov long [a0 + TASK_THREAD_S0], s0
+	mov long [a0 + TASK_THREAD_S1], s1
+	mov long [a0 + TASK_THREAD_S2], s2
+	mov long [a0 + TASK_THREAD_S3], s3
+	mov long [a0 + TASK_THREAD_S4], s4
+	mov long [a0 + TASK_THREAD_S5], s5
+	mov long [a0 + TASK_THREAD_S6], s6
+	mov long [a0 + TASK_THREAD_S7], s7
+	mov long [a0 + TASK_THREAD_S8], s8
+	mov long [a0 + TASK_THREAD_S9], s9
+	mov long [a0 + TASK_THREAD_S10], s10
+	mov long [a0 + TASK_THREAD_S11], s11
+	mov long [a0 + TASK_THREAD_S12], s12
+	mov long [a0 + TASK_THREAD_S13], s13
+	mov long [a0 + TASK_THREAD_S14], s14
+	mov long [a0 + TASK_THREAD_S15], s15
+	mov long [a0 + TASK_THREAD_S16], s16
+	mov long [a0 + TASK_THREAD_S17], s17
+	mov long [a0 + TASK_THREAD_SP], sp
+	mov long [a0 + TASK_THREAD_LR], lr
+
+	# set new thread pointer
+	add tp, a1, zero
+	mtcr scratch2, tp
+
+	# restore registers from new task
+	mov s0, long [a1 + TASK_THREAD_S0]
+	mov s1, long [a1 + TASK_THREAD_S1]
+	mov s2, long [a1 + TASK_THREAD_S2]
+	mov s3, long [a1 + TASK_THREAD_S3]
+	mov s4, long [a1 + TASK_THREAD_S4]
+	mov s5, long [a1 + TASK_THREAD_S5]
+	mov s6, long [a1 + TASK_THREAD_S6]
+	mov s7, long [a1 + TASK_THREAD_S7]
+	mov s8, long [a1 + TASK_THREAD_S8]
+	mov s9, long [a1 + TASK_THREAD_S9]
+	mov s10, long [a1 + TASK_THREAD_S10]
+	mov s11, long [a1 + TASK_THREAD_S11]
+	mov s12, long [a1 + TASK_THREAD_S12]
+	mov s13, long [a1 + TASK_THREAD_S13]
+	mov s14, long [a1 + TASK_THREAD_S14]
+	mov s15, long [a1 + TASK_THREAD_S15]
+	mov s16, long [a1 + TASK_THREAD_S16]
+	mov s17, long [a1 + TASK_THREAD_S17]
+	mov sp, long [a1 + TASK_THREAD_SP]
+	mov lr, long [a1 + TASK_THREAD_LR]
+
+	jalr zero, lr, 0
+SYM_CODE_END(__switch_to)
+
+.bss
+
+.balign 4
+SYM_DATA_START_LOCAL(num_started_cpus)
+	.space 4
+SYM_DATA_END(num_started_cpus)
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/irq.c linux-workdir/arch/xr17032/kernel/irq.c
--- linux-clean/arch/xr17032/kernel/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/irq.c
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/panic.h>
+
+void __init init_IRQ(void)
+{
+	irqchip_init();
+	if (!handle_arch_irq)
+		panic("no interrupt controllers found");
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/process.c linux-workdir/arch/xr17032/kernel/process.c
--- linux-clean/arch/xr17032/kernel/process.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/process.c
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/entry-common.h>
+#include <linux/linkage.h>
+#include <linux/ptrace.h>
+#include <linux/sched.h>
+
+asmlinkage void ret_from_fork_kernel_asm(void);
+asmlinkage void ret_from_fork_kernel(void *fn_arg, int (*fn)(void *),
+				     struct pt_regs *regs);
+
+asmlinkage void ret_from_fork_user_asm(void);
+asmlinkage void ret_from_fork_user(struct pt_regs *regs);
+
+asmlinkage void ret_from_fork_kernel(void *fn_arg, int (*fn)(void *),
+				     struct pt_regs *regs)
+{
+	fn(fn_arg);
+	syscall_exit_to_user_mode(regs);
+}
+
+asmlinkage void ret_from_fork_user(struct pt_regs *regs)
+{
+	syscall_exit_to_user_mode(regs);
+}
+
+int copy_thread(struct task_struct *p, const struct kernel_clone_args *args)
+{
+	unsigned long clone_flags = args->flags;
+	unsigned long usp = args->stack;
+	unsigned long tls = args->tls;
+	struct pt_regs *childregs = task_pt_regs(p);
+
+	memset(&p->thread, 0, sizeof(p->thread));
+
+	if (unlikely(args->fn)) {
+		memset(childregs, 0, sizeof(*childregs));
+		childregs->rs = RS_OLD_M | RS_OLD_I | RS_M;
+
+		p->thread.s[1] = (unsigned long)args->fn;
+		p->thread.s[2] = (unsigned long)args->fn_arg;
+		p->thread.lr = (unsigned long)ret_from_fork_kernel_asm;
+	} else {
+		*childregs = *current_pt_regs();
+		if (usp)
+			childregs->sp = usp;
+		if (clone_flags & CLONE_SETTLS)
+			childregs->tp = tls;
+		childregs->a3 = 0; /* return value of fork() */
+		p->thread.lr = (unsigned long)ret_from_fork_user_asm;
+	}
+
+	p->thread.sp = (unsigned long)childregs;
+	return 0;
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/setup.c linux-workdir/arch/xr17032/kernel/setup.c
--- linux-clean/arch/xr17032/kernel/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/setup.c
@@ -0,0 +1,132 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/early_ioremap.h>
+#include <asm/pgtable.h>
+#include <asm/sections.h>
+#include <asm/smp.h>
+#include <linux/memblock.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/jump_label.h>
+#include <linux/of_fdt.h>
+#include <linux/panic.h>
+#include <linux/printk.h>
+
+unsigned long boot_cpu_hwid;
+
+static void __init parse_dtb(void)
+{
+	if (early_init_dt_scan(_dtb_early_va, _dtb_early_pa)) {
+		const char *name = of_flat_dt_get_machine_name();
+
+		if (name) {
+			pr_info("Machine model: %s\n", name);
+			dump_stack_set_arch_desc("%s", name);
+		}
+	} else {
+		pr_err("Invalid DTB");
+	}
+}
+
+static int num_standard_resources;
+static struct resource *standard_resources;
+
+static int __init add_resource(struct resource *parent, struct resource *res)
+{
+	int ret = insert_resource(parent, res);
+	if (ret < 0) {
+		pr_err("Failed to add a %s resource at %llx\n", res->name,
+		       (unsigned long long) res->start);
+		return ret;
+	}
+
+	return 1;
+}
+
+static void __init init_resources(void)
+{
+	struct memblock_region *region = NULL;
+	struct resource *res = NULL;
+	struct resource *mem_res = NULL;
+
+	/* +1 as memblock_alloc() might increase memblock.reserved.cnt */
+	int num_resources = memblock.memory.cnt + memblock.reserved.cnt + 1;
+	int res_idx = num_resources - 1;
+	int non_resv_res = 0;
+
+	size_t mem_res_sz = num_resources * sizeof(*mem_res);
+	mem_res = memblock_alloc_or_panic(mem_res_sz, SMP_CACHE_BYTES);
+
+	int ret;
+
+	for_each_reserved_mem_region(region) {
+		res = &mem_res[res_idx--];
+
+		res->name = "Reserved";
+		res->flags = IORESOURCE_MEM | IORESOURCE_EXCLUSIVE;
+		res->start = __pfn_to_phys(memblock_region_reserved_base_pfn(region));
+		res->end = __pfn_to_phys(memblock_region_reserved_end_pfn(region)) - 1;
+
+		if (memblock_is_memory(res->start)) {
+			res_idx++;
+			continue;
+		}
+
+		ret = add_resource(&iomem_resource, res);
+		if (ret < 0)
+			goto error;
+	}
+
+	for_each_mem_region(region) {
+		res = &mem_res[res_idx--];
+		non_resv_res++;
+
+		if (unlikely(memblock_is_nomap(region))) {
+			res->name = "Reserved";
+			res->flags = IORESOURCE_MEM | IORESOURCE_EXCLUSIVE;
+		} else {
+			res->name = "System RAM";
+			res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+		}
+
+		res->start = __pfn_to_phys(memblock_region_reserved_base_pfn(region));
+		res->end = __pfn_to_phys(memblock_region_reserved_end_pfn(region)) - 1;
+
+		ret = add_resource(&iomem_resource, res);
+		if (ret < 0)
+			goto error;
+	}
+
+	num_standard_resources = non_resv_res;
+	standard_resources = &mem_res[res_idx + 1];
+
+	if (res_idx >= 0)
+		memblock_free(mem_res, (res_idx + 1) * sizeof(*mem_res));
+	return;
+
+error:
+	release_child_resources(&iomem_resource);
+	memblock_free(mem_res, mem_res_sz);
+}
+
+void __init setup_arch(char **cmdline_p)
+{
+	parse_dtb();
+	setup_initial_init_mm(_stext, _etext, _edata, _end);
+
+	*cmdline_p = boot_command_line;
+
+	early_ioremap_setup();
+	jump_label_init();
+	parse_early_param();
+
+	paging_init();
+
+	unflatten_device_tree();
+	misc_mem_init();
+
+	init_resources();
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/stubs.c linux-workdir/arch/xr17032/kernel/stubs.c
--- linux-clean/arch/xr17032/kernel/stubs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/stubs.c
@@ -0,0 +1,105 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/mmu_context.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/tlbflush.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/panic.h>
+#include <linux/ptrace.h>
+#include <linux/reboot.h>
+#include <linux/sched.h>
+#include <linux/sched/debug.h>
+#include <linux/seq_file.h>
+
+const struct seq_operations cpuinfo_op;
+
+long arch_ptrace(struct task_struct *child, long request,
+		 unsigned long addr, unsigned long data)
+{
+	panic("TODO arch_ptrace");
+}
+
+void flush_thread(void)
+{
+	panic("TODO flush_thread");
+}
+
+void flush_tlb_kernel_range(unsigned long start, unsigned long end)
+{
+	panic("TODO flush_tlb_kernel_range");
+}
+
+void flush_tlb_mm(struct mm_struct *mm)
+{
+	panic("TODO flush_tlb_mm");
+}
+
+void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
+			unsigned long end, unsigned int page_size)
+{
+	panic("TODO flush_tlb_mm_range");
+}
+
+void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)
+{
+	panic("TODO flush_tlb_page");
+}
+
+void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+		     unsigned long end)
+{
+	panic("TODO flush_tlb_range");
+}
+
+unsigned long __get_wchan(struct task_struct *task)
+{
+	panic("TODO __get_wchan");
+}
+
+void machine_halt(void)
+{
+	panic("TODO machine_halt");
+}
+
+void machine_power_off(void)
+{
+	panic("TODO machine_power_off");
+}
+
+void machine_restart(char *cmd)
+{
+	panic("TODO machine_restart");
+}
+
+void ptrace_disable(struct task_struct *child)
+{
+	panic("TODO ptrace_disable");
+}
+
+void show_regs(struct pt_regs *regs)
+{
+	panic("TODO show_regs");
+}
+
+void show_stack(struct task_struct *task, unsigned long *sp, const char *loglvl)
+{
+	pr_cont("TODO show_stack\n");
+}
+
+void start_thread(struct pt_regs *regs, unsigned long pc, unsigned long sp)
+{
+	panic("TODO start_thread");
+}
+
+void switch_mm(struct mm_struct *prev, struct mm_struct *next,
+	       struct task_struct *task)
+{
+	panic("TODO switch_mm");
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/time.c linux-workdir/arch/xr17032/kernel/time.c
--- linux-clean/arch/xr17032/kernel/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/time.c
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/clocksource.h>
+#include <linux/init.h>
+#include <linux/of_clk.h>
+
+void __init time_init(void)
+{
+	of_clk_init(NULL);
+	timer_probe();
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/vmlinux.lds.S linux-workdir/arch/xr17032/kernel/vmlinux.lds.S
--- linux-clean/arch/xr17032/kernel/vmlinux.lds.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/vmlinux.lds.S
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/pgtable.h>
+#define LOAD_OFFSET KERNEL_LINK_ADDR
+
+#include <asm/vmlinux.lds.h>
+#include <asm/page.h>
+#include <asm/cache.h>
+#include <asm/thread_info.h>
+#include <asm/set_memory.h>
+
+#include <linux/sizes.h>
+
+OUTPUT_ARCH(xr17032)
+ENTRY(_start)
+
+jiffies = jiffies_64;
+
+SECTIONS
+{
+	. = LOAD_OFFSET;
+	HEAD_TEXT_SECTION
+	. = ALIGN(PAGE_SIZE);
+
+	.text : {
+		_text = .;
+		_stext = .;
+		TEXT_TEXT
+		SCHED_TEXT
+		LOCK_TEXT
+		KPROBES_TEXT
+		ENTRY_TEXT
+		IRQENTRY_TEXT
+		SOFTIRQENTRY_TEXT
+		_etext = .;
+	}
+
+	. = ALIGN(SECTION_ALIGN);
+	__init_begin = .;
+	__init_text_begin = .;
+	.init.text : AT(ADDR(.init.text) - LOAD_OFFSET) ALIGN(SECTION_ALIGN) { \
+		_sinittext = .;						\
+		INIT_TEXT						\
+		_einittext = .;						\
+	}
+
+	/* we have to discard exit text and such at runtime, not link time */
+	__exittext_begin = .;
+	.exit.text :
+	{
+		EXIT_TEXT
+	}
+	__exittext_end = .;
+
+	__init_text_end = .;
+	. = ALIGN(SECTION_ALIGN);
+	/* Start of init data section */
+	__init_data_begin = .;
+	INIT_DATA_SECTION(16)
+
+	.init.pi : {
+		KEEP(*(.init.pi*))
+	}
+
+	.init.bss : {
+		KEEP(*(.init.bss*))
+	}
+	.exit.data :
+	{
+		EXIT_DATA
+	}
+
+	RUNTIME_CONST_VARIABLES
+
+	PERCPU_SECTION(L1_CACHE_BYTES)
+
+	.rel.dyn : {
+		*(.rel.dyn*)
+	}
+
+	.rela.dyn : ALIGN(8) {
+		__rela_dyn_start = .;
+		*(.rela .rela*)
+		__rela_dyn_end = .;
+	}
+
+	__init_data_end = .;
+
+	. = ALIGN(8);
+	.alternative : {
+		__alt_start = .;
+		KEEP(*(.alternative))
+		__alt_end = .;
+	}
+	__init_end = .;
+
+	/* Start of data section */
+	_sdata = .;
+	RO_DATA(SECTION_ALIGN)
+	.srodata : {
+		*(.srodata*)
+	}
+
+	. = ALIGN(SECTION_ALIGN);
+	_data = .;
+
+	RW_DATA(L1_CACHE_BYTES, PAGE_SIZE, THREAD_ALIGN)
+
+	.got : { *(.got*) }
+
+#ifdef CONFIG_RELOCATABLE
+	.data.rel : { *(.data.rel*) }
+	.plt : { *(.plt) }
+	.dynamic : { *(.dynamic) }
+	.dynsym : { *(.dynsym) }
+	.dynstr : { *(.dynstr) }
+	.hash : { *(.hash) }
+	.gnu.hash : { *(.gnu.hash) }
+#endif
+
+	/* End of data section */
+	_edata = .;
+
+	BSS_SECTION(PAGE_SIZE, PAGE_SIZE, 0)
+
+	_end = .;
+
+	STABS_DEBUG
+	DWARF_DEBUG
+	ELF_DETAILS
+
+	DISCARDS
+}
diff -urN --no-dereference linux-clean/arch/xr17032/lib/Makefile linux-workdir/arch/xr17032/lib/Makefile
--- linux-clean/arch/xr17032/lib/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0-only
+lib-y += delay.o
+lib-y += memset.o
diff -urN --no-dereference linux-clean/arch/xr17032/lib/delay.c linux-workdir/arch/xr17032/lib/delay.c
--- linux-clean/arch/xr17032/lib/delay.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/delay.c
@@ -0,0 +1,28 @@
+#include <linux/compiler.h>
+#include <linux/delay.h>
+
+noinline void __delay(unsigned long loops)
+{
+	asm volatile(
+		"	beq %0, 2f\n"
+		"	beq zero, 1f\n"
+		".balign 16\n"
+		"1:	subi %0, %0, 1\n"
+		"	bne %0, 1b\n"
+		"2:"
+		: "+r" (loops)
+	);
+}
+
+void __const_udelay(unsigned long xloops)
+{
+	xloops *= 4;
+	xloops = ((uint64_t)xloops * (loops_per_jiffy * (HZ / 4))) >> 32;
+
+	__delay(++xloops);
+}
+
+void __udelay(unsigned long loops)
+{
+	__const_udelay(loops * UDELAY_CONST_MULT);
+}
diff -urN --no-dereference linux-clean/arch/xr17032/lib/memset.S linux-workdir/arch/xr17032/lib/memset.S
--- linux-clean/arch/xr17032/lib/memset.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/memset.S
@@ -0,0 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/linkage.h>
diff -urN --no-dereference linux-clean/arch/xr17032/mm/Makefile linux-workdir/arch/xr17032/mm/Makefile
--- linux-clean/arch/xr17032/mm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+obj-y += init.o
diff -urN --no-dereference linux-clean/arch/xr17032/mm/init.c linux-workdir/arch/xr17032/mm/init.c
--- linux-clean/arch/xr17032/mm/init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/mm/init.c
@@ -0,0 +1,233 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/fixmap.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <linux/align.h>
+#include <linux/dma-map-ops.h>
+#include <linux/initrd.h>
+#include <linux/linkage.h>
+#include <linux/memblock.h>
+#include <linux/minmax.h>
+#include <linux/mm.h>
+#include <linux/mmzone.h>
+#include <linux/of_fdt.h>
+
+void *_dtb_early_va;
+uintptr_t _dtb_early_pa;
+
+unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)]
+__page_aligned_bss;
+
+static pte_t fixmap_pte[PTRS_PER_PTE] __page_aligned_bss;
+
+static const pgprot_t protection_map[] = {
+	[VM_NONE]					= PAGE_NONE,
+	[VM_READ]					= PAGE_READ,
+	[VM_WRITE]					= PAGE_COPY,
+	[VM_WRITE | VM_READ]				= PAGE_COPY,
+	[VM_EXEC]					= PAGE_EXEC,
+	[VM_EXEC | VM_READ]				= PAGE_READ_EXEC,
+	[VM_EXEC | VM_WRITE]				= PAGE_COPY_EXEC,
+	[VM_EXEC | VM_WRITE | VM_READ]			= PAGE_COPY_EXEC,
+	[VM_SHARED]					= PAGE_NONE,
+	[VM_SHARED | VM_READ]				= PAGE_READ,
+	[VM_SHARED | VM_WRITE]				= PAGE_SHARED,
+	[VM_SHARED | VM_WRITE | VM_READ]		= PAGE_SHARED,
+	[VM_SHARED | VM_EXEC]				= PAGE_EXEC,
+	[VM_SHARED | VM_EXEC | VM_READ]			= PAGE_READ_EXEC,
+	[VM_SHARED | VM_EXEC | VM_WRITE]		= PAGE_SHARED_EXEC,
+	[VM_SHARED | VM_EXEC | VM_WRITE | VM_READ]	= PAGE_SHARED_EXEC
+};
+
+DECLARE_VM_GET_PAGE_PROT
+
+phys_addr_t dma32_phys_limit;
+
+void __set_fixmap(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot)
+{
+	unsigned long addr = __fix_to_virt(idx);
+	pte_t *ptep;
+
+	BUG_ON(idx <= FIX_HOLE || idx >= __end_of_fixed_addresses);
+
+	ptep = &fixmap_pte[pte_index(addr)];
+
+	if (pgprot_val(prot))
+		set_pte(ptep, pfn_pte(phys >> PAGE_SHIFT, prot));
+	else
+		pte_clear(&init_mm, addr, ptep);
+	local_flush_tlb_page(addr);
+}
+
+static void __meminit create_pgd_mapping(pgd_t *pgdp, uintptr_t va, phys_addr_t pa)
+{
+	uintptr_t pgd_idx = pgd_index(va);
+
+	BUG_ON(pgd_val(pgdp[pgd_idx]));
+
+	pgdp[pgd_idx] = pfn_pgd(PFN_DOWN(pa), PAGE_TABLE);
+}
+
+static void __init reserve_mapped_memory(void)
+{
+	pte_t *cur_pte = (pte_t *)_PGTABLE_ADDR;
+	pgd_t *cur_pgd = swapper_pg_dir;
+
+	for (unsigned i = 0; i < PTRS_PER_PGD; i++) {
+		pgd_t pgd_entry = *cur_pgd++;
+
+		if (pgd_val(pgd_entry)) {
+			for (unsigned j = 0; j < PTRS_PER_PTE; j++) {
+				pte_t pte_entry = *cur_pte++;
+
+				if (pte_val(pte_entry)) {
+					unsigned long pfn = pte_pfn(pte_entry);
+					memblock_reserve(pfn << PAGE_SHIFT,
+							 PAGE_SIZE);
+				}
+			}
+		} else {
+			cur_pte += PTRS_PER_PTE;
+		}
+	}
+}
+
+asmlinkage void __init setup_vm(uintptr_t dtb_pa);
+
+asmlinkage void __init setup_vm(uintptr_t dtb_pa)
+{
+	extern char _end[];
+
+	_dtb_early_va = (void *)ALIGN((uintptr_t)_end, PAGE_SIZE);
+	_dtb_early_pa = dtb_pa;
+
+	pgd_t *early_pg_dir = (pgd_t *)_PGD_ADDR;
+
+	*(pte_t *)(_PGTABLE_ADDR | (_SWAPPER_PGD_ADDR >> 10))
+		= pfn_pte(__pa(early_pg_dir) >> PAGE_SHIFT, PAGE_KERNEL);
+	create_pgd_mapping(early_pg_dir, FIXADDR_START, __pa(fixmap_pte));
+
+	local_flush_tlb_all();
+
+	reserve_mapped_memory();
+}
+
+static void __init setup_bootmem(void)
+{
+	phys_addr_t max_mapped_addr = __pa(-PAGE_SIZE);
+	memblock_reserve(max_mapped_addr, (phys_addr_t)-max_mapped_addr);
+
+	phys_addr_t phys_ram_base = memblock_start_of_DRAM();
+	phys_addr_t phys_ram_end = memblock_end_of_DRAM();
+
+	min_low_pfn = PFN_UP(phys_ram_base);
+	max_low_pfn = max_pfn = PFN_DOWN(phys_ram_end);
+
+	reserve_initrd_mem();
+	early_init_fdt_scan_reserved_mem();
+
+	dma32_phys_limit = max(4UL * SZ_1G,
+			       (unsigned long)PFN_PHYS(max_low_pfn));
+
+	dma_contiguous_reserve(dma32_phys_limit);
+}
+
+static void __meminit create_linear_mapping_range(phys_addr_t start,
+						  phys_addr_t end)
+{
+	pgd_t *pgdp = swapper_pg_dir;
+
+	uintptr_t vhead = (uintptr_t)__va(start);
+	uintptr_t vtail = (uintptr_t)__va(end - 1);
+
+	uintptr_t pgd_head = pgd_index(vhead);
+	uintptr_t pte_head = pte_index(vhead);
+
+	uintptr_t pgd_tail = pgd_index(vtail);
+	uintptr_t pte_tail = pte_index(vtail);
+
+	for (uintptr_t pgd_idx = pgd_head; pgd_idx <= pgd_tail; pgd_idx++) {
+		uintptr_t cur_pte_tail;
+
+		if (pgd_idx != pgd_tail)
+			cur_pte_tail = PTRS_PER_PTE - 1;
+		else
+			cur_pte_tail = pte_tail;
+
+		phys_addr_t pte_phys;
+		pte_t *ptep;
+
+		if (pgd_val(pgdp[pgd_idx]) == 0) {
+			pte_phys = memblock_phys_alloc(PAGE_SIZE, PAGE_SIZE);
+			pgdp[pgd_idx] = pfn_pgd(PFN_DOWN(pte_phys), PAGE_TABLE);
+			ptep = (pte_t *)set_fixmap_offset(FIX_TEMP, pte_phys);
+			memset(ptep, 0, PAGE_SIZE);
+		} else {
+			ptep = (pte_t *)set_fixmap_offset(FIX_TEMP, pte_phys);
+		}
+
+		for (uintptr_t pte_idx = pte_head; pte_idx <= cur_pte_tail;
+		     pte_idx++) {
+			unsigned long pfn = PFN_DOWN(start);
+			ptep[pte_idx] = pfn_pte(pfn, PAGE_KERNEL_EXEC);
+			start += PAGE_SIZE;
+		}
+
+		clear_fixmap(FIX_TEMP);
+
+		pte_head = 0;
+	}
+}
+
+static void __init create_linear_mapping_page_table(void)
+{
+	phys_addr_t start, end;
+	u64 i;
+
+	for_each_mem_range(i, &start, &end) {
+		if (start >= end)
+			break;
+		if (start <= __pa(PAGE_OFFSET) && __pa(PAGE_OFFSET) < end)
+			start = __pa(PAGE_OFFSET);
+
+		create_linear_mapping_range(start, end);
+	}
+}
+
+static void __init setup_vm_final(void)
+{
+	create_linear_mapping_page_table();
+
+	local_flush_tlb_all();
+}
+
+void __init paging_init(void)
+{
+	setup_bootmem();
+	setup_vm_final();
+	memblock_allow_resize();
+}
+
+static void __init zone_sizes_init(void)
+{
+	unsigned long max_zone_pfns[MAX_NR_ZONES] = { 0, };
+
+#ifdef CONFIG_ZONE_DMA32
+	max_zone_pfns[ZONE_DMA32] = PFN_DOWN(dma32_phys_limit);
+#endif
+	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
+
+	free_area_init(max_zone_pfns);
+}
+
+void __init misc_mem_init(void)
+{
+	early_memtest(min_low_pfn << PAGE_SHIFT, max_low_pfn << PAGE_SHIFT);
+	sparse_init();
+	zone_sizes_init();
+	memblock_dump_all();
+}
diff -urN --no-dereference linux-clean/drivers/clocksource/Kconfig linux-workdir/drivers/clocksource/Kconfig
--- linux-clean/drivers/clocksource/Kconfig
+++ linux-workdir/drivers/clocksource/Kconfig
@@ -779,4 +779,12 @@
           Enables the support for NXP System Timer Module found in the
           s32g NXP platform series.
 
+config XRARCH_RTC
+	bool "XR/arch RTC driver"
+	depends on OF
+	select TIMER_PROBE
+	select TIMER_OF
+	help
+	  Enables support for the RTC device found in XR/computer systems.
+
 endmenu
diff -urN --no-dereference linux-clean/drivers/clocksource/Makefile linux-workdir/drivers/clocksource/Makefile
--- linux-clean/drivers/clocksource/Makefile
+++ linux-workdir/drivers/clocksource/Makefile
@@ -94,3 +94,4 @@
 obj-$(CONFIG_EP93XX_TIMER)		+= timer-ep93xx.o
 obj-$(CONFIG_RALINK_TIMER)		+= timer-ralink.o
 obj-$(CONFIG_NXP_STM_TIMER)		+= timer-nxp-stm.o
+obj-$(CONFIG_XRARCH_RTC)		+= timer-xrarch-rtc.o
diff -urN --no-dereference linux-clean/drivers/clocksource/timer-xrarch-rtc.c linux-workdir/drivers/clocksource/timer-xrarch-rtc.c
--- linux-clean/drivers/clocksource/timer-xrarch-rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/clocksource/timer-xrarch-rtc.c
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#define pr_fmt(fmt) "xrarch-rtc: " fmt
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#define RTC_LATCH	((1000UL + (HZ / 2)) / HZ)
+
+#define RTC_CMD		0x00
+#define RTC_DATA	0x04
+
+#define RTC_SET_IRQ	0x01
+#define RTC_GET_TIME	0x02
+#define RTC_GET_TIME_MS	0x03
+#define RTC_SET_TIME	0x04
+#define RTC_SET_TIME_MS	0x05
+
+struct xrarch_rtc {
+	struct clock_event_device base;
+	void __iomem *regs;
+	raw_spinlock_t lock;
+};
+
+static irqreturn_t xrarch_rtc_irq(int irq, void *dev_id)
+{
+	struct xrarch_rtc *device = dev_id;
+	device->base.event_handler(&device->base);
+	return IRQ_HANDLED;
+}
+
+static int xrarch_rtc_shutdown(struct clock_event_device *evt)
+{
+	struct xrarch_rtc *device = (struct xrarch_rtc *)evt;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&device->lock, flags);
+	writel(0, device->regs + RTC_DATA);
+	writel(RTC_SET_IRQ, device->regs + RTC_CMD);
+	raw_spin_unlock_irqrestore(&device->lock, flags);
+
+	return 0;
+}
+
+static int xrarch_rtc_periodic(struct clock_event_device *evt)
+{
+	struct xrarch_rtc *device = (struct xrarch_rtc *)evt;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&device->lock, flags);
+	writel(RTC_LATCH, device->regs + RTC_DATA);
+	writel(RTC_SET_IRQ, device->regs + RTC_CMD);
+	raw_spin_unlock_irqrestore(&device->lock, flags);
+
+	return 0;
+}
+
+static int __init xrarch_rtc_init(struct device_node *np)
+{
+	BUG_ON(RTC_LATCH < 1);
+
+	void __iomem *regs = of_iomap(np, 0);
+	if (!regs)
+		return -ENOMEM;
+
+	int error;
+
+	struct xrarch_rtc *data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		error = -ENOMEM;
+		goto fail_free_regs;
+	}
+
+	data->base.name = "xrarch-rtc";
+	data->base.features = CLOCK_EVT_FEAT_PERIODIC;
+	data->base.set_state_shutdown = xrarch_rtc_shutdown;
+	data->base.set_state_periodic = xrarch_rtc_periodic;
+	data->base.cpumask = cpumask_of(smp_processor_id());
+	data->regs = regs;
+	raw_spin_lock_init(&data->lock);
+
+	xrarch_rtc_shutdown(&data->base);
+
+	int irq = of_irq_get(np, 0);
+	if (irq <= 0) {
+		error = irq ? irq : -ENODEV;
+		goto fail_free_data;
+	}
+
+	error = request_irq(irq, xrarch_rtc_irq, IRQF_NOBALANCING |
+			    IRQF_IRQPOLL | IRQF_TIMER, "xrarch-rtc", data);
+	if (error)
+		goto fail_free_data;
+
+	clockevents_config_and_register(&data->base, 1000, 0, 0);
+
+	return 0;
+
+fail_free_data:
+	kfree(data);
+fail_free_regs:
+	iounmap(regs);
+	return error;
+}
+
+TIMER_OF_DECLARE(xrarch_rtc, "xrarch,rtc", xrarch_rtc_init);
diff -urN --no-dereference linux-clean/drivers/irqchip/Kconfig linux-workdir/drivers/irqchip/Kconfig
--- linux-clean/drivers/irqchip/Kconfig
+++ linux-workdir/drivers/irqchip/Kconfig
@@ -794,4 +794,14 @@
 	  chained controller, routing all interrupt source in P-Chip to
 	  the primary controller on C-Chip.
 
+config XR17032_INTC
+	bool
+	depends on XR17032
+	select IRQ_DOMAIN_HIERARCHY
+
+config XRARCH_LSIC
+	bool
+	depends on XR17032
+	select IRQ_DOMAIN_HIERARCHY
+
 endmenu
diff -urN --no-dereference linux-clean/drivers/irqchip/Makefile linux-workdir/drivers/irqchip/Makefile
--- linux-clean/drivers/irqchip/Makefile
+++ linux-workdir/drivers/irqchip/Makefile
@@ -132,3 +132,5 @@
 obj-$(CONFIG_MCHP_EIC)			+= irq-mchp-eic.o
 obj-$(CONFIG_SOPHGO_SG2042_MSI)		+= irq-sg2042-msi.o
 obj-$(CONFIG_SUNPLUS_SP7021_INTC)	+= irq-sp7021-intc.o
+obj-$(CONFIG_XRARCH_LSIC)		+= irq-xrarch-lsic.o
+obj-$(CONFIG_XR17032_INTC)		+= irq-xr17032-intc.o
diff -urN --no-dereference linux-clean/drivers/irqchip/irq-xr17032-intc.c linux-workdir/drivers/irqchip/irq-xr17032-intc.c
--- linux-clean/drivers/irqchip/irq-xr17032-intc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/irqchip/irq-xr17032-intc.c
@@ -0,0 +1,118 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#define pr_fmt(fmt) "xr17032-intc: " fmt
+#include <asm/irq.h>
+#include <asm/smp.h>
+#include <linux/fwnode.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/smp.h>
+
+#define INTC_IRQS 16
+
+struct irq_domain *xr17032_intc_domain;
+
+static void xr17032_intc_irq(struct pt_regs *regs)
+{
+	unsigned long cause = regs->rs >> 28;
+
+	if (generic_handle_domain_irq(xr17032_intc_domain, cause))
+		pr_warn_ratelimited("failed to handle interrupt (cause: %lu)\n",
+				    cause);
+}
+
+static void xr17032_intc_eoi(struct irq_data *d)
+{
+	// Without this function, the chained_irq functions will try to mask
+	// the IRQ, which is both impossible and unnecessary.
+}
+
+static struct irq_chip xr17032_intc_chip = {
+	.name		= "XR/17032 INTC",
+	.irq_eoi	= xr17032_intc_eoi,
+};
+
+static int xr17032_intc_domain_map(struct irq_domain *d, unsigned int irq,
+				   irq_hw_number_t hwirq)
+{
+	struct irq_chip *chip = d->host_data;
+
+	irq_set_percpu_devid(irq);
+	irq_domain_set_info(d, irq, hwirq, chip, NULL, handle_percpu_devid_irq,
+			    NULL, NULL);
+
+	return 0;
+}
+
+static int xr17032_intc_domain_alloc(struct irq_domain *domain,
+				     unsigned int virq, unsigned int nr_irqs,
+				     void *arg)
+{
+	struct irq_fwspec *fwspec = arg;
+	irq_hw_number_t hwirq;
+	unsigned int type = IRQ_TYPE_NONE;
+
+	int ret = irq_domain_translate_onecell(domain, fwspec, &hwirq, &type);
+	if (ret)
+		return ret;
+
+	if (hwirq + nr_irqs >= INTC_IRQS)
+		return -EINVAL;
+
+	for (unsigned int i = 0; i < nr_irqs; i++) {
+		ret = xr17032_intc_domain_map(domain, virq + i, hwirq + i);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct irq_domain_ops xr17032_intc_domain_ops = {
+	.map	= xr17032_intc_domain_map,
+	.xlate	= irq_domain_xlate_onecell,
+	.alloc	= xr17032_intc_domain_alloc,
+};
+
+static int __init xr17032_intc_init(struct device_node *node,
+				    struct device_node *parent)
+{
+	struct irq_chip *chip = &xr17032_intc_chip;
+
+	unsigned long cpu_hwid = of_get_cpu_hwid(node, 0);
+	if (cpu_hwid == ~0UL) {
+		pr_warn("unable to find cpu hwid for %pOF\n", node);
+		return 0;
+	}
+
+	struct fwnode_handle *fn = of_fwnode_handle(node);
+
+	if (xr17032_cpu_hwid_to_cpuid(cpu_hwid) != smp_processor_id()) {
+		fwnode_dev_initialized(fn, true);
+		return 0;
+	}
+
+	xr17032_intc_domain = irq_domain_create_linear(fn, INTC_IRQS,
+						       &xr17032_intc_domain_ops,
+						       chip);
+	if (!xr17032_intc_domain) {
+		pr_err("failed to create irq domain\n");
+		return -ENOMEM;
+	}
+
+	int rc = set_handle_irq(&xr17032_intc_irq);
+	if (rc) {
+		pr_err("failed to set irq handler\n");
+		return rc;
+	}
+
+	return 0;
+}
+
+IRQCHIP_DECLARE(xr17032_intc, "xrarch,xr17032", xr17032_intc_init);
diff -urN --no-dereference linux-clean/drivers/irqchip/irq-xrarch-lsic.c linux-workdir/drivers/irqchip/irq-xrarch-lsic.c
--- linux-clean/drivers/irqchip/irq-xrarch-lsic.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/irqchip/irq-xrarch-lsic.c
@@ -0,0 +1,292 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#define pr_fmt(fmt) "xrarch-lsic: " fmt
+#include <asm/smp.h>
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#define LSIC_PARENT_IRQ 1
+#define LSIC_IRQS 64
+
+#define LSIC_STRIDE 0x20
+
+#define LSIC_DISA 0x00
+#define LSIC_PEND 0x08
+#define LSIC_COMPL 0x10
+#define LSIC_CLAIM 0x10
+#define LSIC_IPL 0x14
+
+struct lsic_priv {
+	struct fwnode_handle *fwnode;
+	struct irq_domain *domain;
+	struct cpumask lmask;
+};
+
+struct lsic_handler {
+	struct lsic_priv *priv;
+	void __iomem *regs;
+	raw_spinlock_t mask_lock;
+};
+
+static DEFINE_PER_CPU(struct lsic_handler, lsic_handlers);
+
+static void lsic_handle_irq(struct irq_desc *desc)
+{
+	struct lsic_handler *handler = this_cpu_ptr(&lsic_handlers);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+
+	chained_irq_enter(chip, desc);
+
+	irq_hw_number_t hwirq;
+	while ((hwirq = readl(handler->regs + LSIC_CLAIM)) != 0) {
+		int err = generic_handle_domain_irq(handler->priv->domain,
+						    hwirq);
+
+		if (unlikely(err)) {
+			pr_warn_ratelimited("%pfwP: can't find mapping for hwirq %lu",
+					    handler->priv->fwnode, hwirq);
+		}
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static void lsic_irq_set_masked(struct irq_data *d, bool masked)
+{
+	int cpu;
+	unsigned long flags;
+	unsigned int hwirq = d->hwirq;
+	unsigned int offset = hwirq / 32 * 4;
+	unsigned int mask = 1U << (hwirq % 32);
+
+	for_each_cpu(cpu, irq_data_get_effective_affinity_mask(d)) {
+		struct lsic_handler *handler = per_cpu_ptr(&lsic_handlers, cpu);
+		raw_spin_lock_irqsave(&handler->mask_lock, flags);
+
+		void __iomem *reg = handler->regs + LSIC_DISA + offset;
+		unsigned int value = readl(reg);
+
+		if (masked)
+			writel(value | mask, reg);
+		else
+			writel(value & ~mask, reg);
+
+		raw_spin_unlock_irqrestore(&handler->mask_lock, flags);
+	}
+}
+
+static void lsic_irq_mask(struct irq_data *d)
+{
+	lsic_irq_set_masked(d, true);
+}
+
+static void lsic_irq_unmask(struct irq_data *d)
+{
+	lsic_irq_set_masked(d, false);
+}
+
+static void lsic_irq_eoi(struct irq_data *d)
+{
+	struct lsic_handler *handler = this_cpu_ptr(&lsic_handlers);
+	writel(d->hwirq, handler->regs + LSIC_COMPL);
+}
+
+static int lsic_set_affinity(struct irq_data *d,
+			     const struct cpumask *mask_val, bool force)
+{
+	struct lsic_priv *priv = irq_data_get_irq_chip_data(d);
+	unsigned int cpu;
+
+	if (force)
+		cpu = cpumask_first_and(&priv->lmask, mask_val);
+	else
+		cpu = cpumask_first_and_and(&priv->lmask, mask_val,
+					    cpu_online_mask);
+
+	if (cpu >= nr_cpu_ids)
+		return -EINVAL;
+
+	lsic_irq_mask(d);
+	irq_data_update_effective_affinity(d, cpumask_of(cpu));
+	if (!irqd_irq_masked(d))
+		lsic_irq_unmask(d);
+
+	return IRQ_SET_MASK_OK_DONE;
+}
+
+static struct irq_chip lsic_chip = {
+	.name			= "XR/arch LSIC",
+	.irq_mask		= lsic_irq_mask,
+	.irq_unmask		= lsic_irq_unmask,
+	.irq_eoi		= lsic_irq_eoi,
+	.irq_set_affinity	= lsic_set_affinity,
+	.flags			= IRQCHIP_SKIP_SET_WAKE |
+				  IRQCHIP_AFFINITY_PRE_STARTUP,
+};
+
+static int lsic_domain_map(struct irq_domain *d, unsigned int irq,
+			   irq_hw_number_t hwirq)
+{
+	struct lsic_priv *priv = d->host_data;
+
+	irq_domain_set_info(d, irq, hwirq, &lsic_chip, priv, handle_fasteoi_irq,
+			    NULL, NULL);
+	irq_set_noprobe(irq);
+	irq_set_affinity(irq, &priv->lmask);
+
+	return 0;
+}
+
+static int lsic_domain_alloc(struct irq_domain *domain, unsigned int virq,
+			     unsigned int nr_irqs, void *arg)
+{
+	struct irq_fwspec *fwspec = arg;
+	irq_hw_number_t hwirq;
+	unsigned int type;
+
+	int ret = irq_domain_translate_onecell(domain, fwspec, &hwirq, &type);
+	if (ret)
+		return ret;
+
+	if (hwirq + nr_irqs >= LSIC_IRQS)
+		return -EINVAL;
+
+	for (unsigned int i = 0; i < nr_irqs; i++) {
+		ret = lsic_domain_map(domain, virq + i, hwirq + i);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct irq_domain_ops lsic_domain_ops = {
+	.map		= lsic_domain_map,
+	.alloc		= lsic_domain_alloc,
+	.translate	= irq_domain_translate_onecell,
+	.free		= irq_domain_free_irqs_top,
+};
+
+static int lsic_parse_ctx(struct device_node *device, u32 idx, u32 *hwirq,
+			  unsigned long *cpu_hwid, int *cpu)
+{
+	struct of_phandle_args cpu_data;
+	int error = of_irq_parse_one(device, idx, &cpu_data);
+	if (error)
+		return error;
+
+	*cpu_hwid = of_get_cpu_hwid(cpu_data.np, 0);
+	if (*cpu_hwid == ~0UL) {
+		pr_warn("unable to find cpu hwid for %pOF\n", cpu_data.np);
+		return -ENODEV;
+	}
+
+	*hwirq = cpu_data.args[0];
+	*cpu = xr17032_cpu_hwid_to_cpuid(*cpu_hwid);
+	return 0;
+}
+
+static int __init lsic_init(struct device_node *device,
+			    struct device_node *parent)
+{
+	static bool lsic_global_init_done;
+
+	void __iomem *regs = of_iomap(device, 0);
+	if (!regs)
+		return -ENOMEM;
+
+	int error;
+
+	struct fwnode_handle *fwnode = &device->fwnode;
+
+	u32 nr_contexts = of_irq_count(device);
+	if (WARN_ON(!nr_contexts)) {
+		pr_err("%pfwP: no upstream contexts available\n", fwnode);
+		error = -EINVAL;
+		goto fail_free_regs;
+	}
+
+	struct lsic_priv *priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		error = -ENOMEM;
+		goto fail_free_regs;
+	}
+
+	priv->fwnode = fwnode;
+	priv->domain = irq_domain_create_linear(fwnode, LSIC_IRQS,
+						&lsic_domain_ops, priv);
+	if (!priv->domain) {
+		error = -ENOMEM;
+		goto fail_free_priv;
+	}
+
+	for (u32 idx = 0; idx < nr_contexts; idx++) {
+		u32 hwirq;
+		int cpu;
+		unsigned long cpu_hwid;
+
+		error = lsic_parse_ctx(device, idx, &hwirq, &cpu_hwid, &cpu);
+		if (error) {
+			pr_warn("%pfwP: hwirq for context %u not found\n",
+				fwnode, idx);
+			continue;
+		}
+
+		void __iomem *ctx_regs = regs + cpu_hwid * LSIC_STRIDE;
+
+		writel(~0UL, ctx_regs + LSIC_DISA);
+		writel(~0UL, ctx_regs + LSIC_DISA + 4);
+		writel(0, ctx_regs + LSIC_PEND);
+		writel(0, ctx_regs + LSIC_PEND + 4);
+		writel(LSIC_IRQS - 1, ctx_regs + LSIC_IPL);
+
+		if (cpu < 0) {
+			pr_warn("%pfwP: invalid cpuid for context %u\n",
+				fwnode, idx);
+			continue;
+		}
+
+		if (hwirq != LSIC_PARENT_IRQ)
+			continue;
+
+		cpumask_set_cpu(cpu, &priv->lmask);
+
+		struct lsic_handler *handler = per_cpu_ptr(&lsic_handlers, cpu);
+
+		handler->priv = priv;
+		handler->regs = ctx_regs;
+		raw_spin_lock_init(&handler->mask_lock);
+	}
+
+	if (!lsic_global_init_done) {
+		int parent_irq = irq_create_mapping(xr17032_intc_domain,
+						    LSIC_PARENT_IRQ);
+		if (parent_irq)
+			irq_set_chained_handler(parent_irq, lsic_handle_irq);
+
+		lsic_global_init_done = true;
+	}
+
+	pr_info("%pfwP: mapped %u contexts\n", fwnode, nr_contexts);
+	return 0;
+
+fail_free_priv:
+	kfree(priv);
+fail_free_regs:
+	iounmap(regs);
+	return error;
+}
+
+IRQCHIP_DECLARE(xrarch_lsic, "xrarch,lsic", lsic_init);
diff -urN --no-dereference linux-clean/drivers/tty/serial/Kconfig linux-workdir/drivers/tty/serial/Kconfig
--- linux-clean/drivers/tty/serial/Kconfig
+++ linux-workdir/drivers/tty/serial/Kconfig
@@ -1604,6 +1604,15 @@
 	  snippet may be used:
 	    earlycon=esp32s3acm,mmio32,0x60038000
 
+config SERIAL_XRCOMPUTER
+	tristate "XR/computer UART support"
+	depends on OF
+	select SERIAL_CORE
+	select SERIAL_CORE_CONSOLE
+	select SERIAL_EARLYCON
+	help
+	  Driver for the UART controller of the XR/computer platform.
+
 endmenu
 
 config SERIAL_MCTRL_GPIO
diff -urN --no-dereference linux-clean/drivers/tty/serial/Makefile linux-workdir/drivers/tty/serial/Makefile
--- linux-clean/drivers/tty/serial/Makefile
+++ linux-workdir/drivers/tty/serial/Makefile
@@ -92,6 +92,7 @@
 obj-$(CONFIG_SERIAL_UARTLITE)		+= uartlite.o
 obj-$(CONFIG_SERIAL_VT8500)		+= vt8500_serial.o
 obj-$(CONFIG_SERIAL_XILINX_PS_UART)	+= xilinx_uartps.o
+obj-$(CONFIG_SERIAL_XRCOMPUTER)		+= xrcomputer.o
 obj-$(CONFIG_SERIAL_ZS)			+= zs.o
 
 # GPIOLIB helpers for modem control lines
diff -urN --no-dereference linux-clean/drivers/tty/serial/xrcomputer.c linux-workdir/drivers/tty/serial/xrcomputer.c
--- linux-clean/drivers/tty/serial/xrcomputer.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/drivers/tty/serial/xrcomputer.c
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * XR/computer UART driver
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/serial_core.h>
+
+#define UART_CMD_REG	0x00
+#define UART_DATA_REG	0x04
+
+static void xrarch_serial_write(struct uart_port *port, unsigned long reg,
+				u32 v)
+{
+	writel(v, port->membase + reg);
+}
+
+static u32 xrarch_serial_read(struct uart_port *port, unsigned long reg)
+{
+	return readl(port->membase + reg);
+}
+
+static bool xrarch_serial_tx_full(struct uart_port *port)
+{
+	return xrarch_serial_read(port, UART_CMD_REG) != 0;
+}
+
+static void xrarch_serial_put_char(struct uart_port *port, u8 c)
+{
+	xrarch_serial_write(port, UART_DATA_REG, c);
+}
+
+static void xrarch_serial_put_char_sync(struct uart_port *port, u8 c)
+{
+	unsigned long timeout = jiffies + HZ;
+
+	while (xrarch_serial_tx_full(port)) {
+		if (time_after(jiffies, timeout)) {
+			dev_warn(port->dev, "timeout waiting for TX\n");
+			return;
+		}
+
+		cpu_relax();
+	}
+
+	xrarch_serial_put_char(port, c);
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+static int xrarch_serial_poll_get_char(struct uart_port *port)
+{
+	u32 value = xrarch_serial_read(port, UART_DATA_REG);
+
+	if (value != 0xFFFF)
+		return value;
+	else
+		return NO_POLL_CHAR;
+
+}
+#endif
+
+static void xrarch_serial_earlycon_putchar(struct uart_port *port, u8 c)
+{
+	xrarch_serial_put_char_sync(port, c);
+}
+
+static void xrarch_serial_earlycon_write(struct console *con, const char *s,
+				         unsigned int n)
+{
+	struct earlycon_device *dev = con->data;
+
+	uart_console_write(&dev->port, s, n, xrarch_serial_earlycon_putchar);
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+static int xrarch_serial_earlycon_read(struct console *con, char *s,
+				       unsigned int n)
+{
+	struct earlycon_device *dev = con->data;
+	unsigned int num_read = 0;
+
+	while (num_read < n) {
+		int c = xrarch_serial_poll_get_char(&dev->port);
+
+		if (c == NO_POLL_CHAR)
+			break;
+
+		s[num_read++] = c;
+	}
+
+	return num_read;
+}
+#endif
+
+static int __init xrarch_serial_earlycon_setup(struct earlycon_device *device,
+					       const char *options)
+{
+	if (!device->port.membase)
+		return -ENODEV;
+
+	device->con->write = xrarch_serial_earlycon_write;
+#ifdef CONFIG_CONSOLE_POLL
+	device->con->read = xrarch_serial_earlycon_read;
+#endif
+
+	return 0;
+}
+
+OF_EARLYCON_DECLARE(xrarch_serial, "xrarch,serial",
+		    xrarch_serial_earlycon_setup);
+
+MODULE_AUTHOR("monkuous");
+MODULE_DESCRIPTION("XR/computer UART support");
+MODULE_LICENSE("GPL");
diff -urN --no-dereference linux-clean/include/uapi/linux/audit.h linux-workdir/include/uapi/linux/audit.h
--- linux-clean/include/uapi/linux/audit.h
+++ linux-workdir/include/uapi/linux/audit.h
@@ -444,6 +444,7 @@
 #define AUDIT_ARCH_TILEPRO	(EM_TILEPRO|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_UNICORE	(EM_UNICORE|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_XR17032	(EM_XR17032|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_XTENSA	(EM_XTENSA)
 #define AUDIT_ARCH_LOONGARCH32	(EM_LOONGARCH|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_LOONGARCH64	(EM_LOONGARCH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
diff -urN --no-dereference linux-clean/include/uapi/linux/elf-em.h linux-workdir/include/uapi/linux/elf-em.h
--- linux-clean/include/uapi/linux/elf-em.h
+++ linux-workdir/include/uapi/linux/elf-em.h
@@ -67,5 +67,8 @@
 /* Also Panasonic/MEI MN10300, AM33 */
 #define EM_CYGNUS_MN10300 0xbeef
 
+/* XR/17032 */
+#define EM_XR17032	0xb5f0
+
 
 #endif /* _LINUX_ELF_EM_H */
