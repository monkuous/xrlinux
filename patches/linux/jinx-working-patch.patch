diff -urN --no-dereference linux-clean/arch/xr17032/Kconfig linux-workdir/arch/xr17032/Kconfig
--- linux-clean/arch/xr17032/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kconfig
@@ -0,0 +1,18 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config XR17032
+	def_bool y
+	select GENERIC_ATOMIC64
+	select THREAD_INFO_IN_TASK
+	select HAVE_PAGE_SIZE_4KB
+	select ARCH_SPARSEMEM_ENABLE
+	select GENERIC_IOREMAP
+
+config MMU
+	def_bool y
+
+menu "Kernel features"
+
+source "kernel/Kconfig.hz"
+
+endmenu
diff -urN --no-dereference linux-clean/arch/xr17032/Kconfig.debug linux-workdir/arch/xr17032/Kconfig.debug
--- linux-clean/arch/xr17032/Kconfig.debug	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Kconfig.debug
@@ -0,0 +1 @@
+# SPDX-License-Identifier: GPL-2.0-only
diff -urN --no-dereference linux-clean/arch/xr17032/Makefile linux-workdir/arch/xr17032/Makefile
--- linux-clean/arch/xr17032/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/Makefile
@@ -0,0 +1,20 @@
+# This file is included by the global makefile so that you can add your own
+# architecture-specific flags and dependencies.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+
+KBUILD_DEFCONFIG := xr17032_defconfig
+
+UTS_MACHINE := xr17032
+
+KBUILD_CFLAGS += -fno-pic
+
+head-y := arch/xr17032/kernel/head.o
+
+core-y += arch/xr17032/kernel/
+core-y += arch/xr17032/mm/
+
+libs-y += arch/xr17032/lib/
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/Kbuild linux-workdir/arch/xr17032/include/asm/Kbuild
--- linux-clean/arch/xr17032/include/asm/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/Kbuild
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+generic-y += string.h
+generic-y += user.h
+generic-y += kvm_para.h
+generic-y += tlb.h
+generic-y += vmlinux.lds.h
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/asm-extable.h linux-workdir/arch/xr17032/include/asm/asm-extable.h
--- linux-clean/arch/xr17032/include/asm/asm-extable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/asm-extable.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ASM_EXTABLE_H
+#define _ASM_XR17032_ASM_EXTABLE_H
+
+#define EX_TYPE_NONE			0
+#define EX_TYPE_FIXUP			1
+#define EX_TYPE_UACCESS_ERR_ZERO	2
+
+#include <linux/bits.h>
+#include <linux/stringify.h>
+#include <asm/gpr-num.h>
+
+#define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
+	".pushsection	__ex_table, \"a\"\n"		\
+	".balign	4\n"				\
+	".long		(" insn ")\n"		\
+	".long		(" fixup ")\n"		\
+	".short		(" type ")\n"			\
+	".short		(" data ")\n"			\
+	".popsection\n"
+
+#define _ASM_EXTABLE(insn, fixup)	\
+	__ASM_EXTABLE_RAW(#insn, #fixup, __stringify(EX_TYPE_FIXUP), "0")
+
+#define EX_DATA_REG_ERR_SHIFT	0
+#define EX_DATA_REG_ERR		GENMASK(4, 0)
+#define EX_DATA_REG_ZERO_SHIFT	5
+#define EX_DATA_REG_ZERO	GENMASK(9, 5)
+
+#define EX_DATA_REG_DATA_SHIFT	0
+#define EX_DATA_REG_DATA	GENMASK(4, 0)
+#define EX_DATA_REG_ADDR_SHIFT	5
+#define EX_DATA_REG_ADDR	GENMASK(9, 5)
+
+#define EX_DATA_REG(reg, gpr)						\
+	"((.L__gpr_num_" #gpr ") << " __stringify(EX_DATA_REG_##reg##_SHIFT) ")"
+
+#define _ASM_EXTABLE_UACCESS_ERR_ZERO(insn, fixup, err, zero)		\
+	__DEFINE_ASM_GPR_NUMS						\
+	__ASM_EXTABLE_RAW(#insn, #fixup, 				\
+			  __stringify(EX_TYPE_UACCESS_ERR_ZERO),	\
+			  "("						\
+			    EX_DATA_REG(ERR, err) " | "			\
+			    EX_DATA_REG(ZERO, zero)			\
+			  ")")
+
+#define _ASM_EXTABLE_UACCESS_ERR(insn, fixup, err)			\
+	_ASM_EXTABLE_UACCESS_ERR_ZERO(insn, fixup, err, zero)
+
+#endif /* _ASM_XR17032_ASM_EXTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/atomic.h linux-workdir/arch/xr17032/include/asm/atomic.h
--- linux-clean/arch/xr17032/include/asm/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/atomic.h
@@ -0,0 +1,111 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ATOMIC_H
+#define _ASM_XR17032_ATOMIC_H
+
+#ifndef CONFIG_GENERIC_ATOMIC64
+#error "xr17032 does not support 64-bit atomics"
+#endif
+
+#include <asm/cmpxchg.h>
+#include <asm-generic/atomic64.h>
+
+static inline int arch_atomic_read(const atomic_t *v)
+{
+	return READ_ONCE(v->counter);
+}
+
+static inline void arch_atomic_set(atomic_t *v, int i)
+{
+	WRITE_ONCE(v->counter, i);
+}
+
+#define __ATOMIC_OP(op, asm_op)						\
+static inline void arch_atomic_##op(int i, atomic_t *v)			\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %0, %0, %z3\n"			\
+		"	sc  %1, %2, %0\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+}
+
+#define __ATOMIC_OP_RETURN(op, asm_op)					\
+static inline int arch_atomic_##op##_return_relaxed(int i, atomic_t *v)	\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %0, %0, %z3\n"			\
+		"	sc  %1, %2, %0\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+									\
+	return ret;							\
+}
+
+#define __ATOMIC_FETCH_OP(op, asm_op)					\
+static inline int arch_atomic_fetch_##op##_relaxed(int i, atomic_t *v)	\
+{									\
+	int ret;							\
+	unsigned long scratch;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	" asm_op " %1, %0, %z3\n"			\
+		"	sc  %1, %2, %1\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (ret), "=&r" (scratch)				\
+		: "r" (&v->counter), "rO" (i)				\
+		: "memory"						\
+	);								\
+									\
+	return ret;							\
+}
+
+__ATOMIC_OP_RETURN(add, "add")
+__ATOMIC_OP_RETURN(sub, "sub")
+
+__ATOMIC_FETCH_OP(add, "add")
+__ATOMIC_FETCH_OP(sub, "sub")
+__ATOMIC_FETCH_OP(and, "and")
+__ATOMIC_FETCH_OP(or, "or")
+__ATOMIC_FETCH_OP(xor, "xor")
+
+__ATOMIC_OP(add, "add")
+__ATOMIC_OP(sub, "sub")
+__ATOMIC_OP(and, "and")
+__ATOMIC_OP(or, "or")
+__ATOMIC_OP(xor, "xor")
+
+#define arch_atomic_add_return_relaxed arch_atomic_add_return_relaxed
+#define arch_atomic_sub_return_relaxed arch_atomic_sub_return_relaxed
+
+#define arch_atomic_fetch_add_relaxed arch_atomic_fetch_add_relaxed
+#define arch_atomic_fetch_sub_relaxed arch_atomic_fetch_sub_relaxed
+#define arch_atomic_fetch_and_relaxed arch_atomic_fetch_and_relaxed
+#define arch_atomic_fetch_or_relaxed  arch_atomic_fetch_or_relaxed
+#define arch_atomic_fetch_xor_relaxed arch_atomic_fetch_xor_relaxed
+
+#define arch_atomic_add arch_atomic_add
+#define arch_atomic_sub arch_atomic_sub
+#define arch_atomic_and arch_atomic_and
+#define arch_atomic_or  arch_atomic_or
+#define arch_atomic_xor arch_atomic_xor
+
+#endif /* _ASM_XR17032_ATOMIC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cache.h linux-workdir/arch/xr17032/include/asm/cache.h
--- linux-clean/arch/xr17032/include/asm/cache.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cache.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CACHE_H
+#define _ASM_XR17032_CACHE_H
+
+#define L1_CACHE_SHIFT 4
+#define L1_CACHE_BYTES (1 << L1_CACHE_SHIFT)
+
+#endif /* _ASM_XR17032_CACHE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cmpxchg.h linux-workdir/arch/xr17032/include/asm/cmpxchg.h
--- linux-clean/arch/xr17032/include/asm/cmpxchg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cmpxchg.h
@@ -0,0 +1,137 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CMPXCHG_H
+#define _ASM_XR17032_CMPXCHG_H
+
+#include <linux/bug.h>
+
+#define __arch_xchg_masked(mask, ret, scratch, ptr, new)		\
+({									\
+	unsigned long __address = (unsigned long)ptr;			\
+	unsigned long __offset = __address & 3;				\
+	unsigned long __shift = __offset * 8;				\
+	unsigned long __mask = mask << __shift;				\
+	unsigned long __new_shift = (unsigned long)new << __shift;	\
+	unsigned long __ret_shift;					\
+	__address -= __offset;						\
+									\
+	asm volatile(							\
+		"1:	ll  %0, %2\n"					\
+		"	and %1, %0, %z3\n"				\
+		"	or  %1, %1, %z4\n"				\
+		"	sc  %1, %2, %1\n"				\
+		"	beq %1, 1b"					\
+		: "=&r" (__ret_shift), "=&r" (scratch)			\
+		: "r" (__address), "rO" (~__mask), "rO" (__new_shift)	\
+		: "memory"						\
+	);								\
+									\
+	ret = (typeof(ret))((__ret_shift & __mask) >> __shift);		\
+})
+
+#define arch_xchg_relaxed(ptr, new)					\
+({									\
+	typeof(ptr) __ptr = (ptr);					\
+	typeof(*__ptr) __new = (new);					\
+	typeof(*__ptr) __ret;						\
+	unsigned long __scratch;					\
+									\
+	switch (sizeof(*__ptr)) {					\
+	case 1:								\
+		__arch_xchg_masked(0xff, __ret, __scratch, __ptr,	\
+				   __new); 				\
+		break;							\
+	case 2:								\
+		__arch_xchg_masked(0xffff, __ret, __scratch, __ptr,	\
+				   __new); 				\
+		break;							\
+	case 4:								\
+		asm volatile(						\
+			"1:	ll  %0, %2\n"				\
+			"	sc  %1, %2, %z3\n"			\
+			"	beq %1, 1b"				\
+			: "=&r" (__ret), "=&r" (__scratch)		\
+			: "r" (__ptr), "rO" (__new)			\
+			: "memory"					\
+		);							\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+									\
+	__ret;								\
+})
+
+#define __arch_cmpxchg_masked(mask, ret, scratch, ptr, old, new)	\
+({									\
+	unsigned long __address = (unsigned long)ptr;			\
+	unsigned long __offset = __address & 3;				\
+	unsigned long __shift = __offset * 8;				\
+	unsigned long __mask = mask << __shift;				\
+	unsigned long __old_shift = (unsigned long)old << __shift;	\
+	unsigned long __new_shift = (unsigned long)new << __shift;	\
+	unsigned long __ret_shift;					\
+	unsigned long __scratch2;					\
+	__address -= __offset;						\
+									\
+	asm volatile(							\
+		"1:	ll  %1, %3\n"					\
+		"	and %0, %1, %z4\n"				\
+		"	sub %2, %0, %z5\n"				\
+		"	bne %2, 1f\n"					\
+		"	and %1, %1, %z6\n"				\
+		"	or  %1, %1, %z7\n"				\
+		"	sc  %1, %3, %1\n"				\
+		"	beq %1, 1b\n"					\
+		"1:"							\
+		: "=&r" (__ret_shift), "=&r" (scratch),			\
+		  "=&r" (__scratch2)					\
+		: "r" (__address), "rO" (__mask), "rO" (__old_shift),	\
+		  "rO" (~__mask), "rO" (__new_shift)			\
+		: "memory"						\
+	);								\
+									\
+	ret = (typeof(ret))(__ret_shift >> __shift);			\
+})
+
+#define arch_cmpxchg_relaxed(ptr, old, new)				\
+({									\
+	typeof(ptr) __ptr = (ptr);					\
+	typeof(*__ptr) __old = (old);					\
+	typeof(*__ptr) __new = (new);					\
+	typeof(*__ptr) __ret;						\
+	unsigned long __scratch;					\
+									\
+	switch (sizeof(*__ptr)) {					\
+	case 1:								\
+		__arch_cmpxchg_masked(0xff, __ret, __scratch, __ptr,	\
+				      __old, __new);			\
+		break;							\
+	case 2:								\
+		__arch_cmpxchg_masked(0xffff, __ret, __scratch, __ptr,	\
+				      __old, __new);			\
+		break;							\
+	case 4:								\
+		asm volatile(						\
+			"1:	ll  %0, %2\n"				\
+			"	sub %1, %0, %z3\n"			\
+			"	bne %1, 1f\n"				\
+			"	sc  %1, %2, %z4\n"			\
+			"	beq %1, 1b\n"				\
+			"1:"						\
+			: "=&r" (__ret), "=&r" (__scratch)		\
+			: "r" (__ptr), "rO" (__old), "rO" (__new)	\
+			: "memory"					\
+		);							\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+									\
+	__ret;								\
+})
+
+#endif /* _ASM_XR17032_CMPXCHG_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/cr.h linux-workdir/arch/xr17032/include/asm/cr.h
--- linux-clean/arch/xr17032/include/asm/cr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/cr.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CR_H
+#define _ASM_XR17032_CR_H
+
+#define RS_U 0x00000001UL
+#define RS_I 0x00000002UL
+#define RS_M 0x00000004UL
+#define RS_T 0x00000008UL
+
+#define cr_read(cr) 			\
+({ 					\
+	unsigned long __v; 		\
+	asm volatile("mfcr %0, " #cr	\
+		     : "=r" (__v) :	\
+		     : "memory"); 	\
+	__v;				\
+})
+
+#define cr_write(cr, val)				\
+({							\
+	unsigned long __v = (unsigned long)(val);	\
+	asm volatile("mtcr " #cr ", %z0"		\
+		     : : "rO" (__v)			\
+		     : "memory");			\
+})
+
+#endif /* _ASM_XR17032_CR_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/current.h linux-workdir/arch/xr17032/include/asm/current.h
--- linux-clean/arch/xr17032/include/asm/current.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/current.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_CURRENT_H
+#define _ASM_XR17032_CURRENT_H
+
+struct task_struct;
+
+register struct task_struct *current asm("tp");
+
+#endif /* _ASM_XR17032_CURRENT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/elf.h linux-workdir/arch/xr17032/include/asm/elf.h
--- linux-clean/arch/xr17032/include/asm/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/elf.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_ELF_H
+#define _ASM_XR17032_ELF_H
+
+#include <uapi/asm/elf.h>
+
+#define ELF_ARCH	EM_XR17032
+
+#ifndef ELF_CLASS
+#define ELF_CLASS	ELFCLASS32
+#endif
+
+#define ELF_DATA	ELFDATA2LSB
+
+#define ELF_EXEC_PAGESIZE	PAGE_SIZE
+#define ELF_PLATFORM		NULL
+#define ELF_HWCAP		0
+
+#define elf_check_arch(x) (((x)->e_machine == ELF_ARCH) &&		\
+			   ((x)->e_ident[EI_CLASS] == ELF_CLASS))
+
+#define ELF_ET_DYN_BASE		((DEFAULT_MAP_WINDOW / 3) * 2)
+
+#endif /* _ASM_XR17032_ELF_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/extable.h linux-workdir/arch/xr17032/include/asm/extable.h
--- linux-clean/arch/xr17032/include/asm/extable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/extable.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_EXTABLE_H
+#define _ASM_XR17032_EXTABLE_H
+
+struct exception_table_entry {
+	unsigned long insn, fixup;
+	short type, data;
+};
+
+#endif /* _ASM_XR17032_EXTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/gpr-num.h linux-workdir/arch/xr17032/include/asm/gpr-num.h
--- linux-clean/arch/xr17032/include/asm/gpr-num.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/gpr-num.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_GPR_NUM_H
+#define _ASM_XR17032_GPR_NUM_H
+
+#define __DEFINE_ASM_GPR_NUMS					\
+"	.equ	.L__gpr_num_zero,	0\n"			\
+"	.equ	.L__gpr_num_t0,		1\n"			\
+"	.equ	.L__gpr_num_t1,		2\n"			\
+"	.equ	.L__gpr_num_t2,		3\n"			\
+"	.equ	.L__gpr_num_t3,		4\n"			\
+"	.equ	.L__gpr_num_t4,		5\n"			\
+"	.equ	.L__gpr_num_t5,		6\n"			\
+"	.equ	.L__gpr_num_a0,		7\n"			\
+"	.equ	.L__gpr_num_a1,		8\n"			\
+"	.equ	.L__gpr_num_a2,		9\n"			\
+"	.equ	.L__gpr_num_a3,		10\n"			\
+"	.equ	.L__gpr_num_s0,		11\n"			\
+"	.equ	.L__gpr_num_s1,		12\n"			\
+"	.equ	.L__gpr_num_s2,		13\n"			\
+"	.equ	.L__gpr_num_s3,		14\n"			\
+"	.equ	.L__gpr_num_s4,		15\n"			\
+"	.equ	.L__gpr_num_s5,		16\n"			\
+"	.equ	.L__gpr_num_s6,		17\n"			\
+"	.equ	.L__gpr_num_s7,		18\n"			\
+"	.equ	.L__gpr_num_s8,		19\n"			\
+"	.equ	.L__gpr_num_s9,		20\n"			\
+"	.equ	.L__gpr_num_s10,	21\n"			\
+"	.equ	.L__gpr_num_s11,	22\n"			\
+"	.equ	.L__gpr_num_s12,	23\n"			\
+"	.equ	.L__gpr_num_s13,	24\n"			\
+"	.equ	.L__gpr_num_s14,	25\n"			\
+"	.equ	.L__gpr_num_s15,	26\n"			\
+"	.equ	.L__gpr_num_s16,	27\n"			\
+"	.equ	.L__gpr_num_t17,	28\n"			\
+"	.equ	.L__gpr_num_tp,		29\n"			\
+"	.equ	.L__gpr_num_sp,		30\n"			\
+"	.equ	.L__gpr_num_lr,		31\n"
+
+#endif /* _ASM_XR17032_GPR_NUM_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/irqflags.h linux-workdir/arch/xr17032/include/asm/irqflags.h
--- linux-clean/arch/xr17032/include/asm/irqflags.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/irqflags.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_IRQFLAGS_H
+#define _ASM_XR17032_IRQFLAGS_H
+
+#include <asm/cr.h>
+
+static inline unsigned long arch_local_save_flags(void)
+{
+	return cr_read(rs);
+}
+
+static inline void arch_local_irq_restore(unsigned long flags)
+{
+	cr_write(rs, cr_read(rs) | (flags & RS_I));
+}
+
+static inline void arch_local_irq_enable(void)
+{
+	arch_local_irq_restore(RS_I);
+}
+
+static inline void arch_local_irq_disable(void)
+{
+	arch_local_irq_restore(0);
+}
+
+static inline unsigned long arch_local_irq_save(void)
+{
+	unsigned long flags = cr_read(rs);
+	cr_write(rs, flags & ~RS_I);
+	return flags;
+}
+
+static inline int arch_irqs_disabled_flags(unsigned long flags)
+{
+	return !(flags & RS_I);
+}
+
+static inline int arch_irqs_disabled(void)
+{
+	return arch_irqs_disabled_flags(arch_local_save_flags());
+}
+
+#endif /* _ASM_XR17032_IRQFLAGS_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/mmu_context.h linux-workdir/arch/xr17032/include/asm/mmu_context.h
--- linux-clean/arch/xr17032/include/asm/mmu_context.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/mmu_context.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_MMU_CONTEXT_H
+#define _ASM_XR17032_MMU_CONTEXT_H
+
+#include <linux/mm_types.h>
+#include <asm-generic/mm_hooks.h>
+
+#include <linux/mm.h>
+#include <linux/sched.h>
+
+void switch_mm(struct mm_struct *prev, struct mm_struct *next,
+	       struct task_struct *task);
+
+#include <asm-generic/mmu_context.h>
+
+#endif /* _ASM_XR17032_MMU_CONTEXT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/page.h linux-workdir/arch/xr17032/include/asm/page.h
--- linux-clean/arch/xr17032/include/asm/page.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/page.h
@@ -0,0 +1,83 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PAGE_H
+#define _ASM_XR17032_PAGE_H
+
+#include <linux/pfn.h>
+#include <vdso/page.h>
+
+#define PAGE_OFFSET		_AC(0xc0000000, UL)
+
+#ifndef __ASSEMBLER__
+
+#define clear_page(pgaddr)			memset((pgaddr), 0, PAGE_SIZE)
+#define clear_user_page(pgaddr, vaddr, page)	clear_page(pgaddr)
+
+#define copy_page(to, from)			memcpy((to), (from), PAGE_SIZE)
+#define copy_user_page(vto, vfrom, vaddr, topg)	\
+			memcpy((vto), (vfrom), PAGE_SIZE)
+
+typedef struct {
+	unsigned long pgd;
+} pgd_t;
+
+typedef struct {
+	unsigned long pte;
+} pte_t;
+
+typedef struct {
+	unsigned long pgprot;
+} pgprot_t;
+
+typedef struct page *pgtable_t;
+
+#define pte_val(x)	((x).pte)
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x)	((pte_t) { (x) })
+#define __pgd(x)	((pgd_t) { (x) })
+#define __pgprot(x)	((pgprot_t) { (x) })
+
+struct kernel_mapping {
+	unsigned long va_kernel_pa_offset;
+};
+
+extern struct kernel_mapping kernel_map;
+
+#define is_linear_mapping(x)	((x) >= PAGE_OFFSET)
+
+#define linear_mapping_va_to_pa(x)	((unsigned long)(x) - PAGE_OFFSET)
+#define kernel_mapping_va_to_pa(y)	\
+	((unsigned long)(y) - kernel_map.va_kernel_pa_offset)
+
+#define __pa(x)								\
+({									\
+	unsigned long _x = (unsigned long)x;				\
+	is_linear_mapping(_x) ? linear_mapping_va_to_pa(_x) 		\
+			      : kernel_mapping_va_to_pa(_x);		\
+})
+#define __va(x)	((void *)((unsigned long)(x) + PAGE_OFFSET))
+
+#define phys_to_pfn(phys)	(PFN_DOWN(phys))
+
+#define virt_to_pfn(vaddr)	(phys_to_pfn(__pa(vaddr)))
+
+#define virt_to_page(vaddr)	(pfn_to_page(virt_to_pfn(vaddr)))
+
+#define virt_addr_valid(vaddr)	({						\
+	unsigned long _addr = (unsigned long)vaddr;				\
+	(unsigned long)(_addr) >= PAGE_OFFSET && pfn_valid(virt_to_pfn(_addr));	\
+})
+
+#define PTE_FMT	"%08lx"
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#include <asm-generic/memory_model.h>
+#include <asm-generic/getorder.h>
+
+#endif /* _ASM_XR17032_PAGE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/pgalloc.h linux-workdir/arch/xr17032/include/asm/pgalloc.h
--- linux-clean/arch/xr17032/include/asm/pgalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/pgalloc.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PGALLOC_H
+#define _ASM_XR17032_PGALLOC_H
+
+#include <linux/mm.h>
+#include <asm/tlb.h>
+#include <asm-generic/pgalloc.h>
+
+static inline void sync_kernel_mappings(pgd_t *pgd)
+{
+	memcpy(pgd + USER_PTRS_PER_PGD,
+	       init_mm.pgd + USER_PTRS_PER_PGD,
+	       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
+}
+
+static inline pgd_t *pgd_alloc(struct mm_struct *mm)
+{
+	pgd_t *pgd;
+
+	pgd = __pgd_alloc(mm, 0);
+	if (likely(pgd != NULL)) {
+		/* Copy kernel mappings */
+		sync_kernel_mappings(pgd);
+	}
+	return pgd;
+}
+
+static inline void __pte_free_tlb(struct mmu_gather *tlb, pgtable_t pte,
+				  unsigned long addr)
+{
+	tlb_remove_ptdesc(tlb, page_ptdesc(pte));
+}
+
+static inline void pmd_populate_kernel(struct mm_struct *mm,
+				       pmd_t *pmd, pte_t *pte)
+{
+	unsigned long pfn = virt_to_pfn(pte);
+
+	set_pmd(pmd, __pmd((pfn << PFN_PTE_SHIFT) | _PAGE_TABLE));
+}
+
+static inline void pmd_populate(struct mm_struct *mm,
+				pmd_t *pmd, pgtable_t pte)
+{
+	unsigned long pfn = virt_to_pfn(page_address(pte));
+
+	set_pmd(pmd, __pmd((pfn << PFN_PTE_SHIFT) | _PAGE_TABLE));
+}
+
+#endif /* _ASM_XR17032_PGALLOC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/pgtable.h linux-workdir/arch/xr17032/include/asm/pgtable.h
--- linux-clean/arch/xr17032/include/asm/pgtable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/pgtable.h
@@ -0,0 +1,271 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PGTABLE_H
+#define _ASM_XR17032_PGTABLE_H
+
+#include <linux/const.h>
+
+#define PGDIR_SHIFT	22
+#define PGDIR_SIZE	(_AC(1, UL) << PGDIR_SHIFT)
+#define PGDIR_MASK	(~(PGDIR_SIZE - 1))
+
+#define TASK_SIZE		0x80000000
+#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
+#define KERNEL_LINK_ADDR	TASK_SIZE
+
+#ifndef __ASSEMBLER__
+
+#include <asm/tlbflush.h>
+#include <asm-generic/pgtable-nopmd.h>
+#include <linux/mmzone.h>
+
+#define PTRS_PER_PGD	(PAGE_SIZE / sizeof(pgd_t))
+#define PTRS_PER_PTE	(PAGE_SIZE / sizeof(pte_t))
+
+#define KERN_VIRT_SIZE	((PTRS_PER_PGD / 2 * PGDIR_SIZE) / 2)
+
+#define VMALLOC_SIZE	(KERN_VIRT_SIZE >> 1)
+#define VMALLOC_END	PAGE_OFFSET
+#define VMALLOC_START	(PAGE_OFFSET - VMALLOC_SIZE)
+
+#define PFN_PTE_SHIFT	5
+
+#define _PAGE_PRESENT	(1 << 0)
+#define _PAGE_WRITE	(1 << 1)
+#define _PAGE_KERNEL	(1 << 2)
+#define _PAGE_NO_CACHE	(1 << 3)
+#define _PAGE_GLOBAL	(1 << 4)
+#define _PAGE_ACCESSED	(1 << 25)
+#define _PAGE_DIRTY	(1 << 26)
+
+#define _PAGE_CHG_MASK  (~(unsigned long)(_PAGE_PRESENT | _PAGE_WRITE |	\
+					  _PAGE_KERNEL | _PAGE_GLOBAL))
+
+#define _PAGE_PROT_NONE	_PAGE_GLOBAL
+
+#define _PAGE_SWP_EXCLUSIVE (1 << 5)
+
+#define _PAGE_KERNEL_BASE	(_PAGE_PRESENT \
+				| _PAGE_WRITE \
+				| _PAGE_KERNEL \
+				| _PAGE_GLOBAL \
+				| _PAGE_ACCESSED \
+				| _PAGE_DIRTY)
+
+#define _PAGE_TABLE		_PAGE_KERNEL_BASE
+#define _PAGE_IOREMAP		(_PAGE_KERNEL_BASE | _PAGE_NO_CACHE)
+
+#define PAGE_KERNEL		__pgprot(_PAGE_KERNEL_BASE)
+#define PAGE_KERNEL_READ	__pgprot(_PAGE_KERNEL_BASE & ~_PAGE_WRITE)
+#define PAGE_KERNEL_EXEC	__pgprot(_PAGE_KERNEL_BASE)
+#define PAGE_KERNEL_READ_EXEC	__pgprot(_PAGE_KERNEL_BASE & ~_PAGE_WRITE)
+
+#define __page_val_to_pfn(_val)  (((_val) & GENMASK(24, 5)) >> PFN_PTE_SHIFT)
+
+extern pgd_t swapper_pg_dir[];
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero,
+ * used for zero-mapped memory areas, etc.
+ */
+extern unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)];
+#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
+
+#define pgd_ERROR(e) \
+	pr_err("%s:%d: bad pgd " PTE_FMT ".\n", __FILE__, __LINE__, pgd_val(e))
+
+static inline pte_t pfn_pte(unsigned long pfn, pgprot_t prot)
+{
+	return __pte((pfn << PFN_PTE_SHIFT) | pgprot_val(prot));
+}
+
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{
+	return __pte((pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot));
+}
+
+static inline int pte_present(pte_t pte)
+{
+	return pte_val(pte) & (_PAGE_PRESENT | _PAGE_PROT_NONE);
+}
+
+static inline int pte_none(pte_t pte)
+{
+	return pte_val(pte) == 0;
+}
+
+static inline int pte_write(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_WRITE;
+}
+
+static inline int pte_young(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_ACCESSED;
+}
+
+static inline int pte_dirty(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_DIRTY;
+}
+
+static inline unsigned long pte_pfn(pte_t pte)
+{
+	return __page_val_to_pfn(pte_val(pte));
+}
+
+#define pte_page(x)	pfn_to_page(pte_pfn(x))
+
+static inline pte_t pte_mkold(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_ACCESSED);
+}
+
+static inline pte_t pte_mkyoung(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_ACCESSED);
+}
+
+static inline pte_t pte_mkclean(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_DIRTY);
+}
+
+static inline pte_t pte_mkdirty(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_DIRTY);
+}
+
+static inline pte_t pte_mkwrite_novma(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_WRITE);
+}
+
+static inline pte_t pte_wrprotect(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_WRITE);
+}
+
+static inline void set_pte(pte_t *ptep, pte_t pteval)
+{
+	WRITE_ONCE(*ptep, pteval);
+}
+
+void flush_icache_pte(struct mm_struct *mm, pte_t pte);
+
+static inline void __set_pte_at(struct mm_struct *mm, pte_t *ptep, pte_t pteval)
+{
+	if (pte_present(pteval))
+		flush_icache_pte(mm, pteval);
+
+	set_pte(ptep, pteval);
+}
+
+static inline void pte_clear(struct mm_struct *mm,
+			     unsigned long addr, pte_t *ptep)
+{
+	__set_pte_at(mm, ptep, __pte(0));
+}
+
+/*
+ * Encode/decode swap entries and swap PTEs. Swap PTEs are all PTEs that
+ * are !pte_none() && !pte_present().
+ *
+ * Format of swap PTE:
+ *	bit            0:	_PAGE_PRESENT (zero)
+ *	bit            1:	_PAGE_WRITE (zero)
+ *	bit            2:	_PAGE_KERNEL (zero)
+ *	bit            3:	_PAGE_NO_CACHE (zero)
+ *	bit            4:	_PAGE_PROT_NONE (zero)
+ *	bit            5:	exclusive marker
+ *	bits      6 to 11:	swap type
+ *	bits     12 to 31:	swap offset
+ */
+#define __SWP_TYPE_SHIFT	5
+#define __SWP_TYPE_BITS		6
+#define __SWP_TYPE_MASK		((1UL << __SWP_TYPE_BITS) - 1)
+#define __SWP_OFFSET_SHIFT	(__SWP_TYPE_BITS + __SWP_TYPE_SHIFT)
+
+#define MAX_SWAPFILES_CHECK()	\
+	BUILD_BUG_ON(MAX_SWAPFILES_SHIFT > __SWP_TYPE_BITS)
+
+#define __swp_type(x)	(((x).val >> __SWP_TYPE_SHIFT) & __SWP_TYPE_MASK)
+#define __swp_offset(x)	((x).val >> __SWP_OFFSET_SHIFT)
+#define __swp_entry(type, offset) ((swp_entry_t) \
+	{ (((type) & __SWP_TYPE_MASK) << __SWP_TYPE_SHIFT) | \
+	  ((offset) << __SWP_OFFSET_SHIFT) })
+
+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })
+
+static inline bool pte_swp_exclusive(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_SWP_EXCLUSIVE;
+}
+
+static inline pte_t pte_swp_clear_exclusive(pte_t pte)
+{
+	return __pte(pte_val(pte) & ~_PAGE_SWP_EXCLUSIVE);
+}
+
+static inline pte_t pte_swp_mkexclusive(pte_t pte)
+{
+	return __pte(pte_val(pte) | _PAGE_SWP_EXCLUSIVE);
+}
+
+static inline void set_pmd(pmd_t *pmdp, pmd_t pmd)
+{
+	WRITE_ONCE(*pmdp, pmd);
+}
+
+static inline void pmd_clear(pmd_t *pmdp)
+{
+	set_pmd(pmdp, __pmd(0));
+}
+
+static inline int pmd_none(pmd_t pmd)
+{
+	return pmd_val(pmd) == 0;
+}
+
+static inline int pmd_bad(pmd_t pmd)
+{
+	return 1;
+}
+
+static inline int pmd_present(pmd_t pmd)
+{
+	return (pmd_val(pmd) & (_PAGE_PRESENT | _PAGE_PROT_NONE));
+}
+
+static inline struct page *pmd_page(pmd_t pmd)
+{
+	return pfn_to_page(__page_val_to_pfn(pmd_val(pmd)));
+}
+
+#define __pmd_to_phys(pmd)  (__page_val_to_pfn(pmd_val(pmd)) << PAGE_SHIFT)
+
+static inline unsigned long pmd_pfn(pmd_t pmd)
+{
+	return ((__pmd_to_phys(pmd) & PMD_MASK) >> PAGE_SHIFT);
+}
+
+#define pmd_page_vaddr(pmd)	pmd_val(pmd)
+
+static inline void update_mmu_cache_range(struct vm_fault *vmf,
+					  struct vm_area_struct *vma, unsigned long address,
+					  pte_t *ptep, unsigned int nr)
+{
+	while (nr--)
+		local_flush_tlb_page(address + nr * PAGE_SIZE);
+}
+
+#define update_mmu_cache(vma, addr, ptep)	\
+	update_mmu_cache_range(NULL, vma, addr, ptep, 1)
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#endif /* _ASM_XR17032_PGTABLE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/processor.h linux-workdir/arch/xr17032/include/asm/processor.h
--- linux-clean/arch/xr17032/include/asm/processor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/processor.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PROCESSOR_H
+#define _ASM_XR17032_PROCESSOR_H
+
+#define DEFAULT_MAP_WINDOW	TASK_SIZE
+#define STACK_TOP_MAX		TASK_SIZE
+
+#define STACK_ALIGN		4
+#define STACK_TOP		DEFAULT_MAP_WINDOW
+#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
+
+struct pt_regs;
+
+static inline void cpu_relax(void)
+{
+	asm volatile("pause" ::: "memory");
+}
+
+struct thread_struct {
+	/* Callee-saved registers */
+	unsigned long s[18];
+	unsigned long sp;
+	unsigned long lr;
+};
+
+#define INIT_THREAD					\
+{							\
+	.sp = sizeof(init_stack) + (long)&init_stack,	\
+}
+
+#define task_pt_regs(tsk)						\
+	((struct pt_regs *)(task_stack_page(tsk) + THREAD_SIZE		\
+			    - ALIGN(sizeof(struct pt_regs), STACK_ALIGN)))
+
+#define KSTK_EIP(tsk)	(task_pt_regs(tsk)->pc)
+#define KSTK_ESP(tsk)	(task_pt_regs(tsk)->sp)
+
+extern unsigned long __get_wchan(struct task_struct *p);
+
+extern void start_thread(struct pt_regs *regs,
+			 unsigned long pc, unsigned long sp);
+
+#endif /* _ASM_XR17032_PROCESSOR_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/ptrace.h linux-workdir/arch/xr17032/include/asm/ptrace.h
--- linux-clean/arch/xr17032/include/asm/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/ptrace.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_PTRACE_H
+#define _ASM_XR17032_PTRACE_H
+
+#include <uapi/asm/ptrace.h>
+#include <asm/cr.h>
+
+struct pt_regs {
+	unsigned long pc;
+	unsigned long t0;
+	unsigned long t1;
+	unsigned long t2;
+	unsigned long t3;
+	unsigned long t4;
+	unsigned long t5;
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long s0;
+	unsigned long s1;
+	unsigned long s2;
+	unsigned long s3;
+	unsigned long s4;
+	unsigned long s5;
+	unsigned long s6;
+	unsigned long s7;
+	unsigned long s8;
+	unsigned long s9;
+	unsigned long s10;
+	unsigned long s11;
+	unsigned long s12;
+	unsigned long s13;
+	unsigned long s14;
+	unsigned long s15;
+	unsigned long s16;
+	unsigned long s17;
+	unsigned long tp;
+	unsigned long sp;
+	unsigned long lr;
+	unsigned long rs;
+};
+
+#define user_mode(regs) (((regs)->rs & RS_U) != 0)
+
+static inline unsigned long user_stack_pointer(struct pt_regs *regs)
+{
+	return regs->sp;
+}
+
+static inline unsigned long instruction_pointer(struct pt_regs *regs)
+{
+	return regs->pc;
+}
+
+#endif /* _ASM_XR17032_PTRACE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/set_memory.h linux-workdir/arch/xr17032/include/asm/set_memory.h
--- linux-clean/arch/xr17032/include/asm/set_memory.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/set_memory.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SET_MEMORY_H
+#define _ASM_XR17032_SET_MEMORY_H
+
+#define SECTION_ALIGN L1_CACHE_BYTES
+
+#endif /* _ASM_XR17032_SET_MEMORY_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/sparsemem.h linux-workdir/arch/xr17032/include/asm/sparsemem.h
--- linux-clean/arch/xr17032/include/asm/sparsemem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/sparsemem.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SPARSEMEM_H
+#define _ASM_XR17032_SPARSEMEM_H
+
+#ifdef CONFIG_SPARSEMEM
+#define MAX_PHYSMEM_BITS	32
+#define SECTION_SIZE_BITS	25
+#endif
+
+#endif /* _ASM_XR17032_SPARSEMEM_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/syscall.h linux-workdir/arch/xr17032/include/asm/syscall.h
--- linux-clean/arch/xr17032/include/asm/syscall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/syscall.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_SYSCALL_H
+#define _ASM_XR17032_SYSCALL_H
+
+#include <uapi/linux/audit.h>
+
+static inline int syscall_get_arch(struct task_struct *task)
+{
+	return AUDIT_ARCH_XR17032;
+}
+
+#endif /* _ASM_XR17032_SYSCALL_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/thread_info.h linux-workdir/arch/xr17032/include/asm/thread_info.h
--- linux-clean/arch/xr17032/include/asm/thread_info.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/thread_info.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_THREAD_INFO_H
+#define _ASM_XR17032_THREAD_INFO_H
+
+#include <asm/page.h>
+
+#define THREAD_SIZE_ORDER 	0
+#define THREAD_SIZE		(PAGE_SIZE << THREAD_SIZE_ORDER)
+#define THREAD_ALIGN		THREAD_SIZE
+
+#ifndef __ASSEMBLER__
+
+struct thread_info {
+	unsigned long 	flags;
+	int		preempt_count;
+};
+
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.flags		= 0,			\
+	.preempt_count	= INIT_PREEMPT_COUNT,	\
+}
+
+#define TIF_NEED_RESCHED 0
+#define TIF_NOTIFY_SIGNAL 1
+#define TIF_SIGPENDING 2
+#define TIF_SYSCALL_TRACE 3
+#define TIF_MEMDIE 4
+#define TIF_NOTIFY_RESUME 5
+
+#define _TIF_NEED_RESCHED (1 << TIF_NEED_RESCHED)
+#define _TIF_NOTIFY_SIGNAL (1 << TIF_NOTIFY_SIGNAL)
+#define _TIF_SIGPENDING (1 << TIF_SIGPENDING)
+#define _TIF_SYSCALL_TRACE (1 << TIF_SYSCALL_TRACE)
+#define _TIF_MEMDIE (1 << TIF_MEMDIE)
+#define _TIF_NOTIFY_RESUME (1 << TIF_NOTIFY_RESUME)
+
+#endif /* !defined(__ASSEMBLER__) */
+
+#endif /* _ASM_XR17032_THREAD_INFO_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/tlb.h linux-workdir/arch/xr17032/include/asm/tlb.h
--- linux-clean/arch/xr17032/include/asm/tlb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/tlb.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_TLB_H
+#define _ASM_XR17032_TLB_H
+
+struct mmu_gather;
+
+static void tlb_flush(struct mmu_gather *tlb);
+
+#define tlb_flush tlb_flush
+#include <asm-generic/tlb.h>
+
+static inline void tlb_flush(struct mmu_gather *tlb)
+{
+	if (tlb->fullmm || tlb->need_flush_all || tlb->freed_tables)
+		flush_tlb_mm(tlb->mm);
+	else
+		flush_tlb_mm_range(tlb->mm, tlb->start, tlb->end,
+				   tlb_get_unmap_size(tlb));
+}
+
+#endif /* _ASM_XR17032_TLB_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/tlbflush.h linux-workdir/arch/xr17032/include/asm/tlbflush.h
--- linux-clean/arch/xr17032/include/asm/tlbflush.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/tlbflush.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_TLBFLUSH_H
+#define _ASM_XR17032_TLBFLUSH_H
+
+#include <linux/mm_types.h>
+
+void flush_tlb_mm(struct mm_struct *mm);
+void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
+			unsigned long end, unsigned int page_size);
+void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr);
+void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+		     unsigned long end);
+void flush_tlb_kernel_range(unsigned long start, unsigned long end);
+
+static inline void local_flush_tlb_page(unsigned long addr)
+{
+	asm volatile(
+		"mtcr itbctrl, %0\n"
+		"mtcr dtbctrl, %0"
+		:
+		: "r" (addr & ~3UL)
+		: "memory"
+	);
+}
+
+#endif /* _ASM_XR17032_TLBFLUSH_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/uaccess.h linux-workdir/arch/xr17032/include/asm/uaccess.h
--- linux-clean/arch/xr17032/include/asm/uaccess.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/uaccess.h
@@ -0,0 +1,251 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_UACCESS_H
+#define _ASM_XR17032_UACCESS_H
+
+#include <asm/asm-extable.h>
+#include <asm/extable.h>
+#include <asm/pgtable.h>
+#include <asm-generic/access_ok.h>
+#include <linux/compiler.h>
+#include <linux/errno.h>
+
+unsigned long __must_check __asm_copy_to_user(void __user *to,
+					      const void *from,
+					      unsigned long n);
+unsigned long __must_check __asm_copy_from_user(void *to,
+						const void __user *from,
+						unsigned long n);
+
+#ifdef CONFIG_CC_HAS_ASM_GOTO_OUTPUT
+#define __get_user_asm(x, ptr, label)				\
+	asm_goto_output(					\
+		"1:\n"						\
+		"	mov %0, %1\n"				\
+		_ASM_EXTABLE_UACCESS_ERR(1b, %l2, %0)		\
+		: "=&r" (x)					\
+		: "m" (*(ptr)) : : label			\
+	)
+#define __get_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u32 __lo, __hi;						\
+	asm_goto_output(					\
+		"1:\n"						\
+		"	mov %0, %2\n"				\
+		"2:\n"						\
+		"	mov %1, %3\n"				\
+		_ASM_EXTABLE_UACCESS_ERR(1b, %l4, %0)		\
+		_ASM_EXTABLE_UACCESS_ERR(2b, %l4, %0)		\
+		: "=&r" (__lo), "=r" (__hi)			\
+		: "m" (__ptr[0]), "m" (__ptr[1])		\
+		: : label);                                     \
+	(x) = (typeof(x))((typeof((x) - (x)))(			\
+		(((u64)__hi << 32) | __lo)));			\
+} while (0)
+#else /* !CONFIG_CC_HAS_ASM_GOTO_OUTPUT */
+#define __get_user_asm(x, ptr, label)				\
+do {								\
+	long __gua_err = 0;					\
+	asm volatile(						\
+		"1:\n"						\
+		"	mov %1, %2\n"				\
+		"2:\n"						\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(1b, 2b, %0, %1)	\
+		: "+r" (__gua_err), "=&r" (x)			\
+		: "m" (*(ptr))					\
+	);							\
+	if (__gua_err)						\
+		goto label;					\
+} while (0)
+#define __get_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u32 __lo, __hi;						\
+	long __gu8_err = 0;					\
+	__asm__ __volatile__ (					\
+		"1:\n"						\
+		"	mov %1, %3\n"				\
+		"2:\n"						\
+		"	mov %2, %4\n"				\
+		"3:\n"						\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(1b, 3b, %0, %1)	\
+		_ASM_EXTABLE_UACCESS_ERR_ZERO(2b, 3b, %0, %1)	\
+		: "+r" (__gu8_err), "=&r" (__lo), "=r" (__hi)	\
+		: "m" (__ptr[0]), "m" (__ptr[1]));		\
+	if (__gu8_err) {					\
+		__hi = 0;					\
+		goto label;					\
+	}							\
+	(x) = (typeof(x))((typeof((x) - (x)))(			\
+		(((u64)__hi << 32) | __lo)));			\
+} while (0)
+#endif /* CONFIG_CC_HAS_ASM_GOTO_OUTPUT */
+
+#define __get_user_nocheck(x, __gu_ptr, label)				\
+do {									\
+	if (!IS_ALIGNED((uintptr_t)__gu_ptr, sizeof(*__gu_ptr))) {	\
+		if (__asm_copy_from_user((void *)&(x),			\
+					 (const void *)__gu_ptr,	\
+			                 sizeof(*__gu_ptr))) 		\
+			goto label;					\
+		break;							\
+	}								\
+	switch (sizeof(*__gu_ptr)) {					\
+	case 1:								\
+	case 2:								\
+	case 4:								\
+		__get_user_asm((x), __gu_ptr, label);			\
+		break;							\
+	case 8:								\
+		__get_user_8((x), __gu_ptr, label);			\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+} while (0)
+
+#define __get_user_error(x, ptr, err)					\
+do {									\
+	__label__ __gu_failed;						\
+									\
+	__get_user_nocheck(x, ptr, __gu_failed);			\
+		err = 0;						\
+		break;							\
+__gu_failed:								\
+		x = 0;							\
+		err = -EFAULT;						\
+} while (0)
+
+#define __get_user(x, ptr)					\
+({								\
+	const typeof(*(ptr)) __user *__gu_ptr = (ptr);		\
+	long __gu_err = 0;					\
+	typeof(x) __gu_val;					\
+								\
+	__chk_user_ptr(__gu_ptr);				\
+								\
+	__get_user_error(__gu_val, __gu_ptr, __gu_err);		\
+								\
+	(x) = __gu_val;						\
+								\
+	__gu_err;						\
+})
+
+#define get_user(x, ptr)					\
+({								\
+	const typeof(*(ptr)) __user *__p = (ptr);		\
+	might_fault();						\
+	access_ok(__p, sizeof(*__p)) ?				\
+		__get_user((x), __p) :				\
+		((x) = (__force typeof(x))0, -EFAULT);		\
+})
+
+#define __put_user_asm(x, ptr, label)				\
+do {								\
+	typeof(*(ptr)) __x = x;					\
+	asm goto(						\
+		"1:\n"						\
+		"	mov %1, %z0\n"				\
+		_ASM_EXTABLE(1b, %l2)				\
+		: : "rO" (__x), "m"(*(ptr)) : : label);		\
+} while (0)
+#define __put_user_8(x, ptr, label)				\
+do {								\
+	u32 __user *__ptr = (u32 __user *)(ptr);		\
+	u64 __x = (typeof((x)-(x)))(x);				\
+	asm goto(						\
+		"1:\n"						\
+		"	mov %2, %z0\n"				\
+		"2:\n"						\
+		"	mov %3, %z1\n"				\
+		_ASM_EXTABLE(1b, %l4)				\
+		_ASM_EXTABLE(2b, %l4)				\
+		: : "rO" ((u32)__x), "rO" ((u32)(__x >> 32)),	\
+			"m" (__ptr[0]),				\
+			"m" (__ptr[1]) : : label);		\
+} while (0)
+
+#define __put_user_nocheck(x, __gu_ptr, label)				\
+do {									\
+	if (!IS_ALIGNED((uintptr_t)__gu_ptr, sizeof(*__gu_ptr))) {	\
+		if (__asm_copy_to_user((void *)__gu_ptr,		\
+				       (const void *)&((x)),		\
+				       sizeof(*__gu_ptr)))		\
+			goto label;					\
+		break;							\
+	}								\
+	switch (sizeof(*__gu_ptr)) {					\
+	case 1:								\
+	case 2:								\
+	case 4:								\
+		__put_user_asm((x), __gu_ptr, label);			\
+		break;							\
+	case 8:								\
+		__put_user_8((x), __gu_ptr, label);			\
+		break;							\
+	default:							\
+		BUILD_BUG();						\
+	}								\
+} while (0)
+
+#define __put_user_error(x, ptr, err)				\
+do {								\
+	__label__ err_label;					\
+	__put_user_nocheck(x, ptr, err_label);			\
+	break;							\
+err_label:							\
+	(err) = -EFAULT;					\
+} while (0)
+
+#define __put_user(x, ptr)					\
+({								\
+	typeof(*(ptr)) __user *__gu_ptr = (ptr); 		\
+	typeof(*__gu_ptr) __val = (x);				\
+	long __pu_err = 0;					\
+								\
+	__chk_user_ptr(__gu_ptr);				\
+								\
+	__put_user_error(__val, __gu_ptr, __pu_err);		\
+								\
+	__pu_err;						\
+})
+
+#define put_user(x, ptr)					\
+({								\
+	typeof(*(ptr)) __user *__p = (ptr);			\
+	might_fault();						\
+	access_ok(__p, sizeof(*__p)) ? __put_user((x), __p)	\
+				     : -EFAULT;			\
+})
+
+static inline unsigned long
+raw_copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	return __asm_copy_from_user(to, from, n);
+}
+
+static inline unsigned long
+raw_copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	return __asm_copy_to_user(to, from, n);
+}
+
+extern unsigned long __must_check __clear_user(void __user *addr,
+					       unsigned long n);
+
+static inline unsigned long __must_check clear_user(void __user *to,
+						    unsigned long n)
+{
+	might_fault();
+	return access_ok(to, n) ? __clear_user(to, n) : n;
+}
+
+extern long strncpy_from_user(char *dest, const char __user *src, long count);
+
+extern long __must_check strnlen_user(const char __user *str, long n);
+
+#endif /* _ASM_XR17032_UACCESS_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/asm/vmalloc.h linux-workdir/arch/xr17032/include/asm/vmalloc.h
--- linux-clean/arch/xr17032/include/asm/vmalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/asm/vmalloc.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _ASM_XR17032_VMALLOC_H
+#define _ASM_XR17032_VMALLOC_H
+
+#endif /* _ASM_XR17032_VMALLOC_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/byteorder.h linux-workdir/arch/xr17032/include/uapi/asm/byteorder.h
--- linux-clean/arch/xr17032/include/uapi/asm/byteorder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/byteorder.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_BYTEORDER_H
+#define _UAPI_ASM_XR17032_BYTEORDER_H
+
+#include <linux/byteorder/little_endian.h>
+
+#endif /* _UAPI_ASM_XR17032_BYTEORDER_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/elf.h linux-workdir/arch/xr17032/include/uapi/asm/elf.h
--- linux-clean/arch/xr17032/include/uapi/asm/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/elf.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_ELF_H
+#define _UAPI_ASM_XR17032_ELF_H
+
+#include <asm/ptrace.h>
+
+typedef struct user_regs_struct elf_gregset_t;
+typedef unsigned int elf_fpregset_t;
+
+#endif /* _UAPI_ASM_XR17032_ELF_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/posix_types.h linux-workdir/arch/xr17032/include/uapi/asm/posix_types.h
--- linux-clean/arch/xr17032/include/uapi/asm/posix_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/posix_types.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_POSIX_TYPES_H
+#define _UAPI_ASM_XR17032_POSIX_TYPES_H
+
+typedef unsigned long	__kernel_size_t;
+typedef long		__kernel_ssize_t;
+typedef long		__kernel_ptrdiff_t;
+#define __kernel_size_t __kernel_size_t
+
+#include <asm-generic/posix_types.h>
+
+#endif /* _UAPI_ASM_XR17032_POSIX_TYPES_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/ptrace.h linux-workdir/arch/xr17032/include/uapi/asm/ptrace.h
--- linux-clean/arch/xr17032/include/uapi/asm/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/ptrace.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_PTRACE_H
+#define _UAPI_ASM_XR17032_PTRACE_H
+
+/* must be a prefix of struct pt_regs */
+struct user_regs_struct {
+	unsigned long pc;
+	unsigned long t0;
+	unsigned long t1;
+	unsigned long t2;
+	unsigned long t3;
+	unsigned long t4;
+	unsigned long t5;
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+	unsigned long s0;
+	unsigned long s1;
+	unsigned long s2;
+	unsigned long s3;
+	unsigned long s4;
+	unsigned long s5;
+	unsigned long s6;
+	unsigned long s7;
+	unsigned long s8;
+	unsigned long s9;
+	unsigned long s10;
+	unsigned long s11;
+	unsigned long s12;
+	unsigned long s13;
+	unsigned long s14;
+	unsigned long s15;
+	unsigned long s16;
+	unsigned long s17;
+	unsigned long tp;
+	unsigned long sp;
+	unsigned long lr;
+};
+
+#endif /* _UAPI_ASM_XR17032_PTRACE_H */
diff -urN --no-dereference linux-clean/arch/xr17032/include/uapi/asm/sigcontext.h linux-workdir/arch/xr17032/include/uapi/asm/sigcontext.h
--- linux-clean/arch/xr17032/include/uapi/asm/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/include/uapi/asm/sigcontext.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#ifndef _UAPI_ASM_XR17032_SIGCONTEXT_H
+#define _UAPI_ASM_XR17032_SIGCONTEXT_H
+
+#endif /* _UAPI_ASM_XR17032_SIGCONTEXT_H */
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/Makefile linux-workdir/arch/xr17032/kernel/Makefile
--- linux-clean/arch/xr17032/kernel/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for the XR/17032 Linux kernel
+#
+
+always-$(KBUILD_BUILTIN) += vmlinux.lds
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/asm-offsets.c linux-workdir/arch/xr17032/kernel/asm-offsets.c
--- linux-clean/arch/xr17032/kernel/asm-offsets.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/asm-offsets.c
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+void asm_offsets(void);
+
+void asm_offsets(void)
+{
+}
diff -urN --no-dereference linux-clean/arch/xr17032/kernel/vmlinux.lds.S linux-workdir/arch/xr17032/kernel/vmlinux.lds.S
--- linux-clean/arch/xr17032/kernel/vmlinux.lds.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/kernel/vmlinux.lds.S
@@ -0,0 +1,137 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <asm/pgtable.h>
+#define LOAD_OFFSET KERNEL_LINK_ADDR
+
+#include <asm/vmlinux.lds.h>
+#include <asm/page.h>
+#include <asm/cache.h>
+#include <asm/thread_info.h>
+#include <asm/set_memory.h>
+
+#include <linux/sizes.h>
+
+OUTPUT_ARCH(xr17032)
+ENTRY(_start)
+
+jiffies = jiffies_64;
+
+SECTIONS
+{
+	. = LOAD_OFFSET;
+	_start = .;
+	HEAD_TEXT_SECTION
+	. = ALIGN(PAGE_SIZE);
+
+	.text : {
+		_text = .;
+		_stext = .;
+		TEXT_TEXT
+		SCHED_TEXT
+		LOCK_TEXT
+		KPROBES_TEXT
+		ENTRY_TEXT
+		IRQENTRY_TEXT
+		SOFTIRQENTRY_TEXT
+		_etext = .;
+	}
+
+	. = ALIGN(SECTION_ALIGN);
+	__init_begin = .;
+	__init_text_begin = .;
+	.init.text : AT(ADDR(.init.text) - LOAD_OFFSET) ALIGN(SECTION_ALIGN) { \
+		_sinittext = .;						\
+		INIT_TEXT						\
+		_einittext = .;						\
+	}
+
+	/* we have to discard exit text and such at runtime, not link time */
+	__exittext_begin = .;
+	.exit.text :
+	{
+		EXIT_TEXT
+	}
+	__exittext_end = .;
+
+	__init_text_end = .;
+	. = ALIGN(SECTION_ALIGN);
+	/* Start of init data section */
+	__init_data_begin = .;
+	INIT_DATA_SECTION(16)
+
+	.init.pi : {
+		KEEP(*(.init.pi*))
+	}
+
+	.init.bss : {
+		KEEP(*(.init.bss*))	/* from the EFI stub */
+	}
+	.exit.data :
+	{
+		EXIT_DATA
+	}
+
+	RUNTIME_CONST_VARIABLES
+
+	PERCPU_SECTION(L1_CACHE_BYTES)
+
+	.rel.dyn : {
+		*(.rel.dyn*)
+	}
+
+	.rela.dyn : ALIGN(8) {
+		__rela_dyn_start = .;
+		*(.rela .rela*)
+		__rela_dyn_end = .;
+	}
+
+	__init_data_end = .;
+
+	. = ALIGN(8);
+	.alternative : {
+		__alt_start = .;
+		KEEP(*(.alternative))
+		__alt_end = .;
+	}
+	__init_end = .;
+
+	/* Start of data section */
+	_sdata = .;
+	RO_DATA(SECTION_ALIGN)
+	.srodata : {
+		*(.srodata*)
+	}
+
+	. = ALIGN(SECTION_ALIGN);
+	_data = .;
+
+	RW_DATA(L1_CACHE_BYTES, PAGE_SIZE, THREAD_ALIGN)
+
+	.got : { *(.got*) }
+
+#ifdef CONFIG_RELOCATABLE
+	.data.rel : { *(.data.rel*) }
+	.plt : { *(.plt) }
+	.dynamic : { *(.dynamic) }
+	.dynsym : { *(.dynsym) }
+	.dynstr : { *(.dynstr) }
+	.hash : { *(.hash) }
+	.gnu.hash : { *(.gnu.hash) }
+#endif
+
+	/* End of data section */
+	_edata = .;
+
+	BSS_SECTION(PAGE_SIZE, PAGE_SIZE, 0)
+
+	_end = .;
+
+	STABS_DEBUG
+	DWARF_DEBUG
+	ELF_DETAILS
+
+	DISCARDS
+}
diff -urN --no-dereference linux-clean/arch/xr17032/lib/Makefile linux-workdir/arch/xr17032/lib/Makefile
--- linux-clean/arch/xr17032/lib/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+lib-y += memset.o
diff -urN --no-dereference linux-clean/arch/xr17032/lib/memset.S linux-workdir/arch/xr17032/lib/memset.S
--- linux-clean/arch/xr17032/lib/memset.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-workdir/arch/xr17032/lib/memset.S
@@ -0,0 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2025 monkuous
+ */
+
+#include <linux/linkage.h>
diff -urN --no-dereference linux-clean/include/uapi/linux/audit.h linux-workdir/include/uapi/linux/audit.h
--- linux-clean/include/uapi/linux/audit.h
+++ linux-workdir/include/uapi/linux/audit.h
@@ -444,6 +444,7 @@
 #define AUDIT_ARCH_TILEPRO	(EM_TILEPRO|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_UNICORE	(EM_UNICORE|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_XR17032	(EM_XR17032|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_XTENSA	(EM_XTENSA)
 #define AUDIT_ARCH_LOONGARCH32	(EM_LOONGARCH|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_LOONGARCH64	(EM_LOONGARCH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
diff -urN --no-dereference linux-clean/include/uapi/linux/elf-em.h linux-workdir/include/uapi/linux/elf-em.h
--- linux-clean/include/uapi/linux/elf-em.h
+++ linux-workdir/include/uapi/linux/elf-em.h
@@ -67,5 +67,8 @@
 /* Also Panasonic/MEI MN10300, AM33 */
 #define EM_CYGNUS_MN10300 0xbeef
 
+/* XR/17032 */
+#define EM_XR17032	0xb5f0
+
 
 #endif /* _LINUX_ELF_EM_H */
